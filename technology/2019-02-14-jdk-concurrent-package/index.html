<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="一、同步控制1. 重入锁重入锁可以替代 synchronized 关键字，在 jdk5.0 早期，重入锁的性能好于 synchronized，从 jdk6.0 开始，synchronized 优化，两者性能差不多了。 重入锁例子： 1234567891011121314151617181920212223242526public class ReenterLock implements Runna">
<meta name="keywords" content="java,高并发程序设计">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK 并发包小结">
<meta property="og:url" content="http://koon.cool/technology/2019-02-14-jdk-concurrent-package/index.html">
<meta property="og:site_name" content="空城">
<meta property="og:description" content="一、同步控制1. 重入锁重入锁可以替代 synchronized 关键字，在 jdk5.0 早期，重入锁的性能好于 synchronized，从 jdk6.0 开始，synchronized 优化，两者性能差不多了。 重入锁例子： 1234567891011121314151617181920212223242526public class ReenterLock implements Runna">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190202154736.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190203140459.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190203233118.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190205163029.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190205163226.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190205225937.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190206233820.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190208234838.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190208235327.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190208235648.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190210110501.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190210170913.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190213233354.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190213235359.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190214004331.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190214004910.png">
<meta property="og:updated_time" content="2021-11-07T17:34:44.397Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JDK 并发包小结">
<meta name="twitter:description" content="一、同步控制1. 重入锁重入锁可以替代 synchronized 关键字，在 jdk5.0 早期，重入锁的性能好于 synchronized，从 jdk6.0 开始，synchronized 优化，两者性能差不多了。 重入锁例子： 1234567891011121314151617181920212223242526public class ReenterLock implements Runna">
<meta name="twitter:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190202154736.png">
    
    
        
          
              <link rel="shortcut icon" href="//koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/fish_opt.png">
          
        
        
          
            <link rel="icon" type="image/png" href="//koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/fish_opt.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="//koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/fish_opt.png">
          
        
    
    <!-- title -->
    <title>JDK 并发包小结</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">    
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="https://github.com/koonchen">Projects</a></li>
         
          <li><a href="https://valeriehu1995.github.io">PigChain</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/technology/2019-02-21-lock-optimize/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/technology/2018-12-29-jvm-understanding-chapter13/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&text=JDK 并发包小结"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&is_video=false&description=JDK 并发包小结"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JDK 并发包小结&body=Check out this article: http://koon.cool/technology/2019-02-14-jdk-concurrent-package/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&name=JDK 并发包小结&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、同步控制"><span class="toc-number">1.</span> <span class="toc-text">一、同步控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-重入锁"><span class="toc-number">1.1.</span> <span class="toc-text">1. 重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-中断响应"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 中断响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-锁申请等待限时"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 锁申请等待限时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-公平锁"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 公平锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Condition-条件"><span class="toc-number">1.2.</span> <span class="toc-text">2. Condition 条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-信号量"><span class="toc-number">1.3.</span> <span class="toc-text">3. 信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-读写锁"><span class="toc-number">1.4.</span> <span class="toc-text">4. 读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-倒计时器"><span class="toc-number">1.5.</span> <span class="toc-text">5. 倒计时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-循环栅栏"><span class="toc-number">1.6.</span> <span class="toc-text">6. 循环栅栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-LockSupport"><span class="toc-number">1.7.</span> <span class="toc-text">7. LockSupport</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、ThreadPool"><span class="toc-number">2.</span> <span class="toc-text">二、ThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是线程池"><span class="toc-number">2.1.</span> <span class="toc-text">1. 什么是线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JDK-对线程池的支持"><span class="toc-number">2.2.</span> <span class="toc-text">2. JDK 对线程池的支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-核心线程池的实现"><span class="toc-number">2.3.</span> <span class="toc-text">3. 核心线程池的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-拒绝策略"><span class="toc-number">2.4.</span> <span class="toc-text">4. 拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-自定义线程创建"><span class="toc-number">2.5.</span> <span class="toc-text">5. 自定义线程创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-扩展线程池"><span class="toc-number">2.6.</span> <span class="toc-text">6. 扩展线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-优化线程池线程的数量"><span class="toc-number">2.7.</span> <span class="toc-text">7. 优化线程池线程的数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-在线程池中寻找堆栈"><span class="toc-number">2.8.</span> <span class="toc-text">8. 在线程池中寻找堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Fork-Join-框架"><span class="toc-number">2.9.</span> <span class="toc-text">9. Fork/Join 框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、JDK-的并发容器"><span class="toc-number">3.</span> <span class="toc-text">三、JDK 的并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-并发集合"><span class="toc-number">3.1.</span> <span class="toc-text">1. 并发集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-线程安全的-HashMap"><span class="toc-number">3.2.</span> <span class="toc-text">2. 线程安全的 HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-有关-List-的线程安全"><span class="toc-number">3.3.</span> <span class="toc-text">3. 有关 List 的线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-高效读写队列-ConcurrentLinkedQueue"><span class="toc-number">3.4.</span> <span class="toc-text">4. 高效读写队列 ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-不变模式下的-CopyOnWriteArrayList"><span class="toc-number">3.5.</span> <span class="toc-text">5. 不变模式下的 CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-数据共享通道"><span class="toc-number">3.6.</span> <span class="toc-text">6. 数据共享通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-跳表"><span class="toc-number">3.7.</span> <span class="toc-text">7. 跳表</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        JDK 并发包小结
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">空城</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-02-13T16:00:00.000Z" itemprop="datePublished">2019-02-14</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/technology/">technology</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/高并发程序设计/">高并发程序设计</a>
    </div>


    </div>
  </header>
  <!-- 
 -->
  <div class="content" itemprop="articleBody">
    <h1 id="一、同步控制"><a href="#一、同步控制" class="headerlink" title="一、同步控制"></a>一、同步控制</h1><h2 id="1-重入锁"><a href="#1-重入锁" class="headerlink" title="1. 重入锁"></a>1. 重入锁</h2><p>重入锁可以替代 synchronized 关键字，在 jdk5.0 早期，重入锁的性能好于 synchronized，从 jdk6.0 开始，synchronized 优化，两者性能差不多了。</p>
<p>重入锁例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重入锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000000</span>; ++j) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReenterLock tl = <span class="keyword">new</span> ReenterLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    t1.start(); t2.start();</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常直观地，我们发现和 synchronized 相比，这里的重入锁更加注重<strong>锁的细节</strong>，包括了上锁和解锁的过程。更加灵活。</p>
<p>值得注意的是，重入锁可以<strong>重入</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，一个线程连续两次获得同一把锁。这是允许的！<strong>如果同一个线程多次获得锁，那么在释放锁的时候，也必须释放相同次数！</strong>如果释放锁的次数多，那么会得到一个 <code>java. lang. IllegalMonitorState Exception</code> 异常，反之，如果释放锁的次数少了，那么相当于线程还持有这个锁，因此，其他线程也无法进入临界区。</p>
<h3 id="1-1-中断响应"><a href="#1-1-中断响应" class="headerlink" title="1.1 中断响应"></a>1.1 中断响应</h3><p>对于 synchronized 来说，如果一个线程在等待锁，那么结局是<strong>获得锁</strong>或者是<strong>保持等待</strong>；对于重入锁而言，还有可能被<strong>中断</strong>。</p>
<blockquote>
<p>如果一个线程正在等待锁，那么它收到一个通知，被告知无须再等待，可以停止了。</p>
</blockquote>
<p>下面的代码就是一个死锁，得益于锁中断，我已解决这个死锁！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IntLock</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line">        lock1.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        lock2.lockInterruptibly();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lock2.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        lock1.lockInterruptibly();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) lock1.unlock();</span><br><span class="line">      <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) lock2.unlock();</span><br><span class="line">      System.out.println(Thread.currentThread().getId() + <span class="string">":线程退出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    IntLock r1 = <span class="keyword">new</span> IntLock(<span class="number">1</span>);</span><br><span class="line">    IntLock r2 = <span class="keyword">new</span> IntLock(<span class="number">2</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 中断其中一个线程</span></span><br><span class="line">    t2.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到一个方法，叫做 <code>lockInterruptiby()</code> ，这个方法可以对中断进行响应，<strong>在等待锁的过程中，可以响应中断</strong>。</p>
<blockquote>
<p>线程 t1 获取了 lock1 ，然后去获取 lock2 ；线程 t2 获取了 lock2 ，然后去获取 lock1 。现在他们相互等待了，现在，我们中断一个线程，<strong>t2 会放弃对于 lock1 的申请，同时释放 lock2</strong> 。</p>
</blockquote>
<p>所以，最后完成任务的是 t1 ，而 t2 线程放弃任务直接退出，释放资源。</p>
<h3 id="1-2-锁申请等待限时"><a href="#1-2-锁申请等待限时" class="headerlink" title="1.2 锁申请等待限时"></a>1.2 锁申请等待限时</h3><p>避免死锁的另外一种方法是<strong>限时等待</strong>，给定一个时间，让线程自动放弃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"get lock failed"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock.isHeldByCurrentThread()) lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TimeLock tl = <span class="keyword">new</span> TimeLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的方法，是使用了 <code>tryLock()</code> ，第一个参数是等待时间，第二个参数是计时单位。这个例子中，用于持有锁长达 6s ，另外一个线程会申请失败。当然，这个不会导致死锁了。</p>
<blockquote>
<p><code>tryLock()</code> 方法也可以不需要参数。立即获取或者立即失败。同样不会死锁。</p>
</blockquote>
<p>现在我们看一个非常绕的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">":My Job done"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock2.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock1.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>外层是一个 while 循环</strong>，线程1执行这里，然后线程2和它相反。如果不是 <code>tryLock()</code> 就非常容易死锁了，但是这里不会，因为是 <code>tryLock()</code> 嘛，立即返回结果，有意思的是这里的代码不能这样更改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getId() + <span class="string">":My Job done"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock2.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock1.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样改将报错！</strong>这是因为，我们假设有两个线程，线程1现在有 lock1 ，线程2现在有 lock2 ，此刻，线程1尝试获取 lock2 ，就是 <code>try{}</code> 代码里再用 <code>try{}</code> ，去获取 lock2 ，使用的是 <code>tryLock()</code> ，那么，现在我们失败了，于是执行到 <code>finally{}</code> ，<strong>问题在这里</strong>，我们没有 lock2 啊！所以这样改是错的。</p>
<h3 id="1-3-公平锁"><a href="#1-3-公平锁" class="headerlink" title="1.3 公平锁"></a>1.3 公平锁</h3><p>在大多情况下，锁都是非公平的，系统在一个锁可用的时候，从等待列表中随机挑选一个，因此不能保证其公平性。公平锁的特点是：<strong>不会产生解，只要排队，总会得到资源</strong>。如果使用 synchronized 关键字，那么锁就是非公平的。重入锁可以设置公平性，当 fair 为 true 时，锁公平。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>实现公平锁要维护一个有序序列</strong>，因此公平锁的实现成本较高，性能相对较低，默认情况下，锁是非公平的。下面的代码突出了公平锁的特点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公平锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock fairLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fairLock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 获得锁"</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fairLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FairLock r1 = <span class="keyword">new</span> FairLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(r1, <span class="string">"Thread_t1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(r1, <span class="string">"Thread_t2"</span>);</span><br><span class="line">    t1.start(); t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公平锁的情况下，t1 和 t2 将轮流获得锁，而在非公平锁的情况下，<strong>一个线程会倾向于再次获取已经持有的锁</strong>。</p>
<p>重入锁的实现，主要集中在 Java 层面，包含三个要素：</p>
<ol>
<li>原子状态。原子状态使用 CAS 操作来存储当前锁的状态，判断锁是否已经被别的线程持有。</li>
<li>等待队列。所有没有请求到锁的线程，会进入等待队列进行等待，待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作。</li>
<li>阻塞原语 park() 和 unpark() ，用来挂起和恢复线程。没有得到锁的线程将会被挂起。</li>
</ol>
<h2 id="2-Condition-条件"><a href="#2-Condition-条件" class="headerlink" title="2. Condition 条件"></a>2. Condition 条件</h2><p>我们知道 <code>wait()</code> 和 <code>notify()</code> 是配合 synchronized 关键字使用的，而 Condition 是与重入锁相关联的。</p>
<p>主要有下面几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 类似于 Object.wait(); 可以响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>; <span class="comment">// 与 await(); 的区别在于不响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>; <span class="comment">// 类似于 Object.notify(); 方法</span></span><br></pre></td></tr></table></figure>
<p>下面是一个小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockCondition</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Condition</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Condition conditon = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      conditon.await(); <span class="comment">// 释放了这把锁，进行等待</span></span><br><span class="line">      System.out.println(<span class="string">"Thread is going on"</span>); <span class="comment">// 又获得了锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReenterLockCondition tl = <span class="keyword">new</span> ReenterLockCondition();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    conditon.signal(); <span class="comment">// 从队列中唤醒一个线程</span></span><br><span class="line">    lock.unlock(); <span class="comment">// 把锁谦让给唤醒的线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的第27行，<strong>如果我们仅仅只是唤醒了一个线程，而不放弃这个锁，那么那个线程也是没有办法继续执行的</strong>。</p>
<p>在 JDK 内部，也使用了重入锁和 Condition ，比如 ArrayBlockingQueue 。</p>
<h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h2><p>信号量是锁的扩展，无论是 synchronized 和 ReentrantLock ，一次只允许一个线程访问一个资源，而信号量可以指定多个线程，同时访问一个资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> <span class="comment">//第二个参数可以指定是否公平</span></span></span><br></pre></td></tr></table></figure>
<p>信号量的主要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="comment">// 尝试获取一个准入许可，若无法获得，将等待，直到获取或中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span> <span class="params">()</span> <span class="comment">// 不响应中断</span></span></span><br><span class="line"><span class="function">ublic <span class="keyword">boolean</span> <span class="title">tryAcquire</span> <span class="params">()</span> <span class="comment">// 立即返回，不等待</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span> <span class="params">()</span> <span class="comment">// 释放一个许可，其他线程可以进行资源访问</span></span></span><br></pre></td></tr></table></figure>
<p>小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemapDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      semp.acquire(); <span class="comment">// 获取一个锁</span></span><br><span class="line">      <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getId() + <span class="string">": done!"</span>);</span><br><span class="line">      semp.release(); <span class="comment">// 释放一个锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newFixedThreadPool(<span class="number">20</span>); <span class="comment">// 开启20个线程</span></span><br><span class="line">    <span class="keyword">final</span> SemapDemo demo = <span class="keyword">new</span> SemapDemo();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">      exec.submit(demo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，因为我们设置信号量为5，所以会分组完成。</p>
<h2 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4. 读写锁"></a>4. 读写锁</h2><p>ReadWriteLock 是 Jdk5 中提供的读写分离锁。假设有线程 A1、A2、A3 用来写，线程 B1、B2、B3 用来读，如果是重入锁或者内部锁那么理论上来讲：<strong>读之间、读写之间、写之间</strong>都是串行操作。这显然是不合理的。</p>
<p>读写锁允许多线程<strong>同时读</strong>，使得 B1、B2、B3 之间真正并行。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190202154736.png" alt></p>
<p>下面有个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 读写锁</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock(); <span class="comment">// 模拟读操作</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>); <span class="comment">// 读操作的耗时越多，读写锁的优势更加明显</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(Lock lock, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock(); <span class="comment">// 模拟写操作</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      value = index;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">    Runnable readRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          demo.handleRead(readLock); <span class="comment">// 并行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Runnable writeRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          demo.handleWrite(writeLock, <span class="keyword">new</span> Random().nextInt()); <span class="comment">// 串行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(readRunnable).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(writeRunnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用读写锁，上面的代码只要2秒多，而重入锁需要进行20多秒。</p>
<h2 id="5-倒计时器"><a href="#5-倒计时器" class="headerlink" title="5. 倒计时器"></a>5. 倒计时器</h2><p>CountDownLatch 中，CountDown 在英文中为倒计时，Latch 为门闩。</p>
<blockquote>
<p>把门锁起来，不让里面的线程跑出来，因此，这个工具通常用来控制线程等待。<strong>它让一个线程等待直到倒计时结束，再开始执行</strong>。</p>
</blockquote>
<p>比如火箭发射，火箭发射前，要等待所有的检查完毕，才能点火，执行。</p>
<p>下面就是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLoatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 倒计时器</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); <span class="comment">// 倒计时器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> CountDownLoatchDemo demo = <span class="keyword">new</span> CountDownLoatchDemo();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟检查任务</span></span><br><span class="line">      Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">      System.out.println(<span class="string">"check complete"</span>);</span><br><span class="line">      end.countDown(); <span class="comment">// 一个线程完成任务，倒计时器减一</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 线程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      exec.submit(demo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待检查</span></span><br><span class="line">    end.await(); <span class="comment">// 等到10个线程完成方可继续</span></span><br><span class="line">    <span class="comment">// 发射火箭</span></span><br><span class="line">    System.out.println(<span class="string">"File!"</span>);</span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述逻辑如下：</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190203140459.png" alt></p>
<h2 id="6-循环栅栏"><a href="#6-循环栅栏" class="headerlink" title="6. 循环栅栏"></a>6. 循环栅栏</h2><p>CyclicBarrier 是另外一个多线程并发控制工具，和 CountDownLatch 类似，它实现线程间的计数等待，但是它的功能更加复杂且强大。</p>
<p>前面的 Cyclic 意为循环，也就是说这个计数器可以反复使用，<strong>假如我们将计数器设置为10，那么凑齐第一批10个线程后，计数器就会归零，然后接着凑齐下一批10个线程，这就是循环栅栏内在的含义</strong>。</p>
<p>比 CountDownLatch 略微强大的地方，CyclicBarrier 可以接收一个参数作为 barrierAction 。所谓的 barrierAction 就是当计数器完成一次计数后，系统会执行的动作。</p>
<p>下面第一个参数是等待数，第二个参数是执行的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span>;</span><br></pre></td></tr></table></figure>
<p>比如下面的司令命令士兵的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 循环栅栏</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String soldier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(CyclicBarrier cyclic, String soldier)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.soldier = soldier;</span><br><span class="line">      <span class="keyword">this</span>.cyclic = cyclic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待所有士兵到齐</span></span><br><span class="line">        cyclic.await();</span><br><span class="line">        doWork(); <span class="comment">// 执行任务</span></span><br><span class="line">        <span class="comment">// 等待所有士兵任务完成</span></span><br><span class="line">        cyclic.await();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(Math.abs(<span class="keyword">new</span> Random().nextInt() % <span class="number">10000</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(soldier + <span class="string">":任务完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> flag;</span><br><span class="line">      <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        N = n;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">          System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个，任务完成！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个，集合完成！"</span>);</span><br><span class="line">          flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">      Thread[] allSoldier = <span class="keyword">new</span> Thread[N];</span><br><span class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">      CyclicBarrier cyclic = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));</span><br><span class="line">      <span class="comment">// 设置屏障点，主要是为了执行这个方法</span></span><br><span class="line">      System.out.println(<span class="string">"集合队伍！"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        System.out.println(<span class="string">"士兵"</span> + i + <span class="string">"报道！"</span>);</span><br><span class="line">        allSoldier[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclic, <span class="string">"士兵"</span> + i));</span><br><span class="line">        allSoldier[i].start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>CyclicBarrier.await()</code> 以后每一个士兵线程集合完毕，之后再次使用该方法，将进行下一次计数，这次是监控士兵是否已经完成了任务。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190203233118.png" alt></p>
<p>这里可能有一个异常是 BrokenBarrierException ，一旦遇到这个异常，则表示当前的 CyclicBarrier 已经破损了，可能系统已经出现了问题没有办法达到线程到齐。</p>
<p>如果我们插入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">  allSoldier[<span class="number">0</span>].interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将产生1个 InterruptedException 和9个 BrokenBarrierException 。</p>
<h2 id="7-LockSupport"><a href="#7-LockSupport" class="headerlink" title="7. LockSupport"></a>7. LockSupport</h2><p>LockSupport 是一个非常方便实用的线程阻塞工具，它可以在线程内任意位置让线程阻塞。<strong>和 <code>Thread.suspend()</code> 相比，它弥补了由于 <code>resume()</code> 在前发生，导致线程无法继续执行</strong>。它不会像 <code>Object.wait()</code> 相比，它不需要先获取对象的锁，也不会抛出 InterruptedException 异常。</p>
<p>LockSupport 的静态方法 <code>park()</code> 可以阻塞当前线程，类似的还有 <code>parkNanos()</code>、<code>parkUntil()</code> 等<br>方法。它们实现了一个限时的等待。</p>
<p>我们重写关于 <code>suspend()</code> 永久挂起的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LockSupport</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">  <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">        System.out.println(<span class="string">"in "</span> + getName());</span><br><span class="line">        LockSupport.park();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    LockSupport.unpark(t1); LockSupport.unpark(t2);</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们依然不能保证 <code>unpark()</code> 在 <code>park()</code> 后执行，<strong>但是可以正常结束</strong>。只有合适因为 LockSupport 内部使用了类似信号量的机制，每为一个线程准备一个许可，如果许可可用，那么 <code>park()</code> 会立即返回，并消费这个许可。不可用时，会阻塞。而 <code>unpark()</code> 会让一个许可可用，与信号量不同的是，许可不可能超过一个，永远只有一个！</p>
<blockquote>
<p>即使 <code>unpark()</code> 在 <code>park()</code> 前执行，它也可以在下一次 <code>park()</code> 的时候返回。</p>
</blockquote>
<p>虽然 LockSupport 不会抛出 <code>InterruptedException</code> 异常，但是我们可以通过 <code>Thread.interrupted()</code> 等方法获取中断标志。</p>
<h1 id="二、ThreadPool"><a href="#二、ThreadPool" class="headerlink" title="二、ThreadPool"></a>二、ThreadPool</h1><p>最简单的线程创建和回收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>上面的代码在 <code>run()</code> 之后自动回收该线程。<strong>对线程的使用必须掌握一个度，在有限的范围内，增加线程的数量可以明显提高系统的吞吐量</strong>。</p>
<h2 id="1-什么是线程池"><a href="#1-什么是线程池" class="headerlink" title="1. 什么是线程池"></a>1. 什么是线程池</h2><p>避免系统频繁创建和销毁线程，让创建的线程进行复用。好比数据库连接池。<strong>创建线程变成了从线程池获得空闲线程，关闭线程变成了向池子归还线程</strong>。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190205163029.png" alt></p>
<h2 id="2-JDK-对线程池的支持"><a href="#2-JDK-对线程池的支持" class="headerlink" title="2. JDK 对线程池的支持"></a>2. JDK 对线程池的支持</h2><p>为了更好的控制多线程，JDK 有一套 Executor 框架，帮助开发人员有效进行线程控制，其本质就是一个线程池。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190205163226.png" alt></p>
<p>这些成员都在 java.util.concurrent 包中，是并发包的核心类。其中 ThreadPoolExecutor 表示一个线程池，Executors 类则扮演线程池工厂的角色，通过它获得一个拥有特定功能的线程池，ThreadPoolExecutor 类实现了 Executor 接口，因此通过它，任何 Runnable 对象都可以被 ThreadPoolExecutor 线程池调度。</p>
<p>Executor 框架提供了各种类型的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor Service <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> <span class="comment">// 返回固定线程数量的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> <span class="comment">// 返回只有一个线程的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadpool</span><span class="params">()</span> <span class="comment">// 返回一个根据实际情况调整线程数量的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadscheduledExecutor</span><span class="params">()</span> <span class="comment">// ScheduledExecutorService 接口在 ExecutorService 接口上扩展了给定时间执行某任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolsize)</span> <span class="comment">// 和上面的区别在于线程池数量可以指定</span></span></span><br></pre></td></tr></table></figure>
<p>下面是一个简单的例子，创建一个线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 固定大小的线程池</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(System.currentTimeMillis() + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">    ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      es.submit(task); <span class="comment">// 提交任务</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我们一直有提到计划任务，它返回一个 ScheduledExecutorService 对象，它可以根据时间对线程进行调度，具体方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit); <span class="comment">// 在给定的时间，对任务进行一次调度</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay (Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit);</span><br></pre></td></tr></table></figure>
<p>要知道一点，ScheduledExecutorService 并不一定会立即安排执行任务，它其实是一个计划任务的作用，<strong>会在指定时间，进行调度</strong>。</p>
<p>关于 <code>scheduleAtFixedTime()</code> 和 <code>scheduleWithFixedDelay()</code> 的区别如下：</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190205225937.png" alt></p>
<p><strong>对于 rate 而言，任务的频率是一定的，上一次任务开始到下一次任务开始，经过了一个周期时间；对于 delay 而言，上一次任务结束，经过 delay 时间后，再开始下一次的任务</strong>。</p>
<p>下面是一个关于 <code>scheduleAtFixedRate()</code> 方法的调用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorServiceDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// scheduleAtFixedRate 方法的例子</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 如果前面的任务没有完成，则调度不会启动</span></span><br><span class="line">    ses.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          System.out.println(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务周期是 2S ，任务的实际执行是 1S ，两秒调用一次。</p>
<blockquote>
<p><strong>如果任务执行的时间超过周期，那么周期被拉长到任务执行的长度</strong>。</p>
</blockquote>
<p>任务如果中断，那么不会永久执行！要好好做异常处理。</p>
<h2 id="3-核心线程池的实现"><a href="#3-核心线程池的实现" class="headerlink" title="3. 核心线程池的实现"></a>3. 核心线程池的实现</h2><p>那么对于核心的几个线程池，使用了 <code>newFixedThreadPool()</code> 方法，<code>newSingleThreadExecutor()</code> 方法还有 <code>newCachedThreadPool()</code> 方法，虽然看起来创建的线程有着完全不同的特点，<strong>但是内部均使用 <code>ThreadPoolExecutor</code> 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads</span><br><span class="line">                          OL, TimeUnit.MILLISECONDS</span><br><span class="line">                          <span class="keyword">new</span> LinkedBlockingQueue &lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutor Service</span><br><span class="line">      (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                          OL, TimeUnit.MILLISECONDS,</span><br><span class="line">                          <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAXVALUE,</span><br><span class="line">                          <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 ThreadPoolExecutor 类的封装吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span> <span class="params">(<span class="keyword">int</span> corePoolsize, // 线程池中线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> maximumPoolSize, // 线程池中最大的线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> keepAliveTime, // 当超过 corePoolSize 时，多余线程的存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                        TimeUnit unit, // keepAliveTime 的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue, // 被提交但仍未执行的任务</span></span></span><br><span class="line"><span class="function"><span class="params">                        ThreadFactory threadFactory, // 线程工厂，用于创建线程</span></span></span><br><span class="line"><span class="function"><span class="params">                        RejectedExecutionHandler handler // 拒绝策略)</span></span></span><br></pre></td></tr></table></figure>
<p>其中值得注意的 workQueue ，是一个 BlockingQueue 接口的对象，仅仅用于存放 Runnable 对象，在 ThreadPoolExecutor 的构造函数中有以下几种 BlockingQueue ：</p>
<ul>
<li><strong>直接提交队列</strong>：该功能由 SynchronousQueue 对象提供，这是一个特殊的 BlockingQueue 。它没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除都要等待一个插入操作。</li>
</ul>
<blockquote>
<p>任务提交到 SynchronousQueue 不会被真实保存，而是将新任务提交给线程执行，如果没有空闲进程，则尝试创建新的进程，<strong>如果进行数量已经最大，则执行拒绝策略</strong>。因此使用 SynchronousQueue 队列，通常要设置 maximumPoolSize 值。</p>
</blockquote>
<ul>
<li><strong>有界任务队列</strong>：通过 ArrayBlockingQueue 实现，有新任务时，如果任务数量小于 corePoolSize ，则优先创建新的线程，若大于 corePoolSize ，则将任务加入等待队列，若队列已满，则在总数不大于 maximumPoolSize 的情况下，创建新的线程执行任务，若大于 maximumPoolSize ，则执行拒绝策略。</li>
</ul>
<blockquote>
<p>有界队列在队列装满时，才可能将线程数提升到 corePoolSize 以上，除非系统繁忙，否则将确保线程数维持在 corePoolSize 。</p>
</blockquote>
<ul>
<li><strong>无界任务队列</strong>：无界任务队列通过 LinkedBlockingQueue 类实现，当有新的任务到来，系统线程数小于 corePoolSize 时，会生成新的线程执行任务，但达到 corePoolSize 后，不会继续增加了。若还有任务，而没有空闲线程，则进入队列等待，直到耗尽系统内存。</li>
<li><strong>优先任务队列</strong>：通过 PriorityBlockingQueue 实现，它是特殊的无界队列，之前的有界和无界队列都是按照先进先出算法处理任务的，而 PriorityBlockingQueue 则可以通过任务自身的优先级顺序先后执行（确保高优先级任务先执行）。</li>
</ul>
<p>使用 <code>newFixedThreadPool()</code> 方法将返回一个 corePoolSize 和 maximumPoolSize 大小一样的使用<strong>无界任务队列</strong>的线程池。使用的是 LinkedBlockingQueue 任务队列。使用这个任务队列存放无法立即执行的任务。</p>
<p>使用 <code>newCachedThreadPool()</code> 方法将返回 corePoolSize 为 0 ，maximumPoolSize 无穷大的线程池，没有任务时，线程池中没有现成，当任务被提交，线程池将使用空闲的线程执行任务，若无空闲线程，则将任务加入 SynchronounsQueue 队列，直接提交队列，它迫使线程池增加新的线程执行任务，当任务完毕，由于 corePoolSize 为 0 ，因此空闲线程会在指定时间内被回收。</p>
<p>下面是 ThreadPoolExecutor 线程池的核心调度逻辑：</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190206233820.png" alt></p>
<h2 id="4-拒绝策略"><a href="#4-拒绝策略" class="headerlink" title="4. 拒绝策略"></a>4. 拒绝策略</h2><p>JDK 内置如下拒绝策略：</p>
<ul>
<li>AbortPolicy 策略：该策略会直接抛出异常，阻止系统正常工作。</li>
<li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li>
<li>DiscardOldestPolicy 策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy 策略：该策略默默地丢弃无法处理的任务，不予仼何处理。如果允许任务丢失，我觉得这可能是最好的一种方案了吧!</li>
</ul>
<p>这些策略都实现了 RejectedExecutionHandler 接口，我们可以自己扩展这个接口，该接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>; <span class="comment">// r 是请求执行的任务，executor 是当前的线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码执行需要 100 毫秒，因此有大量任务被直接丢弃：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectThreadPoolDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(System.currentTimeMillis() + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">    ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">10</span>), <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        System.out.println(r.toString() + <span class="string">" is discard"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; ++i) &#123;</span><br><span class="line">      es.submit(task);</span><br><span class="line">      Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-自定义线程创建"><a href="#5-自定义线程创建" class="headerlink" title="5. 自定义线程创建"></a>5. 自定义线程创建</h2><p>我们开始思考一个问题：线程池里的线程是哪里来的？最开始的时候，线程通过 ThreadFactory 创建。ThreadFactory 是一个接口，它只有一个方法，用来创建线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面的案例使用自定义的 ThreadFactory ，一方面记录了线程的创建，另一方面将所有线程设置为守护线程，这样主线程退出的时候，会强制销毁线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 自定义线程创建</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(System.currentTimeMillis() + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">    ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"create "</span> + t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-扩展线程池"><a href="#6-扩展线程池" class="headerlink" title="6. 扩展线程池"></a>6. 扩展线程池</h2><p>虽然线程池已经有了，但是我们需要对它扩展，比如任务开始、结束的时间，或者其他一些功能。ThreadPoolExecutor 是一个可以扩展的线程池，有 <code>beforeExecute()</code> 、 <code>afterExecute()</code> 、 <code>terminated()</code> 三个接口对线程池进行控制。</p>
<p>在 <code>ThreadPoolExecutor.Worker.runTask()</code> 方法内部有这样的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">beforeExecute(thread, task); <span class="comment">// 运行前</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  task.run(); <span class="comment">// 运行任务</span></span><br><span class="line">  ran = <span class="keyword">true</span>;</span><br><span class="line">  afterExecute(task, <span class="keyword">null</span>); <span class="comment">// 任务执行后</span></span><br><span class="line">  ++completedTasks;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ran) afterExecute(task, ex); <span class="comment">// 运行结束</span></span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 Worker 是 ThreadPoolExecutor 的内部类，实现了 Runnable 接口。ThreadPoolExecutor 线程池中的线程正是 Worker 实例。<code>Worker.runTask()</code> 方法会被线程池以多线程模式异步调用，就是说这个方法会同时被多个线程访问，因此这里的 <code>beforeExecute()</code> 和 <code>afterExecute()</code> 接口也将同时被多线程访问。</p>
<p>默认下，这两个方法是空的，我们可以对其扩展，对线程池运行状态跟踪，输出有用的调试信息，下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtThreadPool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 扩展线程池</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"正在执行:Thread ID:"</span> + Thread.currentThread().getId() + <span class="string">", Task name = "</span> + name);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;()) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备执行："</span> + ((MyTask) r).name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行完成："</span> + ((MyTask) r).name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      MyTask task = <span class="keyword">new</span> MyTask(<span class="string">"Task-"</span> + i);</span><br><span class="line">      es.execute(task);</span><br><span class="line">      Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    es.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有意思的是这里使用的是 <code>execute()</code> 而不是 <code>submit()</code> 。</p>
<ul>
<li><code>execute(Runnable x)</code> 没有返回值。可以执行任务，但无法判断任务是否成功完成。（异步执行）</li>
<li><code>submit(Runnable task)</code> 返回一个 Future 。通过 get 等待直到获取到检索结果为止。（同步执行）</li>
</ul>
<h2 id="7-优化线程池线程的数量"><a href="#7-优化线程池线程的数量" class="headerlink" title="7. 优化线程池线程的数量"></a>7. 优化线程池线程的数量</h2><p>在 《Java Concurrency in Practice》 选中有一个估算线程池带下的公式：</p>
<script type="math/tex; mode=display">
Ncpu = CPU 的数量\\
Ucpu = 目标的使用率，0 \leq Ucpu \leq 1\\
W/C = 等待时间与计算时间的比率</script><p>最优的池的大小：</p>
<script type="math/tex; mode=display">
Nthreads = Ncpu * Ucpu * (1 + W/C)</script><p>在 Java 中，我么可以通过如下方法获取可用 CPU 数量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure>
<h2 id="8-在线程池中寻找堆栈"><a href="#8-在线程池中寻找堆栈" class="headerlink" title="8. 在线程池中寻找堆栈"></a>8. 在线程池中寻找堆栈</h2><p>计算两个数的商：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DivTask</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> re = a / b;</span><br><span class="line">    System.out.println(re);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor pools = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      pools.submit(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码只有4个输出，当除数 i 为0，结果没有计算，一个简单的方法是放弃 <code>submit()</code> ，使用 <code>execute()</code> 。</p>
<p>这里我们可以得到一些错误信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "pool-1-thread-1" java.lang.ArithmeticException: / by zero</span><br><span class="line">  at threadPool.DivTask.run(DivTask.java:19)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>我们还想要一个重要信息，就是任务在哪里提交的？与其以后加班，不如扩展 ThreadPoolExecutor 线程池，让它在调度任务之前，先保存一下提交任务线程的堆栈信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.execute(wrap(command, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">"Client stack trace"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task, <span class="keyword">final</span> Exception clientStack, String clientThreadName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          clientStack.printStackTrace(); <span class="comment">// 这里的参数含义是保存着提交任务的线程的堆栈信息</span></span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor pools = <span class="keyword">new</span> TraceThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    <span class="comment">// 错误堆栈中可以看到哪里提交的任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      pools.execute(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在代码报错还将显示以下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Exception: Client stack trace</span><br><span class="line">  at threadPool.TraceThreadPoolExecutor.clientTrace(TraceThreadPoolExecutor.java:22)</span><br><span class="line">  at threadPool.TraceThreadPoolExecutor.execute(TraceThreadPoolExecutor.java:13)</span><br><span class="line">  at threadPool.TraceThreadPoolExecutor.main(TraceThreadPoolExecutor.java:43)</span><br></pre></td></tr></table></figure>
<p>我们现在找到了任务提交的地方。</p>
<h2 id="9-Fork-Join-框架"><a href="#9-Fork-Join-框架" class="headerlink" title="9. Fork/Join 框架"></a>9. Fork/Join 框架</h2><p>分而治之是非常有效处理大量数据的方法，著名的 MapReduce 也是采用了分而治之的思想，在 Linux 平台，函数 <code>fork()</code> 用来创建子进程，使得系统进程可以多一个执行分支，在 Java 中类似，而 <code>join()</code> 的意思是等待，使用了 <code>fork()</code> 以后多了一个执行分支，所以需要等待。</p>
<p>在 JDK 中，有一个 ForkJoinPool 线程池，对于 <code>fork()</code> 方法并不急着开启的，而是交给 ForkJoinPool 线程池进行处理。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190208234838.png" alt></p>
<p>大多数情况下一个物理线程需要处理多个逻辑任务，每个线程需要一个<strong>任务队列</strong>，可能存在：线程 A 已经将任务完成，而 B 还有任务要处理，线程 A 将帮助线程 B ，达到平衡，这是一种互助，如下图所示。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190208235327.png" alt></p>
<blockquote>
<p>当线程帮助别人的时候，总是从底部开始拿数据，这样避免了数据的竞争。</p>
</blockquote>
<p>下面是一个 ForkJoinPool 的重要接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以向 ForkJoinPool 线程池提交一个 ForkJoinTask 任务，这样的任务就是支持 <code>fork()</code> 和 <code>join()</code> 的任务，而它有两个重要的子类，RecursiveAction 和 RecursiveTask ，他们分别表示没有返回值的任务和可以携带返回值的任务。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190208235648.png" alt></p>
<p>下面是一个小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// fork/join demo</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start = start;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> canCompute = (end - start) &lt; THRESHOLD;</span><br><span class="line">    <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 分任务咯，100个</span></span><br><span class="line">      <span class="keyword">long</span> step = (start + end) / <span class="number">100</span>;</span><br><span class="line">      ArrayList&lt;CountTask&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">long</span> pos = start;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastOne = pos + step;</span><br><span class="line">        <span class="keyword">if</span> (lastOne &gt; end) lastOne = end;</span><br><span class="line">        CountTask subTask = <span class="keyword">new</span> CountTask(pos, lastOne);</span><br><span class="line">        pos += step + <span class="number">1</span>;</span><br><span class="line">        subTasks.add(subTask);</span><br><span class="line">        subTask.fork();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (CountTask t : subTasks) &#123;</span><br><span class="line">        sum += t.join();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    CountTask task = <span class="keyword">new</span> CountTask(<span class="number">0</span>, <span class="number">200000L</span>);</span><br><span class="line">    ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">long</span> res = result.get();</span><br><span class="line">      System.out.println(<span class="string">"sum + "</span> + res);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkJoin 线程池使用一个无锁的栈来管理空闲的线程，如果工作线程暂时取不到可用的任务，则可能挂起，挂起线程被压入由线程池维护的栈中，待将来有任务时，再唤醒这些线程。</p>
<h1 id="三、JDK-的并发容器"><a href="#三、JDK-的并发容器" class="headerlink" title="三、JDK 的并发容器"></a>三、JDK 的并发容器</h1><h2 id="1-并发集合"><a href="#1-并发集合" class="headerlink" title="1. 并发集合"></a>1. 并发集合</h2><p>JDK 提供的这些容器大部分在 java.util.concurrent 包中，这些容器主要如下：</p>
<ul>
<li>ConcurrentHashMap：这是一个高效的并发 HashMap 。你可以理解为一个线程安全的 HashMap 。</li>
<li>CopyOnWriteArrayList：这是一个 List ，从名字看就是和 ArrayList 是一族的。在<strong>读多写少</strong>的场合，这个 List 的性能非常好，远远好于 Vector 。</li>
<li>ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看做一个线程安全的 Linkedlist 。</li>
<li>BlockingQueue：这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li>
<li>ConcurrentSkipListMap：跳表的实现。这是一个 Map ，使用跳表的数据结构进行快速查找。</li>
</ul>
<p>此外，Vector 也是线程安全，但是性能和上述专用工具没得比，另外 Collections 工具类可以帮助我们将任意集合包装成线程安全的集合。</p>
<h2 id="2-线程安全的-HashMap"><a href="#2-线程安全的-HashMap" class="headerlink" title="2. 线程安全的 HashMap"></a>2. 线程安全的 HashMap</h2><p>做到线程安全的 HashMap ，一种可行的是 <code>Colletions.synchronizedMap()</code> 方法包装我们的 HashMap ，下面的 HashMap 就是线程安全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Collections.synchronizedMap()</code> 会生成一个名为 SynchronizedMap 的 Map 。它使用了委托，将自己所有 Map 相关的功能交给传入的 HashMap 实现，而自己则负责保证线程安全。</p>
</blockquote>
<p>首先，我们用 SynchronizedMap 包装一个 Map ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">197</span>...L;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; m; <span class="comment">// Backing Map</span></span><br><span class="line">  <span class="keyword">final</span> Object mutex; <span class="comment">// Object on which to synchronize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们通过 mutex 实现对这个 m 的互斥操作。比如，对于 <code>Map.get()</code> 方法，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">    <span class="keyword">return</span> m.get(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他相关的 Map 操作都会使用这个 mutex 进行同步，从而实现线程安全。</p>
<p>如果并发级别不高，一般够用，但是在高并发下我们需要新的解决方案，一个更加专业的并发 HashMap 是 ConcurrentHashMap ，它专门为并发进行性能优化。</p>
<h2 id="3-有关-List-的线程安全"><a href="#3-有关-List-的线程安全" class="headerlink" title="3. 有关 List 的线程安全"></a>3. 有关 List 的线程安全</h2><p>在 Java 中 ArrayList 和 Vector 都是使用数组作为实现，前者非线程安全，后者为线程安全，我们也可以使用 Collections 包来完成 ArrayList 的线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br></pre></td></tr></table></figure>
<h2 id="4-高效读写队列-ConcurrentLinkedQueue"><a href="#4-高效读写队列-ConcurrentLinkedQueue" class="headerlink" title="4. 高效读写队列 ConcurrentLinkedQueue"></a>4. 高效读写队列 ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 应该算在高并发环境中性能最好的队列。</p>
<p>首先在 ConcurrentLinkedQueue 中，定义了节点 Node ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> E item;</span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 CAS 操作对 Node 进行一些维护：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123; <span class="comment">// 第一个参数是期望值，第二个参数是设置目标值</span></span><br><span class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它内部有两个字段，head 和 tail ，分别代表链表头和链表尾，我们可以通过 head 以及 <code>succ()</code> 方法来遍历，而 tail 表示队列的末尾。</p>
<p>一般，我们期望 tail 总是末尾，但是实际上更新不是及时的，存在拖延现象，如下所示：</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190210110501.png" alt></p>
<blockquote>
<p>tail 的更新会延后，每次跳跃两个元素。</p>
</blockquote>
<p>我们看一下加入节点的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">    Node&lt;E&gt; q = p.next;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// p is last node</span></span><br><span class="line">      <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">        <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">        <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">        <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">        <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">          casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">      <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">      <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">      <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">      <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">      p = (t != (t = tail)) ? t : head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">      p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始情况下，由于队列为空，所以 p.next 为 null ，然后将 p 的 next 节点赋值 newNode ，也就是将新的元素加入到队列中，此时 p == t 是成立的，因此不会更新结尾 tail ，因此增加一个元素后，tail 并不会更新。</p>
<p>当我们试图增加第二个元素时，由于 t 在 head 的位置，因此 p.next 指向第一个元素，现在 q != null ，q 不是最后的节点。于是代码开始寻找最后一个节点。此时， p 指向第一个元素，而它的 next 是 null ，p 更新自己的 next ，此时 p != t ，于是更新 t 所在的位置，到链表的最后。</p>
<p>那么什么时候会出现 p == q 呢？这是因为遇到了哨兵节点，就是 next 指向自己的节点。主要表示要删除的节点和空节点。出现了的话，则使用新的 tail 作为结尾，避免重新查找 tail 的开销。</p>
<p>在单线程下，这就话不容易理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = (t != (t = tail)) ? t : head;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>!= 不是原子操作，首先是 t 的值，然后执行 t = tail ，取得新的 t 的值，然后比较是否相等，单线程不会出现 t != t ，但是在并发下，右边可能修改了，如果修改了，就现在进行修改，如果没有修改，重新查找结尾。</p>
</blockquote>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190210170913.png" alt></p>
<p>哨兵是怎么产生的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentLinkedQueue&lt;String&gt; q = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;();</span><br><span class="line">q.add(<span class="string">"1"</span>);</span><br><span class="line">q.poll();</span><br></pre></td></tr></table></figure>
<p>下面是 <code>poll()</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  restartFromHead:</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">      E item = p.item;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">        <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">        <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">          updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        updateHead(h, p);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">        <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于现在队列中只有一个元素，所以 tail 没有更新，而是指向和 head 相同的位置，此时 head 本身的 item 是空的，next 是第一个元素，首先我们代码到 p = q 的位置，p 现在指向了第一个元素，第二次循环，p 的 item 被设置成了 null ，也就是弹出元素，被删除，此时 p 和 h 当然不等了，故执行了 <code>updateHead()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">    h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 p 设置为链表的表头，原来的 head 被设置成了哨兵，通过 <code>lazySetNext()</code> 实现。现在一个哨兵节点被创建了，原来的 head 和 tail 实际上就是一个元素，如果再次执行 <code>offer()</code> 将会遇到这个 tail 。</p>
<blockquote>
<p>原来头节点没用了，next指向本身，变成哨兵节点。</p>
</blockquote>
<h2 id="5-不变模式下的-CopyOnWriteArrayList"><a href="#5-不变模式下的-CopyOnWriteArrayList" class="headerlink" title="5. 不变模式下的 CopyOnWriteArrayList"></a>5. 不变模式下的 CopyOnWriteArrayList</h2><p>有些场景下，读远远大于写，我们希望读尽可能快，写慢一点点没关系。</p>
<p>我们应该允许多个线程访问，但是写应该受到阻碍。所谓 CopyOnWrite 就是在写的时候，进行一次自我复制，如果需要修改，我们并不修改<strong>原有的内容</strong>，写完之后再替换，不影响读操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和读取相比，写入就比较麻烦了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">    newElements[len] = e;</span><br><span class="line">    setArray(newElements);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里为什么需要使用 <code>final ReentrantLock lock = this.lock;</code> 这句话，一部分重要一部分不重要。</p>
<p>重要：</p>
<ul>
<li>this.lock 是类的成员变量，一般都是存到堆上，访问堆上的变量会涉及内存同步的操作(这个建议通过编译后的 bytecode 进行观察)，而将其 copy 到栈上，然后访问就不存在这个问题了。</li>
<li>在访问堆上的 this.lock 时，对于多个 CPU ，可能会存在 cache 命中的问题，这样必然会导致内存重新 load ，而 copy 到栈上，则直接是线程相关的，就不存在这个问题了。</li>
</ul>
<p>不重要：</p>
<ul>
<li>这个 final 对于编译而言是可有可无的，即便将其final修饰符去掉，效果也一样。</li>
<li>Jdk1.6 及以前是没有这句话的，对结果是没有影响的。</li>
</ul>
</blockquote>
<p>首先使用锁，生成一个新的数组，然后将元素加入，接着新数组替换老数组，不影响读，修改完成，读就察觉了，因为 array 是 volatile 类型的。</p>
<h2 id="6-数据共享通道"><a href="#6-数据共享通道" class="headerlink" title="6. 数据共享通道"></a>6. 数据共享通道</h2><p>我们说过 ConcurrentLinkedQueue 可以作为高性能的队列，但多线程的开发还有一个问题，如何在多个线程之间进行数据共享呢？</p>
<blockquote>
<p>一般来说，我们总是希望系统是松耦合的。</p>
</blockquote>
<p>如果我们进行重构或者升级，可以不修改线程 A ，而直接把线程 B 升级成线程 C ，保证系统的平滑过渡，其中升级的意见箱使用 BlockingQueue 来实现。</p>
<p>与之前的 ConcurrentLinkedQueue 和 CopyOnWriteArrayList 不同，BlockingQueue 是一个接口，而不是一个实现，主要实现有下面的内容：</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190213233354.png" alt></p>
<p>其中 ArrayBlockingQueue 是基于数组实现的，而 LinkedBlockingQueue 基于链表。正因为如此 ArrayBlockingQueue 更适合做有界队列，因为队列中可以容纳的最大元素在创建的时候指定；而 LinkedBlockingQueue 适合做无界队列，内部元素可以动态增加。</p>
<p>BlockingQueue 之所以适合作为数据共享的通道，关键在于 Blocking 上，它有阻塞的意思，当服务线程处理完队列中信息后，如何知道下一条信息何时到来？</p>
<p>它会让服务线程在队列为空的时候，进行等待，当有信息进入队列后，自动将线程唤醒。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190213235359.png" alt></p>
<p>ArrayBlockingQueue 内部有一个对象数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] items;</span><br></pre></td></tr></table></figure>
<p>向队列中压入元素使用 <code>offer()</code> 方法和 <code>put()</code> 方法，对于 offer ，如果队列满了，返回 false ，如果没有满，则正常入队列。对于 put ，是压入队列的末尾，如果队列满了，会一直等待，直到队列中有空闲的位置。</p>
<p>从队列中弹出元素可以使用 <code>poll()</code> 方法和 <code>take()</code> 方法，他们都是从头部获取一个元素，不同在于，队列如果为空 poll 方法会直接返回 null ，而 take 会等待，直到队列内有元素。</p>
<p>为了做好等待和通知两件事，在 ArrayBlockingQueue 内部定义了以下一些字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>
<p>当执行 <code>take()</code> 操作时，如果队列为空，则让当前线程等待在 notEmpty 上，新元素加入，则进行一次 notEmpty 上的通知。</p>
<p>下面是 take 的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">      notEmpty.await();</span><br><span class="line">    <span class="keyword">return</span> extract();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码会循环进行等待，当有新元素进入，线程会得到通知，下面是加入元素的代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">  items[putIndex] = x;</span><br><span class="line">  putIndex = inc(putIndex);</span><br><span class="line">  ++count;</span><br><span class="line">  notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当新元素进入队列，需要通知在 notEmpty 上的线程，让他们继续工作。</p>
<p>同理，对于 put 操作，当队列满的时候，需要让压入线程等待：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="keyword">final</span> Reentrantlock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == items.length)</span><br><span class="line">      notFull.await();</span><br><span class="line">    insert(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有元素挪走，出现了空位，自然也需要通知入队的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">extract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  E x = items[takeIndex];</span><br><span class="line">  items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">  takeIndex = inc(takeIndex);</span><br><span class="line">  --count;</span><br><span class="line">  notFull.signal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在生产者消费者中还会有 BlockingQueue 的身影。</p>
</blockquote>
<h2 id="7-跳表"><a href="#7-跳表" class="headerlink" title="7. 跳表"></a>7. 跳表</h2><p>跳表有点类似平衡树，平衡树的插入和删除往往可能导致平衡树进行一次全局的调整。而跳表的插入和删除只需要对整个数据结构的局部进行操作即可。在高并发下，我们需要一个全局锁来保证整个平衡树的线程安全；对于跳表，我们只需要部分锁即可。</p>
<p>查询而言，跳表的复杂度也是 O(log n) ，JDK 使用跳表来实现一个 Map 。</p>
<p>跳表的另外一个特点是随机算法，它的本质是维护了多个链表，而且链表是分层的：</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190214004331.png" alt></p>
<p>每上面一层链表都是下面的子集，一个元素插入哪些层是完全随机的。查找时，我们从顶层链表开始找，一旦发现查找元素大于当前链表的取值，跳到下一层继续。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190214004910.png" alt></p>
<p>到第二层，我们找到 8 ，但是 8 比 7 大，不行，继续进入下一层，这样查找，比从元素 1 开始逐个查找要快得多。</p>
<blockquote>
<p>和哈希算法不同在于：哈希不会保存元素的顺序，而跳表的元素是排序的。</p>
</blockquote>
<p>实现这一数据结构的类是 ConcurrentSkipListMap 。下面是一个跳表的简单使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map=<span class="keyword">new</span> ConcurrentskipListMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">  map. put(, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry:map.entrySet()) &#123;</span><br><span class="line">  System.out.println(entry.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 HashMap 不同，跳表的输出是有序的。</p>
<p>跳表的内部实现有几个关键的数据结构组成。首先是 Node ，一个 Node 就是一个节点，里面含有两个重要的元素 key 和 value 。每个 Node 还会指向下一个 Node ，因此还有一个元素 next 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="keyword">volatile</span> Object value;</span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 Node 的所有操作，使用的是 CAS 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123; <span class="comment">// 设置 value</span></span><br><span class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123; <span class="comment">// 设置 next</span></span><br><span class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个数据结构是 Index ，表示索引，内部包装了 Node ，同时增加了向下的引用和向右的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">  <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">  <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个跳表就是根据 Index 进行全网的组织的。</p>
<p>此外，对于每一层的表头，还需要记录当前在哪一层，为此，还需要一个称为 HeadIndex 的数据结构，表示链表头部的第一个 Index ，它集成自 Index 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>, <span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>, <span class="title">v</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">  HeadIndex(Node&lt;K, V&gt; node, Index&lt;K, V&gt; down, Index&lt;K, v&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">    <span class="keyword">super</span>(node, down, right);</span><br><span class="line">    <span class="keyword">this</span>.level = level;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于跳表的所有操作，就是组织好这些 Index 之间的连接关系。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="https://github.com/koonchen">Projects</a></li>
         
          <li><a href="https://valeriehu1995.github.io">PigChain</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、同步控制"><span class="toc-number">1.</span> <span class="toc-text">一、同步控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-重入锁"><span class="toc-number">1.1.</span> <span class="toc-text">1. 重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-中断响应"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 中断响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-锁申请等待限时"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 锁申请等待限时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-公平锁"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 公平锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Condition-条件"><span class="toc-number">1.2.</span> <span class="toc-text">2. Condition 条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-信号量"><span class="toc-number">1.3.</span> <span class="toc-text">3. 信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-读写锁"><span class="toc-number">1.4.</span> <span class="toc-text">4. 读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-倒计时器"><span class="toc-number">1.5.</span> <span class="toc-text">5. 倒计时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-循环栅栏"><span class="toc-number">1.6.</span> <span class="toc-text">6. 循环栅栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-LockSupport"><span class="toc-number">1.7.</span> <span class="toc-text">7. LockSupport</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、ThreadPool"><span class="toc-number">2.</span> <span class="toc-text">二、ThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是线程池"><span class="toc-number">2.1.</span> <span class="toc-text">1. 什么是线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JDK-对线程池的支持"><span class="toc-number">2.2.</span> <span class="toc-text">2. JDK 对线程池的支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-核心线程池的实现"><span class="toc-number">2.3.</span> <span class="toc-text">3. 核心线程池的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-拒绝策略"><span class="toc-number">2.4.</span> <span class="toc-text">4. 拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-自定义线程创建"><span class="toc-number">2.5.</span> <span class="toc-text">5. 自定义线程创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-扩展线程池"><span class="toc-number">2.6.</span> <span class="toc-text">6. 扩展线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-优化线程池线程的数量"><span class="toc-number">2.7.</span> <span class="toc-text">7. 优化线程池线程的数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-在线程池中寻找堆栈"><span class="toc-number">2.8.</span> <span class="toc-text">8. 在线程池中寻找堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Fork-Join-框架"><span class="toc-number">2.9.</span> <span class="toc-text">9. Fork/Join 框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、JDK-的并发容器"><span class="toc-number">3.</span> <span class="toc-text">三、JDK 的并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-并发集合"><span class="toc-number">3.1.</span> <span class="toc-text">1. 并发集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-线程安全的-HashMap"><span class="toc-number">3.2.</span> <span class="toc-text">2. 线程安全的 HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-有关-List-的线程安全"><span class="toc-number">3.3.</span> <span class="toc-text">3. 有关 List 的线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-高效读写队列-ConcurrentLinkedQueue"><span class="toc-number">3.4.</span> <span class="toc-text">4. 高效读写队列 ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-不变模式下的-CopyOnWriteArrayList"><span class="toc-number">3.5.</span> <span class="toc-text">5. 不变模式下的 CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-数据共享通道"><span class="toc-number">3.6.</span> <span class="toc-text">6. 数据共享通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-跳表"><span class="toc-number">3.7.</span> <span class="toc-text">7. 跳表</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&text=JDK 并发包小结"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&is_video=false&description=JDK 并发包小结"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JDK 并发包小结&body=Check out this article: http://koon.cool/technology/2019-02-14-jdk-concurrent-package/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&title=JDK 并发包小结"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://koon.cool/technology/2019-02-14-jdk-concurrent-package/&name=JDK 并发包小结&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 Koon Chen
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="https://github.com/koonchen">Projects</a></li>
         
          <li><a href="https://valeriehu1995.github.io">PigChain</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<!-- <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"> -->
<link rel="stylesheet" href="//cdn.staticfile.org/font-awesome/5.2.0/css/all.min.css">
<!-- <link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css"> -->
<link rel="stylesheet" href="//cdn.staticfile.org/justifiedGallery/3.6.5/css/justifiedGallery.min.css">

    <!-- jquery -->
<!-- <script src="/lib/jquery/jquery.min.js"></script> -->
<script src="//cdn.staticfile.org/jquery/3.3.1/jquery.min.js"></script>
<!-- <script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script> -->
<script src="//cdn.staticfile.org/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-109260587-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
