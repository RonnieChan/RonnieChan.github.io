<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="一、几点建议锁将导致整体性能下降，这里有几点建议。 1.1 减小锁持有时间程序应该减少对某个锁的占有时间，减少互斥的可能。下面的代码为例： 12345public synchronized void syncMethod() &amp;#123;  othercode1();  mutextMethod();  othercode2();&amp;#125; 假设在 syncMethod 方法中只有 mutext">
<meta name="keywords" content="java,高并发程序设计">
<meta property="og:type" content="article">
<meta property="og:title" content="锁的优化及注意事项">
<meta property="og:url" content="http://koon.cool/technology/2019-02-21-lock-optimize/index.html">
<meta property="og:site_name" content="空城">
<meta property="og:description" content="一、几点建议锁将导致整体性能下降，这里有几点建议。 1.1 减小锁持有时间程序应该减少对某个锁的占有时间，减少互斥的可能。下面的代码为例： 12345public synchronized void syncMethod() &amp;#123;  othercode1();  mutextMethod();  othercode2();&amp;#125; 假设在 syncMethod 方法中只有 mutext">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190219230459.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190221133013.png">
<meta property="og:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190219233222.png">
<meta property="og:updated_time" content="2021-11-07T18:06:23.917Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="锁的优化及注意事项">
<meta name="twitter:description" content="一、几点建议锁将导致整体性能下降，这里有几点建议。 1.1 减小锁持有时间程序应该减少对某个锁的占有时间，减少互斥的可能。下面的代码为例： 12345public synchronized void syncMethod() &amp;#123;  othercode1();  mutextMethod();  othercode2();&amp;#125; 假设在 syncMethod 方法中只有 mutext">
<meta name="twitter:image" content="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190219230459.png">
    
    
        
          
              <link rel="shortcut icon" href="//koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/fish_opt.png">
          
        
        
          
            <link rel="icon" type="image/png" href="//koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/fish_opt.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="//koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/fish_opt.png">
          
        
    
    <!-- title -->
    <title>锁的优化及注意事项</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">    
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="https://github.com/koonchen">Projects</a></li>
         
          <li><a href="https://valeriehu1995.github.io">PigChain</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/technology/2019-02-23-parallel-pattern/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/technology/2019-02-14-jdk-concurrent-package/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://koon.cool/technology/2019-02-21-lock-optimize/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://koon.cool/technology/2019-02-21-lock-optimize/&text=锁的优化及注意事项"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://koon.cool/technology/2019-02-21-lock-optimize/&is_video=false&description=锁的优化及注意事项"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=锁的优化及注意事项&body=Check out this article: http://koon.cool/technology/2019-02-21-lock-optimize/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://koon.cool/technology/2019-02-21-lock-optimize/&name=锁的优化及注意事项&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、几点建议"><span class="toc-number">1.</span> <span class="toc-text">一、几点建议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-减小锁持有时间"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 减小锁持有时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-减小锁粒度"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 减小锁粒度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-读写分离锁替换独占锁"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 读写分离锁替换独占锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-锁分离"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 锁分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-锁粗化"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 锁粗化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Java-虚拟机对锁的优化"><span class="toc-number">2.</span> <span class="toc-text">二、Java 虚拟机对锁的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-锁偏向"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 锁偏向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-轻量级锁"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 轻量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-自旋锁"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-锁消除"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 锁消除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、ThreadLocal"><span class="toc-number">3.</span> <span class="toc-text">三、ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ThreadLocal-简单实用"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 ThreadLocal 简单实用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-ThreadLocal-的实现原理"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 ThreadLocal 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-对性能有何帮助"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 对性能有何帮助</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、无锁"><span class="toc-number">4.</span> <span class="toc-text">四、无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-比较交换"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 比较交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-AtomicInteger"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 AtomicInteger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Java-中的指针：Unsafe-类"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Java 中的指针：Unsafe 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-无锁对象引用：AtomicReference"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 无锁对象引用：AtomicReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-带时间戳的对象引用：AtomicStampedReference"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 带时间戳的对象引用：AtomicStampedReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-数组也能无锁：AtomicIntegerArray"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 数组也能无锁：AtomicIntegerArray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-让普通变量也享受原子操作：AtomicIntegerFieldUpdater"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 让普通变量也享受原子操作：AtomicIntegerFieldUpdater</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-无锁-Vector-实现"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 无锁 Vector 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-细看-SynchronousQueue-的实现"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 细看 SynchronousQueue 的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、有关死锁的问题"><span class="toc-number">5.</span> <span class="toc-text">五、有关死锁的问题</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        锁的优化及注意事项
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">空城</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-02-20T16:00:00.000Z" itemprop="datePublished">2019-02-21</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/technology/">technology</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/高并发程序设计/">高并发程序设计</a>
    </div>


    </div>
  </header>
  <!-- 
 -->
  <div class="content" itemprop="articleBody">
    <h1 id="一、几点建议"><a href="#一、几点建议" class="headerlink" title="一、几点建议"></a>一、几点建议</h1><p>锁将导致整体性能下降，这里有几点建议。</p>
<h2 id="1-1-减小锁持有时间"><a href="#1-1-减小锁持有时间" class="headerlink" title="1.1 减小锁持有时间"></a>1.1 减小锁持有时间</h2><p><strong>程序应该减少对某个锁的占有时间，减少互斥的可能</strong>。下面的代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  othercode1();</span><br><span class="line">  mutextMethod();</span><br><span class="line">  othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设在 <code>syncMethod</code> 方法中只有 <code>mutextMethod</code> 方法是需要同步的，而 <code>othercode1</code> 和 <code>othercode2</code> 方法不需要同步，而假设这两个方法是重量级的，需要时间去使用 CPU ，那么需要大量等待，一个更好的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  othercode1();</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    mutextMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们仅仅对 <code>mutextMethod</code> 方法进行同步，占用时间短，而且有更高的并行性，这样类似的还有比如正则表达式的『Pattern』类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Matcher <span class="title">matcher</span><span class="params">(CharSequence input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!compiled) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!compiled) &#123;</span><br><span class="line">        compile();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Matcher m = <span class="keyword">new</span> Matcher(<span class="keyword">this</span>, input);</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>matcher</code> 方法有条件地进行锁申请，进行局部加锁。</p>
<blockquote>
<p><strong>减少锁的持有时间有助于降低锁冲突的可能，进而提高并发能力</strong>。</p>
</blockquote>
<h2 id="1-2-减小锁粒度"><a href="#1-2-减小锁粒度" class="headerlink" title="1.2 减小锁粒度"></a>1.2 减小锁粒度</h2><p>减小粒度是一种削弱多线程的一种手段，比如『ConcurrentHashMap』，之前说到过，使用『Collections』包可以实现线程安全的『HashMap』，其中使用了「mutex」对象进行互斥。</p>
<p>对于『HashMap』而言，最重要的自然是 <code>get</code> 方法和 <code>put</code> 方法，我们如果全局加锁，那么锁的粒度太大，在『ConcurrentHashMap』中，将细分若干小的『HashMap』，这些被称作<strong>段</strong>，默认下一个『ConcurrentHashMap』被分为16个段。</p>
<p>如果现在往『ConcurrentHashMap』中添加元素，不是将整个『HashMap』加锁，而是<strong>根据「hashcode」决定将该项放到哪个段中，然后对段进行加锁</strong>，如果多线程执行 <code>put</code> 方法，只要不是同一个段，那么就是真正的并行！</p>
<p>因为默认是16个段，如果够幸运，应该最多能同时接受16个线程，大大提高了吞吐量。下面是 <code>put</code> 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span> <span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  Segment&lt;K,V&gt; s;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> hash = hash(key); <span class="comment">// 获取 key 相应的 hash</span></span><br><span class="line">  <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; <span class="comment">// 获取段序号</span></span><br><span class="line">  <span class="keyword">if</span> ((s = (Segment&lt;K, V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT)+ SBASE)) == <span class="keyword">null</span>) <span class="comment">// recheck</span></span><br><span class="line">    s = ensureSegment(j); <span class="comment">// 得到段</span></span><br><span class="line">  <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少锁粒度将引发一个新的问题：<strong>当系统获取全局锁的时候，消耗的内存比较多</strong>。</p>
<p>虽然我们的 <code>put</code> 方法很好的分离了锁，但是当我们试图访问『ConcurrentHashMap 的全局信息的时候，需要同时取得所有锁才能顺利实施，比如说 <code>size</code> 方法，它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) <span class="comment">// 对所有的段加锁</span></span><br><span class="line">  segments[i].lock();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) <span class="comment">// 统计总数</span></span><br><span class="line">  sum += segments[i].count;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) <span class="comment">// 释放所有锁</span></span><br><span class="line">  segments[i].unlock();</span><br></pre></td></tr></table></figure>
<p>事实上 <code>size</code> 方法不总是这样的，它先使用无锁的方式求和，如果失败才采取这样的方式。</p>
<p><strong>只有在 <code>size</code> 这样获取全局信息不频发的情况下，减少锁粒度的方法才能提高系统吞吐量</strong>。</p>
<blockquote>
<p>或者说减少锁定对象的范围，从而减少锁冲突的可能。</p>
</blockquote>
<h2 id="1-3-读写分离锁替换独占锁"><a href="#1-3-读写分离锁替换独占锁" class="headerlink" title="1.3 读写分离锁替换独占锁"></a>1.3 读写分离锁替换独占锁</h2><p>我们知道读写锁『ReadWriteLock』可以提高系统性能，这也是减小锁粒度的一种情况，<strong>如果说减少锁粒度是分割数据结构，那么读写锁是对系统功能点的分割</strong>。</p>
<blockquote>
<p>在读多写少的场景，使用读写锁可以有效提高系统的并行能力。</p>
</blockquote>
<h2 id="1-4-锁分离"><a href="#1-4-锁分离" class="headerlink" title="1.4 锁分离"></a>1.4 锁分离</h2><p>将读写锁的思想进一步延伸，就是所分离。一个例子就是『java.util.concurrent.LinkedBlockingQueue』的实现。</p>
<blockquote>
<p>可以回忆它的近亲，『ArrayBlockingQueue』。</p>
</blockquote>
<p>同样，这里的 <code>take</code> 方法和 <code>put</code> 方法分别实现了从队列取和放入队列的功能，由于是链表，这两个操作分别作用在队列的前端和尾端。</p>
<blockquote>
<p> 使用独占锁，这两个方法就不可能真正并发，它们互相等待对方资源释放。</p>
</blockquote>
<p>因此，在 JDK 中，我们取而代之的是使用两把不同的锁，分离 <code>take</code> 方法和 <code>put</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// take 方法需要持有 takeLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// put 方法需要持有 putLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以发现和『ArrayBlockingQueue』很像。</p>
</blockquote>
<p>以上，我们定义好「takeLock」和「putLock」，它们分别在 <code>take</code> 方法和 <code>put</code> 方法中使用，因此它们互相独立，<code>take</code> 方法和 <code>take</code> 方法竞争，<code>put</code> 方法和 <code>put</code> 方法竞争，做到削弱竞争的可能性。</p>
<p>下面是 <code>take</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  E x;</span><br><span class="line">  <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">  takeLock.lockInterruptibly(); <span class="comment">// 不能有两个线程同时取数据</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">// 没有可用线程进行等待</span></span><br><span class="line">      notEmpty.await(); <span class="comment">// 等待 put 方法的通知</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = dequeue(); <span class="comment">// 取得第一个数</span></span><br><span class="line">    c = count.getAndDecrement(); <span class="comment">// 数量减一，原子操作，变量 c 是 count 减一前的数字</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">      notEmpty.signal(); <span class="comment">// 通知其他 take 操作</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    takeLock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c == capacity)</span><br><span class="line">    signalNotFull(); <span class="comment">// 通知 put 方法，已经没有空间了</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是 <code>put</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">  Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">  <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">  putLock.lockInterruptibly(); <span class="comment">// 不能两个线程同时 put</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count.get() == capacity) &#123; <span class="comment">// 队列满了</span></span><br><span class="line">      notFull.await(); <span class="comment">// 等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    enqueue(node); <span class="comment">// 插入数据</span></span><br><span class="line">    c = count.getAndIncrement(); <span class="comment">// 更新总是，c 是 count 加一前的数</span></span><br><span class="line">    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">      notFull.signal(); <span class="comment">// 空间足够，通知其他线程</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    putLock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">    signalNotEmpty(); <span class="comment">// 插入成功，通知 take 取数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过「takeLock」和「putLock」两把锁，实现取和写的分离。</p>
<h2 id="1-5-锁粗化"><a href="#1-5-锁粗化" class="headerlink" title="1.5 锁粗化"></a>1.5 锁粗化</h2><p>通常情况下，我们要求线程持有锁的时间尽可能短，完成就释放，<strong>如果对一个锁不断请求，同步，释放，那么也会消耗资源，反而不利于优化</strong>。</p>
<p><strong>虚拟机遇到一系列对锁的请求和释放，就会整合对锁一次的请求，减少同步次数</strong>，就是锁粗化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 做其他不需要同步的工作，但很快完毕</span></span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整合成以下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">    <span class="comment">// 其他工作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合理粗化是有用的，但是下面的情况就不必要了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CIRCLE; ++i) &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更合理的，应该这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CIRCLE; ++i) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>锁粗化的思想和减少持有时间正好相反，应该根据实际情况，进行权衡。</p>
</blockquote>
<h1 id="二、Java-虚拟机对锁的优化"><a href="#二、Java-虚拟机对锁的优化" class="headerlink" title="二、Java 虚拟机对锁的优化"></a>二、Java 虚拟机对锁的优化</h1><h2 id="2-1-锁偏向"><a href="#2-1-锁偏向" class="headerlink" title="2.1 锁偏向"></a>2.1 锁偏向</h2><p>如果一个线程获得锁，那么锁就进入偏向模式，<strong>再次请求这个线程，无需再做同步操作</strong>，因此在几乎没有锁竞争的场合，偏向锁很好，因为多次极有可能是同一个线程请求相同的锁。<strong>而在竞争激烈的场合，效果不佳</strong>，最可能的情况是不同线程请求相同的锁。</p>
<blockquote>
<p>可以使用参数「-XX:+UseBiasedLocking」开启偏向锁。</p>
</blockquote>
<h2 id="2-2-轻量级锁"><a href="#2-2-轻量级锁" class="headerlink" title="2.2 轻量级锁"></a>2.2 轻量级锁</h2><p>偏向锁失败，虚拟机不会立即挂起线程，而是采用轻量级锁的优化手段，简单将对象头部作为指针，指向持有锁的线程堆栈内部，以此判断线程是否持有锁。<strong>如果线程获得轻量级锁成功，则进入临界区；如果失败，则表示其他线程获得了锁，当前线程的锁清秋膨胀为重量级锁</strong>。</p>
<h2 id="2-3-自旋锁"><a href="#2-3-自旋锁" class="headerlink" title="2.3 自旋锁"></a>2.3 自旋锁</h2><p>锁膨胀以后，虚拟机还会最后努力一下，也许在几个 CPU 时钟周期后就获得锁了，因此虚拟机将当前线程进行几个<strong>空循环</strong>（这也是自旋的含义），如果获得就进入临界区；如果没有，才真正进行挂起。</p>
<h2 id="2-4-锁消除"><a href="#2-4-锁消除" class="headerlink" title="2.4 锁消除"></a>2.4 锁消除</h2><p>JVM 在 JIT 编译时，通过上下文扫描，<strong>去除不可能共享资源竞争的锁</strong>。</p>
<p>比如我们日常使用的『Vector』，这个类是线程安全的，而如果我们在方法内使用，那么该对象就是局部变量，在<strong>虚拟机栈上分配内存</strong>，此时，这些锁同步操作就会被去除。</p>
<blockquote>
<p>当在方法区外使用这个『Vector』时，就涉及了<strong>逃逸分析</strong>，不能进行锁消除了。</p>
<p>逃逸分析必须在「-server」模式下进行，使用「-XX:+DoEscapeAnalysis」参数打开逃逸分析，使用「-XX:+EliminateLocks」参数可以打开锁消除。</p>
</blockquote>
<h1 id="三、ThreadLocal"><a href="#三、ThreadLocal" class="headerlink" title="三、ThreadLocal"></a>三、ThreadLocal</h1><h2 id="3-1-ThreadLocal-简单实用"><a href="#3-1-ThreadLocal-简单实用" class="headerlink" title="3.1 ThreadLocal 简单实用"></a>3.1 ThreadLocal 简单实用</h2><p>加锁只是一种解决办法，另外一种办法则是使用『ThreadLocal』，感受人手一支笔。</p>
<p>比如下面的 demo :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>.i=i;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Date t=sdf.parse(<span class="string">"2015-03-29 19:29:"</span>+i%<span class="number">60</span>);</span><br><span class="line">      System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">      e.printstackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">  ExecutorService es=Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) &#123;</span><br><span class="line">    es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是解析字符串类型的日期，但是一般，会有一场，因为 <code>SimpleDateFormat.parse()</code> 不是线程安全的，在线程池中共享这个对象会导致错误。</p>
<p><strong>一个办法是在 <code>sdf.parse()</code> 前后加锁</strong>，而另外一个办法则是<strong>使用『ThreadLocal』为每一个线程产生一个『SimpleDateformat』对象实例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; t1 = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>.i=i;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t1.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t1.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      Date t = t1.get().parse(<span class="string">"2015-03-29 19:29:"</span> + i % <span class="number">60</span>);</span><br><span class="line">      System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程不持有『SimpleDateformat』对象，则新建，否则直接使用。当然，如果再应用上为每一个线程分配相同的对象，那么『ThreadLocal』也不能保证线程安全。</p>
<h2 id="3-2-ThreadLocal-的实现原理"><a href="#3-2-ThreadLocal-的实现原理" class="headerlink" title="3.2 ThreadLocal 的实现原理"></a>3.2 ThreadLocal 的实现原理</h2><p>『ThreadLocal』如何保证对象只有当前线程可以访问呢？问题自然是它的 <code>set</code> 和 <code>get</code> 两个方法。从 <code>set</code> 开始看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获得当前线程，然后获得线程的『ThreadLocal』，并将值设入『ThreadLocalMap』中，这可以理解成一个『HashMap』，它是定义在『Thread』内部的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>我们在设置『ThreadLocal』的数据，就是写入这个「map」中，其中「key」是当前对象，而「value」是我们需要的值，那么 <code>get</code> 就是从「map」中取出数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先 <code>get</code> 获得当前线程的『ThreadLocalMap』对象，然后通过自己作为「key」获得内部实际数据。</p>
</blockquote>
<p>这些变量维护在『Thread』内部，意味着只要线程不退出，对象引用一直存在。</p>
<p>线程退出，『Thread』类会进行清理工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">    group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">    group = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  target = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 加速资源清理</span></span><br><span class="line">  threadLocals = <span class="keyword">null</span>;</span><br><span class="line">  inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">  inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">  blocker = <span class="keyword">null</span>;</span><br><span class="line">  uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，如果使用线程池，那么线程未必会退出，如果设置对象到『ThreadLocal』但是又不清理，几次之后，对象也无法回收，也不能再用，因此，最好使用 <code>ThreadLocal.remove()</code> 将变量移除。</p>
<hr>
<p>我们也可以像释放普通变量那样释放『ThreadLocal』。我们会写下 <code>obj=null</code> 这样的代码，会更容易让垃圾回收器发现对象，从而回收。</p>
<p>同样，对于『ThreadLocal』我们也可以使用 <code>t1=null</code> ，现在这个对象的所有线程局部变量都可能被回收。</p>
<p>下面的代码执行以后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo_Gc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadLocal&lt;SimpleDateFormat&gt; t1 = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.toString() + <span class="string">" is gc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          t1.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              System.out.println(<span class="keyword">this</span>.toString() + <span class="string">" is gc"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          System.out.println(Thread.currentThread().getId() + <span class="string">":create SimpleDateFormat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date t = t1.get().parse(<span class="string">"2019-02-19 22:08:"</span> + i % <span class="number">60</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cd.countDown(); <span class="comment">// 一个线程完成，计时器减一</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">      es.submit(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">    &#125;</span><br><span class="line">    cd.wait(); <span class="comment">// 等待 CountDownLatch 完成</span></span><br><span class="line">    System.out.println(<span class="string">"mission complete!"</span>);</span><br><span class="line">    t1 = <span class="keyword">null</span>; <span class="comment">// 进行一次 GC 同时也是单单删除了 t1</span></span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(<span class="string">"first GC complete!!"</span>);</span><br><span class="line">    <span class="comment">// 在设置 ThreadLocal 的时候，会清除 ThreadLocalMap 中的无效对象</span></span><br><span class="line">    t1 = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line">    cd = <span class="keyword">new</span> CountDownLatch(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">      es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">    &#125;</span><br><span class="line">    cd.await(); <span class="comment">// 等待 CountDownLatch 完成</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(<span class="string">"second GC complete!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先10个线程创建各自的『SimpleDateFormat』，然后进行一次 GC ，发现一开始的『ThreadLocal』对象被回收，<strong>因为我们把它设置为了 「null」 </strong>；接着提交第二次任务，也创建10个『SimpleDateFormat』，然后第二次没有单独指定就进行 GC ，发现第一次全部10个『SimpleDateFormat』被回收了，</p>
<blockquote>
<p>出现这样的原因是因为『ThreadLocalMap』的实现使用了弱引用，JVM 在垃圾回收的时候，如果发现弱引用，会立即回收，当『ThreadLocal』的外部强引用被回收时，『ThreadLocalMap』的「key」会变成 null ，因此在第一次 GC 时，一个『ThreadLocal』对象被回收，第二次其对应的10个『SimpleDateFormat』自然被删除了。</p>
</blockquote>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190219230459.png" alt></p>
<h2 id="3-3-对性能有何帮助"><a href="#3-3-对性能有何帮助" class="headerlink" title="3.3 对性能有何帮助"></a>3.3 对性能有何帮助</h2><blockquote>
<p>如果共享对象对于竞争的处理容易引起性能损失，我们就应该使用『ThreadLocal』为每一个线程分配单独的对象。</p>
</blockquote>
<p>比如多线程下产生随机数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RndTaskTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GEN_COUNT = <span class="number">10000000</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">static</span> ExecutorService exe = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random(<span class="number">123</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Random&gt; tRnd = <span class="keyword">new</span> ThreadLocal&lt;Random&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Random <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Random(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RndTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RndTask</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.mode = mode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Random <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mode == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rnd;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tRnd.get();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> b = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; GEN_COUNT; i++) &#123;</span><br><span class="line">        getRandom().nextInt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"spend "</span> + (e - b) + <span class="string">"ms"</span>);</span><br><span class="line">      <span class="keyword">return</span> e - b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Future&lt;Long&gt;[] futs = <span class="keyword">new</span> Future[THREAD_COUNT];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">      futs[i] = exe.submit(<span class="keyword">new</span> RndTask(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> totaltime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">      totaltime += futs[i].get();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"多线程访问同一个 Random 实例："</span> + totaltime + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">// ThreadLocal 的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">      futs[i] = exe.submit(<span class="keyword">new</span> RndTask(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    totaltime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">      totaltime += futs[i].get();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"使用 ThreadLocal 包装 Random 实例："</span> + totaltime + <span class="string">"ms"</span>);</span><br><span class="line">    exe.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从运行结果发现，如果多线程共享同一个『Random』实例，总耗时接近13秒，在『ThreadLocal』模式下，耗时不到1秒。</p>
<h1 id="四、无锁"><a href="#四、无锁" class="headerlink" title="四、无锁"></a>四、无锁</h1><h2 id="4-1-比较交换"><a href="#4-1-比较交换" class="headerlink" title="4.1 比较交换"></a>4.1 比较交换</h2><p>CAS 包含三个参数「V E N」，V 表示要更新的变量，E 表示预期，N 表示新值，<strong>仅当 V 等于 E 时，才会将 V 改成 N </strong>，如果 V 和 E 不同，表示有其他线程进行了修改，则什么都不做。最后，CAS 会返回当前 V 的真实值。</p>
<blockquote>
<p>CAS 是乐观态度的操作，它总是认为可以完成操作，当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，<strong>失败的线程不会挂起，仅是被告知失败，并允许重新尝试</strong>。</p>
</blockquote>
<p>从 JDK5 以后，虚拟机可以使用这个指令来实现并发操作和并发数据结构。</p>
<h2 id="4-2-AtomicInteger"><a href="#4-2-AtomicInteger" class="headerlink" title="4.2 AtomicInteger"></a>4.2 AtomicInteger</h2><p>JDK 并发包里面实现了一些直接使用 CAS 操作的线程安全的类型。其中，最常用的就是『AtomicInteger』，与『Integer』不同，它是可变的，而且是线程安全的，下面是『AtomicInteger』的一些主要方法，其他原子类也是类似的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>; <span class="comment">// 取得当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>; <span class="comment">// 设置当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>; <span class="comment">// 设置新值，并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> u)</span></span>; <span class="comment">// 如果当前值是 expect 则设置成 u</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>; <span class="comment">// 当前值加1，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span></span>; <span class="comment">// 当前值减1，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span></span>; <span class="comment">// 当前值加 delta ，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>; <span class="comment">// 当前值加1，返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span></span>; <span class="comment">// 当前值减1，返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span></span>; <span class="comment">// 当前值加 delta ，返回新值</span></span><br></pre></td></tr></table></figure>
<p>就内部实现而言，『AtomicInteger』中保存一个核心字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>
<p>它表示『AtomicInteger』的当前实际取值，此外还有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br></pre></td></tr></table></figure>
<p>它保存着「value」字段在『AtomicInteger』对象中的偏移量，这个偏移量是实现『AtomicInteger』的关键。</p>
<p>下面是一个关于『AtomicInteger』的 demo ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; ++k)</span><br><span class="line">        i.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">      ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) ts[k].start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) ts[k].join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，最后输出的结果是100000，所以执行是正确的，如果线程不安全，结果应该小于100000。</p>
<p>下面是 <code>incrementAndGet()</code> 的内部实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAnGet</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="title">for</span> <span class="params">(;;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current = get();</span><br><span class="line">    <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSet(current, next));</span><br><span class="line">      <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>get</code> 方法就非常简单，只是返回内部的「value」。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里，我们应该好奇为什么设置一个值这么简单的操作都需要一个死循环，<strong>CAS操作未必成功，对于不成功，我们不断重复尝试</strong>。</p>
</blockquote>
<p>和『AtomicInteger』类似的还有『AtomicLong』来代替『Long』类型，『AtomicBoolean』代替『Boolean』类型，『AtomicRegerence』表示对象引用。</p>
<h2 id="4-3-Java-中的指针：Unsafe-类"><a href="#4-3-Java-中的指针：Unsafe-类" class="headerlink" title="4.3 Java 中的指针：Unsafe 类"></a>4.3 Java 中的指针：Unsafe 类</h2><p>我们特别注意到 <code>compareAndSet</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里涉及一个特殊的变量「unsafe」，它是『sun.misc.Unsafe』类型，从名字看，什么是不安全？指针是不安全的，这也是在 Java 中把指针去除的原因。</p>
</blockquote>
<p>这里的『Unsafe』就是封装了一些类似指针的操作，<code>compareAndSwapInt()</code> 方法是一个 native 方法，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数「o」是给定的对象，「offset」是对象内的偏移量，其实就是一个字段到对象头部的偏移量，通过这个偏移量可以快速定位字段，「expected」表示期望，「x」表示要设置的值。如果指定的字段的值等于「expected」，那么就会把它设置为「x」。</p>
<p><code>compareAndSwapInt</code> 方法的内部，使用 CAS 原子指令，此外，『Unsafe』类还提供了一些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得给定对象偏移量上的 int 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 设置给定对象偏移量上的 int 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 获得字段在对象中的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"><span class="comment">// 设置给定对象的 int 值，使用 volatile 语义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 获得给定对象的 int 值，使用 volatile 语义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 和 putIntVolatile 一样，但是要求被操作字段是 volatile 类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以回忆『ConcurrentLinkedQueue』中对「node」的一些操作就是使用『Unsafe』类来实现的。</p>
</blockquote>
<p>虽然 Java 抛弃了指针，但是在关键时刻，类似指针的技术是必不可少的。对于『Unsafe』实现就是最好的例子，但是 JDK 的开发人员不希望大家使用这个类，获取『Unsafe』实例的方法是调用其工厂方法 <code>getUnsafe</code> ，它的实现是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class cc = Reflection.getClasserClass();</span><br><span class="line">  <span class="keyword">if</span> (cc.getClassLoader() != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">  <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它会检查 <code>getUnsafe</code> 函数的类，如果这个类的『ClassLoader』不为「null」，就抛出异常，这导致我们无法直接使用『Unsafe』类。</p>
</blockquote>
<h2 id="4-4-无锁对象引用：AtomicReference"><a href="#4-4-无锁对象引用：AtomicReference" class="headerlink" title="4.4 无锁对象引用：AtomicReference"></a>4.4 无锁对象引用：AtomicReference</h2><p>在介绍『AtomicReference』前，先提出一个关于原子操作的逻辑上的不足。</p>
<p>当我们在获得对象当前值以后，<strong>准备修改为新值前，对象被其他线程连续修改了两次</strong>，而经过修改后，对象的值又恢复为旧值，这样，我们无法判断对象是否被修改过。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190221133013.png" alt></p>
<blockquote>
<p>现实中，我们要修改的值，通常不仅仅取决于当前值，还和对象的过程变化有关，这时，『AtomicRegerence』就无能为力了。</p>
</blockquote>
<p>有个蛋糕店，为了挽留客户，对余额低于20元的客户一次赠送20元，但只能被赠送一次，首先定义账户余额：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> AtomicReference&lt;Integer&gt; money = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置账户低于20，显然需要一个需要被充值的账户</span></span><br><span class="line">    money.set(<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟多个线程同时更新后台数据库，为用户充值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              Integer m = money.get();</span><br><span class="line">              <span class="keyword">if</span> (m &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (money.compareAndSet(m, m + <span class="number">20</span>)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"余额低于20元，充值成功，余额为"</span> + money.get() + <span class="string">"元"</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// System.out.println("余额大于20元，无需充值");</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户消费线程，模拟消费行为</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Integer m = money.get();</span><br><span class="line">            <span class="keyword">if</span> (m &gt; <span class="number">10</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">"大于10元"</span>);</span><br><span class="line">              <span class="keyword">if</span> (money.compareAndSet(m, m - <span class="number">10</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费10元，剩余"</span> + money.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">"金额不足"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，这个账户被反复多次充值，修改后的值等于原值，这种情况就比较尴尬。运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">余额低于20元，充值成功，余额为39元</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余29</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余19</span><br><span class="line">余额低于20元，充值成功，余额为39元</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余29</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余19</span><br><span class="line">余额低于20元，充值成功，余额为39元</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余29</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="4-5-带时间戳的对象引用：AtomicStampedReference"><a href="#4-5-带时间戳的对象引用：AtomicStampedReference" class="headerlink" title="4.5 带时间戳的对象引用：AtomicStampedReference"></a>4.5 带时间戳的对象引用：AtomicStampedReference</h2><p>之所以『AtomicRegerence』无法解决上述问题的根本原因，对象值本身和状态被画上了等号，『AtomicStampedReference』不仅维护了对象值，还维护了一个时间戳，当值被修改了，时间戳也要进行更新。</p>
<p>它新增了几个关于时间戳的 Api ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较设置参数依次：期望 新值 期望时间戳 新时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expectedReference, V newReference, <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前对象引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取当前时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 设置当前对象引用和时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>有了这个法宝，我们不用担心对象被写坏了，修正贵宾发的 demo ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; money = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">19</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟多线程更新后台，为用户充值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> timeStamp = money.getStamp();</span><br><span class="line">      <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              Integer m = money.getReference();</span><br><span class="line">              <span class="keyword">if</span> (m &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (money.compareAndSet(m, m + <span class="number">20</span>, timeStamp, timeStamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"余额小于20元，充值成功，余额"</span> + money.getReference() + <span class="string">"元"</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// System.out.println("余额大于20元，无需充值");</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用户消费线程，模拟消费行为</span></span><br><span class="line">      <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> timeStamp = money.getStamp();</span><br><span class="line">              Integer m = money.getReference();</span><br><span class="line">              <span class="keyword">if</span> (m &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"大于10元"</span>);</span><br><span class="line">                <span class="keyword">if</span> (money.compareAndSet(m, m - <span class="number">10</span>, timeStamp, timeStamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"消费10元，剩余"</span> + money.getReference());</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"金额不足"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为修改时间戳，所以系统不可能发生二次赐予，运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">余额小于20元，充值成功，余额39元</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余29</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余19</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余9</span><br><span class="line">金额不足</span><br><span class="line">金额不足</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="4-6-数组也能无锁：AtomicIntegerArray"><a href="#4-6-数组也能无锁：AtomicIntegerArray" class="headerlink" title="4.6 数组也能无锁：AtomicIntegerArray"></a>4.6 数组也能无锁：AtomicIntegerArray</h2><p>除了对于基本类型，JDK 还提供了数组等复合结构，当前可用的原子数组有：『AtomicIntegerArray』、『AtomicLongArray』、『AtomicReferenceArray』。这里以『AtomicIntegerArray』为例，展示原子数组的使用方式。</p>
<p>它的本质是对 <code>int[]</code> 的封装，使用『Unsafe』类通过 CAS 的方式控制 <code>int[]</code> 在多线程下的安全性，其核心 Api 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得数组第i个下标元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 获得数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 将数组第i个下标设置成newValue，并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"><span class="comment">// 进行CAS操作，如果第i个下标是expect，则设置成update，设置成功返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;</span><br><span class="line"><span class="comment">// 将第i个下标的元素加1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 将第i个下标的元素减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 将第i个下标的元素增加delta</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span></span>;</span><br></pre></td></tr></table></figure>
<p>跑一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> AtomicIntegerArray arr = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; ++k) &#123;</span><br><span class="line">        arr.getAndIncrement(k % arr.length());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">      ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">      ts[k].start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">      ts[k].join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面声明一个包含10个元素的数组，每个元素各加1000次，每个线程结果都是10000，如果线程不安全，那么即通过应该会小于10000，结果如下，可以看出，『AtomicIntegerArray』保证了数组的线程安全性。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br></pre></td></tr></table></figure>
<h2 id="4-7-让普通变量也享受原子操作：AtomicIntegerFieldUpdater"><a href="#4-7-让普通变量也享受原子操作：AtomicIntegerFieldUpdater" class="headerlink" title="4.7 让普通变量也享受原子操作：AtomicIntegerFieldUpdater"></a>4.7 让普通变量也享受原子操作：AtomicIntegerFieldUpdater</h2><blockquote>
<p>如果我们随意在开发中将一个变量变成线程安全的，那么需要在每一处使用它的地方都进行修改，并且这还不符合开闭原则，系统功能的增加应该是开放的，而修改应该是相对保守的，一个一个修改也令人厌烦。</p>
</blockquote>
<p>『AtomicIntgerFieldUpdater』类可以在不改动原有代码基础上，让普通变量享受 CAS 带来的线程安全性，这个「Updater」有三种，分别是『AtomicIntegerFieldUpdater』、『AtomicLongFieldUpdater』、『AtomicReferenceFieldUpdater』它们可以对『int』、『long』以及普通对象进行 CAS 修改。</p>
<p>假设有一个选举，每个选民有一票，投了记为1，没投记为0，最终选票显然就是所有数据的求和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">"score"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查Updater是否工作正确</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger allScore = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Candidate stu = <span class="keyword">new</span> Candidate(); <span class="comment">// 假设只有一个候选人</span></span><br><span class="line">    Thread[] t = <span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">      t[i] = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.4</span>) &#123;</span><br><span class="line">            scoreUpdater.incrementAndGet(stu);</span><br><span class="line">            allScore.incrementAndGet();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      t[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) t[i].join();</span><br><span class="line">    System.out.println(<span class="string">"score="</span> + stu.score);</span><br><span class="line">    System.out.println(<span class="string">"allScore="</span> + allScore);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，候选人的得票数被记录在「Candidate.score」中，它不是线程安全的，而「allScore」是线程安全的，它是用来检验结果是否正确的。</p>
<blockquote>
<ol>
<li>「Updater」只能修改可见范围内的变量，因为使用了反射，如果上面的「score」是 private 的，那么是不行的。</li>
<li>为了保证正确读取，它必须是 volatile 类型。</li>
<li>由于 CAS 操作会对对象实例中的偏移量直接赋值，因此，不支持 static 字段。<code>Unsafe.objectFieldOffset()</code> 不支持静态变量。</li>
</ol>
</blockquote>
<h2 id="4-8-无锁-Vector-实现"><a href="#4-8-无锁-Vector-实现" class="headerlink" title="4.8 无锁 Vector 实现"></a>4.8 无锁 Vector 实现</h2><p>使用『AtomicReferenceArray』实现。</p>
<h2 id="4-9-细看-SynchronousQueue-的实现"><a href="#4-9-细看-SynchronousQueue-的实现" class="headerlink" title="4.9 细看 SynchronousQueue 的实现"></a>4.9 细看 SynchronousQueue 的实现</h2><p>曾经我们看过一个非常特殊的等待队列『SynchronousQueue』，任何一个对它的写需要等待读，因此与其说它是一个队列，不如说是一个通道。它将 <code>put</code> 和 <code>take</code> 两个功能截然不同的操作抽象为一个共通的方法 <code>Transferer.tansfer()</code> ，完整签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">transfer</span><span class="params">(Object e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当参数 e 为非空，表示当前操作传递给一个消费者，如果为空，则表示当前操作需要请求一个数据。timed 参数决定是否存在 timeout 时间。nanos 表示了 timeout 的时长。如果返回值非空，则表示数据已经接受或正常提供，如果为空，则表示失败。</p>
<p>它的内部维护了一个线程等待队列，等待队列会保存等待线程以及相关数据的信息，比如生产者将数据放入『SynchronousQueue』时，如果没有消费者接收，那么数据本身和线程对象都会打包在队列中等待。</p>
<p><code>Transferer.transfer()</code> 函数的实现是『SynchronousQueue』的核心，它分三个步骤：</p>
<ol>
<li>如果等待队列为空，或者队列中节点的类型和本次操作是一致的，那么将当前操作压入队列等待；</li>
<li>如果等待队列中的元素和本次操作是互补的，则插入一个「完成」状态，并且让他匹配到一个等待节点上。接着弹出这两个节点，使得对应的两个线程继续执行；</li>
<li>如果线程发现等待队列的节点是「完成」节点，则帮助节点完成任务。</li>
</ol>
<h1 id="五、有关死锁的问题"><a href="#五、有关死锁的问题" class="headerlink" title="五、有关死锁的问题"></a>五、有关死锁的问题</h1><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190219233222.png" alt></p>
<p>我们可以用代码来模拟哲学家就餐问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Object tool;</span><br><span class="line">  <span class="keyword">static</span> Object fork1 = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">static</span> Object fork2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DeadLock</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tool = obj;</span><br><span class="line">    <span class="keyword">if</span> (tool == fork1)</span><br><span class="line">      <span class="keyword">this</span>.setName(<span class="string">"哲学家A"</span>);</span><br><span class="line">    <span class="keyword">if</span> (tool == fork2)</span><br><span class="line">      <span class="keyword">this</span>.setName(<span class="string">"哲学家B"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tool == fork1) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (fork1) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (fork2) &#123;</span><br><span class="line">          System.out.println(<span class="string">"哲学家 A 开始吃饭了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tool == fork2) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (fork2) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (fork1) &#123;</span><br><span class="line">          System.out.println(<span class="string">"哲学家 B 开始吃饭了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    DeadLock A = <span class="keyword">new</span> DeadLock(fork1);</span><br><span class="line">    DeadLock B = <span class="keyword">new</span> DeadLock(fork2);</span><br><span class="line">    A.start();</span><br><span class="line">    B.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哲学家 A 先用叉子1，哲学家 B 先占用叉子2，接着他们相互等待，都没有办法同时获得两个叉子。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="https://github.com/koonchen">Projects</a></li>
         
          <li><a href="https://valeriehu1995.github.io">PigChain</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、几点建议"><span class="toc-number">1.</span> <span class="toc-text">一、几点建议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-减小锁持有时间"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 减小锁持有时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-减小锁粒度"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 减小锁粒度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-读写分离锁替换独占锁"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 读写分离锁替换独占锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-锁分离"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 锁分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-锁粗化"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 锁粗化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Java-虚拟机对锁的优化"><span class="toc-number">2.</span> <span class="toc-text">二、Java 虚拟机对锁的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-锁偏向"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 锁偏向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-轻量级锁"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 轻量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-自旋锁"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-锁消除"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 锁消除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、ThreadLocal"><span class="toc-number">3.</span> <span class="toc-text">三、ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ThreadLocal-简单实用"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 ThreadLocal 简单实用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-ThreadLocal-的实现原理"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 ThreadLocal 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-对性能有何帮助"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 对性能有何帮助</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、无锁"><span class="toc-number">4.</span> <span class="toc-text">四、无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-比较交换"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 比较交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-AtomicInteger"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 AtomicInteger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Java-中的指针：Unsafe-类"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Java 中的指针：Unsafe 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-无锁对象引用：AtomicReference"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 无锁对象引用：AtomicReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-带时间戳的对象引用：AtomicStampedReference"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 带时间戳的对象引用：AtomicStampedReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-数组也能无锁：AtomicIntegerArray"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 数组也能无锁：AtomicIntegerArray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-让普通变量也享受原子操作：AtomicIntegerFieldUpdater"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 让普通变量也享受原子操作：AtomicIntegerFieldUpdater</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-无锁-Vector-实现"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 无锁 Vector 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-细看-SynchronousQueue-的实现"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 细看 SynchronousQueue 的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、有关死锁的问题"><span class="toc-number">5.</span> <span class="toc-text">五、有关死锁的问题</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://koon.cool/technology/2019-02-21-lock-optimize/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://koon.cool/technology/2019-02-21-lock-optimize/&text=锁的优化及注意事项"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://koon.cool/technology/2019-02-21-lock-optimize/&is_video=false&description=锁的优化及注意事项"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=锁的优化及注意事项&body=Check out this article: http://koon.cool/technology/2019-02-21-lock-optimize/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://koon.cool/technology/2019-02-21-lock-optimize/&title=锁的优化及注意事项"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://koon.cool/technology/2019-02-21-lock-optimize/&name=锁的优化及注意事项&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 Koon Chen
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="https://github.com/koonchen">Projects</a></li>
         
          <li><a href="https://valeriehu1995.github.io">PigChain</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<!-- <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"> -->
<link rel="stylesheet" href="//cdn.staticfile.org/font-awesome/5.2.0/css/all.min.css">
<!-- <link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css"> -->
<link rel="stylesheet" href="//cdn.staticfile.org/justifiedGallery/3.6.5/css/justifiedGallery.min.css">

    <!-- jquery -->
<!-- <script src="/lib/jquery/jquery.min.js"></script> -->
<script src="//cdn.staticfile.org/jquery/3.3.1/jquery.min.js"></script>
<!-- <script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script> -->
<script src="//cdn.staticfile.org/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-109260587-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
