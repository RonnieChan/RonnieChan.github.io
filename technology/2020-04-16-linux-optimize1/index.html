<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
        
          
              <link rel="shortcut icon" href="//koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/fish_opt.png">
          
        
        
          
            <link rel="icon" type="image/png" href="//koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/fish_opt.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="//koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/fish_opt.png">
          
        
    
    <!-- title -->
    <title>Linux CPU 性能优化</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">    
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="https://github.com/koonchen">Projects</a></li>
         
          <li><a href="https://valeriehu1995.github.io">PigChain</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/technology/2020-05-01-linux-optimize2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/technology/2020-04-15-elasticsearch-learn2/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://chenzeping.com/technology/2020-04-16-linux-optimize1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&text=Linux CPU 性能优化"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&is_video=false&description=Linux CPU 性能优化"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Linux CPU 性能优化&body=Check out this article: https://chenzeping.com/technology/2020-04-16-linux-optimize1/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&name=Linux CPU 性能优化&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是平均负载"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是平均负载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-平均负载高的不同情况"><span class="toc-number">2.</span> <span class="toc-text">2. 平均负载高的不同情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-CPU-密集型进程"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. CPU 密集型进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-IO-密集型进程"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 IO 密集型进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-大量进程的场景"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 大量进程的场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-CPU-上下文切换"><span class="toc-number">3.</span> <span class="toc-text">3. CPU 上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-CPU-上下文切换的三个种类"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 CPU 上下文切换的三个种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-CPU-上下文切换实验"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 CPU 上下文切换实验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-应用-CPU-利用率-100-怎么办？"><span class="toc-number">4.</span> <span class="toc-text">4. 应用 CPU 利用率 100% 怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-什么是-CPU-使用率？"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 什么是 CPU 使用率？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-CPU-使用率过高怎么办？"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 CPU 使用率过高怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-案例分析"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 案例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-找到-CPU-利用率高的应用"><span class="toc-number">5.</span> <span class="toc-text">5. 找到 CPU 利用率高的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-大量不可用中断进程与僵尸进程"><span class="toc-number">6.</span> <span class="toc-text">6. 大量不可用中断进程与僵尸进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-案例表现"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 案例表现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-案例分析"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 案例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-理解-Linux-中断"><span class="toc-number">7.</span> <span class="toc-text">7. 理解 Linux 中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-软中断-CPU-使用率上升处理"><span class="toc-number">8.</span> <span class="toc-text">8. 软中断 CPU 使用率上升处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-分析-CPU-瓶颈"><span class="toc-number">9.</span> <span class="toc-text">9. 分析 CPU 瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-CPU-性能指标"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 CPU 性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-案例汇总"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 案例汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-从性能指标出发"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 从性能指标出发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-从工具出发"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 从工具出发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-工具的联动"><span class="toc-number">9.5.</span> <span class="toc-text">9.5 工具的联动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-CPU-性能优化"><span class="toc-number">10.</span> <span class="toc-text">10. CPU 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-性能优化方法论"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 性能优化方法论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-性能优化评估"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 性能优化评估</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-多个性能问题"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 多个性能问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-多种优化方式"><span class="toc-number">10.4.</span> <span class="toc-text">10.4 多种优化方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-CPU-优化"><span class="toc-number">10.5.</span> <span class="toc-text">10.5 CPU 优化</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Linux CPU 性能优化
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">空城</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-04-15T16:00:00.000Z" itemprop="datePublished">2020-04-16</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/technology/">technology</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/CPU/">CPU</a>, <a class="tag-link" href="/tags/linux/">linux</a>
    </div>


    </div>
  </header>
  <!-- 
 -->
  <div class="content" itemprop="articleBody">
    <h2 id="1-什么是平均负载"><a href="#1-什么是平均负载" class="headerlink" title="1. 什么是平均负载"></a>1. 什么是平均负载</h2><p><code>uptime</code> 指令显示内容如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">02</span>:<span class="number">00</span> up <span class="number">17</span> days, <span class="number">10</span>:<span class="number">57</span>,  <span class="number">1</span> user,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span></span><br></pre></td></tr></table></figure>
<p>前面：当前时间、系统运行时间、正在运行用户数。后面分别 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。</p>
<p>平均负载是什么？是 CPU 的使用率吗？明显不对，<strong>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系</strong>。</p>
<blockquote>
<p>可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</p>
<p>不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</p>
<p><strong>平均负载</strong>不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。只有当 CPU 密集或大量等待 CPU 的时候导致平均负载升高时，平均负载和 CPU 使用率的情况可以对应，在 IO 密集型中平均负载上升而 CPU 使用率不一定高。</p>
</blockquote>
<p>既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。</p>
<p>如何知道 CPU 数呢？通过 <code>grep &#39;model name&#39; /proc/cpuinfo | wc -l</code> 有几行就是几个 CPU 。</p>
<h2 id="2-平均负载高的不同情况"><a href="#2-平均负载高的不同情况" class="headerlink" title="2. 平均负载高的不同情况"></a>2. 平均负载高的不同情况</h2><h3 id="2-1-CPU-密集型进程"><a href="#2-1-CPU-密集型进程" class="headerlink" title="2.1. CPU 密集型进程"></a>2.1. CPU 密集型进程</h3><ol>
<li>先用 <code>stress --cpu 1 --timeout 600</code> 模拟一个 CPU 使用率 100% 的场景。</li>
<li>在第二个终端中用 <code>watch -d uptime</code> 查看平均负载的变化情况，其中 <code>-d</code> 表示高亮变化部分。</li>
<li>在第三个终端中用 <code>mpstat -P ALL 5</code> 查看 CPU 使用率的变化情况，其中 <code>-P ALL</code> 表示监控所有 CPU，可以发现一个 CPU 的负载会达到 100%。<ul>
<li>1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。</li>
</ul>
</li>
<li>通过 <code>pidstat -u 5 1</code> 可以查看具体进程情况，其中 <code>-u 5 1</code> 表示每 5 秒输出一次。<ul>
<li>从这里可以明显看到，stress 进程的 CPU 使用率为 100%。</li>
</ul>
</li>
</ol>
<h3 id="2-2-IO-密集型进程"><a href="#2-2-IO-密集型进程" class="headerlink" title="2.2 IO 密集型进程"></a>2.2 IO 密集型进程</h3><ol>
<li>使用 <code>stress -i 1 --timeout 600</code> 模拟 IO 压力。</li>
<li>同理第二个终端用 <code>watch -d uptime</code> 查看平均负载。</li>
<li>依然用 <code>mpstat -P ALL 5 1</code> 可以发现 CPU 的使用率情况。<ul>
<li>从这里可以看到，1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。</li>
</ul>
</li>
<li>最后也是通过 <code>pidstat -u 5 1</code> 找到相应的 pid。</li>
</ol>
<h3 id="2-3-大量进程的场景"><a href="#2-3-大量进程的场景" class="headerlink" title="2.3 大量进程的场景"></a>2.3 大量进程的场景</h3><ol>
<li>使用 <code>stress -c 8 --timeout 600</code> 模拟 8 个进程，阿里云上只有一个 CPU，显然会出现负载过高。</li>
<li>同理用 <code>watch -d uptime</code> 查看平均负载。<ul>
<li>由于系统只有 1 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 8 或 9；</li>
</ul>
</li>
<li>通过 <code>pidstat -u 5 1</code> 发现有 8 个 stress 进程占用了 CPU。<ul>
<li>可以看出，8 个进程在争抢 1 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</li>
</ul>
</li>
</ol>
<h2 id="3-CPU-上下文切换"><a href="#3-CPU-上下文切换" class="headerlink" title="3. CPU 上下文切换"></a>3. CPU 上下文切换</h2><h3 id="3-1-CPU-上下文切换的三个种类"><a href="#3-1-CPU-上下文切换的三个种类" class="headerlink" title="3.1 CPU 上下文切换的三个种类"></a>3.1 CPU 上下文切换的三个种类</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200611001221.png" alt></p>
<p>如上为 CPU 上下文的抽象图，根据任务的执行形式的不同，CPU 的下上文切换有：进程上下文切换、线程上下文切换、中断上下文切换这三类。</p>
<p>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用（特权模式切换）过程中一直是同一个进程在运行，属于同进程内的 CPU 上下文切换。</p>
<p>进程的切换只能发生在内核态，进程的上下文切换需要比系统调用多做一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p>
<p>频繁的进程上下文切换会出现性能隐患，可能出现切换的场景：</p>
<ol>
<li>时间片耗尽，当前进程必须挂起；</li>
<li>资源不足的，在获取到足够资源之前进程挂起；</li>
<li>进程 sleep 挂起进程；</li>
<li>高优先级进程导致当前进度挂起；</li>
<li>硬件中断，导致当前进程挂起；</li>
</ol>
<p>进程有上下文切换，线程也有，<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。线程的上下文切换有两种情况：</p>
<ol>
<li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样；</li>
<li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，只需要切换线程间不共享的数据。</li>
</ol>
<p>除了前面两种上下文切换，还有一个场景也会切换 CPU 上下文，那就是中断。</p>
<p>快速响应硬件的事件，中断处理会打断进程的正常调度和执行。同一 CPU 内，硬件中断优先级高于进程。切换过程类似于系统调用的时候，不涉及到用户运行态资源。大量的中断上下文切换同样可能引发性能问题。</p>
<h3 id="3-2-CPU-上下文切换实验"><a href="#3-2-CPU-上下文切换实验" class="headerlink" title="3.2 CPU 上下文切换实验"></a>3.2 CPU 上下文切换实验</h3><p>vmstat 是一个常用的系统性能分析工具，用来分析系统的内存使用情况，也可以分析 CPU 上下文切换和中断的次数。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># vmstat 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> <span class="number">6</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128740</span> <span class="number">140324</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">12</span>     <span class="number">6</span>   <span class="number">15</span>   <span class="number">16</span>  <span class="number">1</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128740</span> <span class="number">140332</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">2</span>  <span class="number">309</span>  <span class="number">879</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128740</span> <span class="number">140332</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>  <span class="number">294</span>  <span class="number">859</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128740</span> <span class="number">140332</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>  <span class="number">295</span>  <span class="number">861</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128244</span> <span class="number">140332</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>  <span class="number">323</span>  <span class="number">912</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128196</span> <span class="number">140336</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">114</span>  <span class="number">297</span>  <span class="number">866</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cs（context switch）是每秒上下文切换的次数。</li>
<li>in（interrupt）则是每秒中断的次数。</li>
<li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</li>
<li>b（Blocked）则是处于不可中断睡眠状态的进程数。</li>
</ul>
<p><code>vmstat</code> 只能看到总体的情况，每个进程的详细情况需要使用 <code>pidstat -w</code> 。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># pidstat -w 5 1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span>-<span class="number">514.26</span>.<span class="number">2</span>.el7.x86_64 (koonchen) 	<span class="number">06</span>/<span class="number">18</span>/<span class="number">2020</span> 	_x86_64_	(<span class="number">1</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">20</span> AM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>         <span class="number">3</span>      <span class="number">0.40</span>      <span class="number">0.00</span>  ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>         <span class="number">6</span>      <span class="number">0.20</span>      <span class="number">0.00</span>  kworker/u2:<span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>         <span class="number">9</span>     <span class="number">12.45</span>      <span class="number">0.00</span>  rcu_sched</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>        <span class="number">10</span>      <span class="number">0.20</span>      <span class="number">0.00</span>  watchdog/<span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>       <span class="number">745</span>      <span class="number">0.40</span>      <span class="number">0.00</span>  aliyun-service</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>       <span class="number">956</span>     <span class="number">10.04</span>      <span class="number">0.00</span>  AliYunDun</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>      <span class="number">1672</span>      <span class="number">8.43</span>      <span class="number">0.00</span>  kworker/<span class="number">0</span>:<span class="number">2</span></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>      <span class="number">1673</span>      <span class="number">0.20</span>      <span class="number">0.00</span>  sshd</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>      <span class="number">1700</span>      <span class="number">0.20</span>      <span class="number">0.00</span>  pidstat</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>      <span class="number">9668</span>     <span class="number">10.04</span>      <span class="number">0.00</span>  AliSecGuard</span><br></pre></td></tr></table></figure>
<ul>
<li>cswch 每秒自愿上下文切换（voluntary context switches）的次数；<ul>
<li>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。</li>
<li>比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。</li>
</ul>
</li>
<li>nvcswch 每秒非自愿上下文切换（non voluntary context switches）的次数。<ul>
<li>进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。</li>
<li>比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。</li>
</ul>
</li>
</ul>
<p>sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。</p>
<ol>
<li>第一个终端使用 <code>sysbench --threads=10 --max-time=300 threads run</code> 表示以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题。</li>
<li>第二个终端使用 <code>vmstat 1</code> 表示每隔 1 秒输出 1 组数据。<ul>
<li>cs（上下文切换的次数）的数值达到了 160 万左右。</li>
<li>r（就绪队列的长度）的数值达到了 8 左右，超过了 CPU 的个数 1 。</li>
<li>us 表示用户态，sy 表示内核态，可以看到 us 在 10% 左右，sy 在 90% 左右。</li>
<li>in（每秒中断的次数）的数值在 1300 左右，说明中断处理是一个潜在的问题。</li>
<li>综上，系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。</li>
</ul>
</li>
<li>第三个终端使用 <code>pidstat -w -u 1</code> ，<code>-w</code> 参数表示输出进程切换指标，而 <code>-u</code> 参数则表示输出 CPU 使用指标。<ul>
<li>可以发现占用 CPU 最高的是 <code>sysbench</code> 。</li>
<li>但是在这里自愿与非自愿的上下文切换加起来也远远达不到 <code>vmstat</code> 中 160 万的数值，这是因为 Linux 的调度基本单位是线程， <code>sysbench</code> 模拟的也是线程调度，所以在 <code>pidstat</code> 中加上 <code>-t</code> 参数才会显示线程指标。</li>
</ul>
</li>
<li>剩下的是中断问题，为什么中断达到了 1300 左右，在 <code>/proc/interrupts</code> 文件汇总可以读取，它提供了中断的使用情况，通过 <code>watch -d cat /proc/interrupts</code> 查看。<ul>
<li>在单核下没有 CPU 切换的展示，事实上这里应该转变最快的是 RES（重调度中断），它表示唤醒空闲状态的 CPU 来调度新的任务运行。</li>
</ul>
</li>
</ol>
<blockquote>
<p><code>stress</code> 基于多进程的，会 fork 多个进程，导致进程上下文切换，导致 us 开销很高；</p>
<p><code>sysbench</code> 基于多线程的，会创建多个线程，单一进程基于内核线程切换，导致 sy 的内核开销很高；</p>
<p>首先通过 <code>uptime</code> 查看系统负载，然后使用 <code>mpstat</code> 结合 <code>pidstat</code> 来初步判断到底是 CPU 计算量大还是进程争抢过大或者是 io 过多，接着使用 <code>vmstat</code> 分析切换次数，以及切换类型，来进一步判断到底是 io 过多导致问题还是进程争抢激烈导致问题。</p>
</blockquote>
<h2 id="4-应用-CPU-利用率-100-怎么办？"><a href="#4-应用-CPU-利用率-100-怎么办？" class="headerlink" title="4. 应用 CPU 利用率 100% 怎么办？"></a>4. 应用 CPU 利用率 100% 怎么办？</h2><h3 id="4-1-什么是-CPU-使用率？"><a href="#4-1-什么是-CPU-使用率？" class="headerlink" title="4.1 什么是 CPU 使用率？"></a>4.1 什么是 CPU 使用率？</h3><p>Linux 事先定义了节拍率 HZ 每当触发一次时间中断，全局变量 Jiffies 就会加 1。这个值在 <code>/boot/config</code> 中被定义。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># grep 'CONFIG_HZ=' /boot/config-3.10.0-1127.10.1.el7.x86_64</span></span><br><span class="line">CONFIG_HZ=<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>这里的 1000 表示每秒钟触发 1000 次时间中断，节拍率是内核选项，用户空间节拍率是 USER_HZ，它总是 100，Linux 通过 <code>/proc</code> 文件向用户提供系统内部的信息，在 <code>/proc/stat</code> 提供系统的 CPU 和任务统计信息。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># cat /proc/stat | grep ^cpu</span></span><br><span class="line">cpu  <span class="number">2070722</span> <span class="number">339</span> <span class="number">978764</span> <span class="number">233911909</span> <span class="number">69735</span> <span class="number">0</span> <span class="number">11212</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu0 <span class="number">2070722</span> <span class="number">339</span> <span class="number">978764</span> <span class="number">233911909</span> <span class="number">69735</span> <span class="number">0</span> <span class="number">11212</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里的第一行是之后每一行的累加结果，具体含义：</p>
<ul>
<li>user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</li>
<li>nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</li>
<li>system（通常缩写为 sys），代表内核态 CPU 时间。</li>
<li>idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。</li>
<li>iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。</li>
<li>irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li>
<li>softirq（通常缩写为 si），代表处理软中断的 CPU 时间。</li>
<li>steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li>
<li>guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</li>
<li>guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</li>
</ul>
<script type="math/tex; mode=display">平均CPU使用率=1-\frac{\text {空闲时间}_{n e w}-\text { 空闲时间 }_{\text {old }}}{ \text { 总CPU时间 }\left._{n e w}-\text {总CPU时间}\right._{\text {old}}}</script><blockquote>
<p>重点在于时间间隔，比如 <code>top</code> 里的时间间隔是 3s 的，而 <code>ps</code> 则是进程的整个生命周期。</p>
</blockquote>
<p><code>top</code> 对于每个进程没有细分用户态和内核态的 CPU 使用率，可以通过 <code>pidstat</code> 查看每个进程的 CPU 使用详情，包括：</p>
<ul>
<li>用户态 CPU 使用率 （%usr）；</li>
<li>内核态 CPU 使用率（%system）；</li>
<li>运行虚拟机 CPU 使用率（%guest）；</li>
<li>等待 CPU 使用率（%wait）；</li>
<li>以及总的 CPU 使用率（%CPU）。</li>
</ul>
<h3 id="4-2-CPU-使用率过高怎么办？"><a href="#4-2-CPU-使用率过高怎么办？" class="headerlink" title="4.2 CPU 使用率过高怎么办？"></a>4.2 CPU 使用率过高怎么办？</h3><p>通过 <code>top</code> <code>ps</code> <code>pidstat</code> 等工具可以找到 CPU 高的进程，但是是哪个函数呢？首先能想到的是 GDB（The GNU Project Debugger），但是它不适合在性能分析的早期使用，因为 GDB 会中断程序，在线上是不允许的，它适合在分析的后期，在线下调试函数内部的问题，这里推荐使用 <code>perf</code>，它是 Linux 2.6.31 后内置的性能分析工具。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># perf top</span></span><br><span class="line">Samples: <span class="number">2</span>K of event <span class="string">'cpu-clock'</span>, <span class="number">4000</span> Hz, Event count (approx.): <span class="number">310098968</span> lost: <span class="number">0</span>/<span class="number">0</span> drop: <span class="number">0</span>/<span class="number">0</span></span><br><span class="line">Overhead  Shared Object                           Symbol</span><br><span class="line">   <span class="number">9.09</span>%  [kernel]                                [k] finish_task_switch</span><br><span class="line">   <span class="number">7.96</span>%  [kernel]                                [k] _raw_spin_unlock_irqrestore</span><br><span class="line">   <span class="number">5.37</span>%  perf                                    [.] rb_next</span><br><span class="line">   <span class="number">5.15</span>%  perf                                    [.] __symbols__insert</span><br><span class="line">   <span class="number">3.99</span>%  [kernel]                                [k] run_timer_softirq</span><br><span class="line">   <span class="number">2.70</span>%  [kernel]                                [k] tick_nohz_idle_enter</span><br><span class="line">   <span class="number">1.92</span>%  [kernel]                                [k] __do_softirq</span><br><span class="line">   <span class="number">1.52</span>%  [kernel]                                [k] kallsyms_expand_symbol.constprop.<span class="number">1</span></span><br><span class="line">   <span class="number">1.47</span>%  perf                                    [.] rb_insert_color</span><br></pre></td></tr></table></figure>
<p>使用 <code>perf top</code> 的效果如上所示，显示占用 CPU 时钟最多的函数或指令，第一行分别是：采样数、事件类型、事件总量。这里是 2000 个采样，类型是 cpu-clock，事件总量是 310098968。</p>
<p>之后的 Overhead 表示该符号的性能事件在所有采样中的比例，用百分比来表示；Shared 是该函数或指令所在的动态共享对象；Object 是动态共享对象的类型，比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间；Symbol 是符号名，也就是函数名，当函数名未知时，用十六进制的地址来表示。</p>
<p>此外还能使用 <code>perf record</code> 和 <code>perf report</code> 进行保存数据、离线分析，输出的报告和 <code>perf top</code> 类似。</p>
<h3 id="4-3-案例分析"><a href="#4-3-案例分析" class="headerlink" title="4.3 案例分析"></a>4.3 案例分析</h3><p>在虚拟机（1 CPU 2 GB）上运行 Nginx + PHP 的 Web 服务，本地通过 apache bench 进行压力测试，使用并发 10 请求，共发送 100 个请求：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -c <span class="number">10</span> -n <span class="number">100</span> http://xxx:<span class="number">10000</span>/</span><br><span class="line">Requests per second:    <span class="number">11.68</span> [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">856.416</span> [ms] (mean)</span><br></pre></td></tr></table></figure>
<p>发现每秒平均只有 11.68 ，然后将请求总数提高到 10000，在第一个终端用 <code>top</code> 查看 CPU 的情况。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line"><span class="number">4731</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9372</span>   <span class="number">1692</span> R <span class="number">19.9</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">06.03</span> php-fpm</span><br><span class="line"><span class="number">4730</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9368</span>   <span class="number">1688</span> R <span class="number">19.6</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">06.14</span> php-fpm</span><br><span class="line"><span class="number">4732</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9364</span>   <span class="number">1684</span> R <span class="number">19.6</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">05.94</span> php-fpm</span><br><span class="line"><span class="number">4733</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9364</span>   <span class="number">1684</span> R <span class="number">19.6</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">05.94</span> php-fpm</span><br><span class="line"><span class="number">4734</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9364</span>   <span class="number">1684</span> R <span class="number">19.6</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">05.85</span> php-fpm</span><br><span class="line"> <span class="number">956</span> root      <span class="number">10</span> -<span class="number">10</span>  <span class="number">160856</span>  <span class="number">44608</span>   <span class="number">5880</span> S  <span class="number">0.7</span>  <span class="number">2.4</span> <span class="number">217</span>:<span class="number">43.96</span> AliYunDun</span><br></pre></td></tr></table></figure>
<p>可以发现用户空间的 php-fpm 使用了几乎 100% 的 CPU，然后通过 <code>perf</code> 查看函数。因为 PHP 与 Nginx 在 docker 内执行，如果直接通过 <code>perf top</code> 是看不到具体方法的，只能看到 16 进制的地址，需要通过 <code>perf record -g -p &lt;pid&gt;</code> 保存结果，然后 <code>docker cp perf.data xxx:/tmp</code> 拷贝，使用 <code>docker exec -i -t xxx bash</code> 进入容器，然后安装 <code>perf</code> 工具即 <code>apt-get update &amp;&amp; apt-get install -y linux-perf linux-tools procps</code>，最后使用 <code>perf report</code> 查看报告。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200619170506.png" alt></p>
<p>可以发现 sqrt 和 add_function 函数有问题，可以将源码拷出来使用 <code>docker cp phpfpm:/app .</code>。接着从源码发现，问题出在了 sqrt 函数。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># grep sqrt -r app/</span></span><br><span class="line">app/index.php:  <span class="variable">$x</span> += sqrt(<span class="variable">$x</span>);</span><br><span class="line">[root@koonchen ~]<span class="comment"># grep add_function -r app/</span></span><br><span class="line">[root@koonchen ~]<span class="comment"># cat app/index.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">// test only.</span><br><span class="line"><span class="variable">$x</span> = <span class="number">0.0001</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt;= <span class="number">1000000</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">  <span class="variable">$x</span> += sqrt(<span class="variable">$x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo <span class="string">"It works!"</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>使用修复结果进行 ab 测试，每秒处理数从 11 变成 271：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -c <span class="number">10</span> -n <span class="number">10000</span> -k http://xxx:<span class="number">10000</span>/</span><br><span class="line">Requests per second:    <span class="number">271.09</span> [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">36.888</span> [ms] (mean)</span><br></pre></td></tr></table></figure>
<h2 id="5-找到-CPU-利用率高的应用"><a href="#5-找到-CPU-利用率高的应用" class="headerlink" title="5. 找到 CPU 利用率高的应用"></a>5. 找到 CPU 利用率高的应用</h2><p>当 CPU 使用率高的时候，我们不一定能找到相应的高 CPU 使用率进程，现在在虚拟机上启动一个 Nginx 和 PHP 然后通过本地访问 curl：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p <span class="number">10000</span>:<span class="number">80</span> -itd feisky/nginx:sp</span><br><span class="line">docker run --name phpfpm -itd --network container:nginx feisky/php-fpm:sp</span><br><span class="line"></span><br><span class="line">curl http://xxx:<span class="number">10000</span>/</span><br><span class="line">It works!</span><br></pre></td></tr></table></figure>
<p>通过 ab 进行并发 100 共 1000 的请求：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ab -c <span class="number">100</span> -n <span class="number">1000</span> http://xxx:<span class="number">10000</span>/</span><br><span class="line"></span><br><span class="line">Requests per second:    <span class="number">70.60</span> [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">1416.448</span> [ms] (mean)</span><br></pre></td></tr></table></figure>
<p>每秒请求数只有 70，接着就来处理这个问题了，现在把并发改成 5，时间为 10 分钟。现在去服务器，发现使用 <code>top</code> 以后 CPU 使用率为 80%，但是显示的进程占用都不高，然后用 <code>pidstat</code> 查看。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># pidstat 1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span>-<span class="number">514.26</span>.<span class="number">2</span>.el7.x86_64 (koonchen) 	<span class="number">06</span>/<span class="number">21</span>/<span class="number">2020</span> 	_x86_64_	(<span class="number">1</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">35</span> PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">0</span>       <span class="number">956</span>    <span class="number">5.00</span>    <span class="number">2.00</span>    <span class="number">0.00</span>    <span class="number">7.00</span>     <span class="number">0</span>  AliYunDun</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM   <span class="number">101</span>      <span class="number">7560</span>    <span class="number">1.00</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">2.00</span>     <span class="number">0</span>  nginx</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12214</span>    <span class="number">0.00</span>    <span class="number">2.00</span>    <span class="number">0.00</span>    <span class="number">2.00</span>     <span class="number">0</span>  php-fpm</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12221</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">1.00</span>     <span class="number">0</span>  php-fpm</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12228</span>    <span class="number">1.00</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">2.00</span>     <span class="number">0</span>  php-fpm</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12238</span>    <span class="number">1.00</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">2.00</span>     <span class="number">0</span>  php-fpm</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12239</span>    <span class="number">0.00</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">1.00</span>     <span class="number">0</span>  php-fpm</span><br></pre></td></tr></table></figure>
<p>所有进程的 CPU 使用率也不高，回到 <code>top</code> 再看看是否有遗漏信息。发现 Nginx 和 PHP 进程都处于 Sleep 状态，而 Running 状态的是 stress 进程，随便找到一个查看一下 <code>pidstat -p 25858</code> 竟然不存在，用 <code>ps aux | grep 25858</code> 状态已经变成了 S+，已经暂停了，同时在 <code>top</code> 中这个进程不见了，可能是因为：</p>
<ol>
<li>进程不断崩溃重启；</li>
<li>进程是短时进程。</li>
</ol>
<p>如果想要找到这个 stress 进程是怎么被调用的，就需要找到父进程，可以使用 <code>pstree</code> 工具。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># pstree | grep stress</span></span><br><span class="line">        |            |-containerd-shim-+-php-fpm-+-<span class="number">2</span>*[php-fpm---sh---stress---stress]</span><br></pre></td></tr></table></figure>
<p>发现 stress 进程是被 PHP 调用的，将 PHP 源码拷贝到本地：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># docker cp phpfpm:/app .</span></span><br><span class="line"></span><br><span class="line">[root@koonchen ~]<span class="comment"># grep stress -r app</span></span><br><span class="line">app/index.php:// fake I/O with stress (via write()/unlink()).</span><br><span class="line">app/index.php:<span class="variable">$result</span> = exec(<span class="string">"/usr/local/bin/stress -t 1 -d 1 2&gt;&amp;1"</span>, <span class="variable">$output</span>, <span class="variable">$status</span>);</span><br></pre></td></tr></table></figure>
<p>找到 index.php 源码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// fake I/O with stress (via write()/unlink()).</span></span><br><span class="line">$result = exec(<span class="string">"/usr/local/bin/stress -t 1 -d 1 2&gt;&amp;1"</span>, $output, $status);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">"verbose"</span>]) &amp;&amp; $_GET[<span class="string">"verbose"</span>]==<span class="number">1</span> &amp;&amp; $status != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Server internal error: "</span>;</span><br><span class="line">  print_r($output);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"It works!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>原来这里每一个请求都会调用 <code>stress</code> 命令，模拟了 IO 压力，但是之前只看到 CPU 使用率升高，通过 verbose 参数但因日志：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl http://<span class="number">112.124</span>.<span class="number">14.155</span>:<span class="number">10000</span>\?verbose=<span class="number">1</span></span><br><span class="line">Server internal error: Array</span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; stress: info: [<span class="number">5727</span>] dispatching hogs: <span class="number">0</span> cpu, <span class="number">0</span> io, <span class="number">0</span> vm, <span class="number">1</span> hdd</span><br><span class="line">    [<span class="number">1</span>] =&gt; stress: FAIL: [<span class="number">5731</span>] (<span class="number">563</span>) mkstemp failed: Permission denied</span><br><span class="line">    [<span class="number">2</span>] =&gt; stress: FAIL: [<span class="number">5727</span>] (<span class="number">394</span>) &lt;-- worker <span class="number">5731</span> returned error <span class="number">1</span></span><br><span class="line">    [<span class="number">3</span>] =&gt; stress: WARN: [<span class="number">5727</span>] (<span class="number">396</span>) now reaping child worker processes</span><br><span class="line">    [<span class="number">4</span>] =&gt; stress: FAIL: [<span class="number">5727</span>] (<span class="number">400</span>) kill error: No such <span class="keyword">process</span></span><br><span class="line">    [<span class="number">5</span>] =&gt; stress: FAIL: [<span class="number">5727</span>] (<span class="number">451</span>) failed run completed <span class="keyword">in</span> <span class="number">0</span>s</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>因为 stress 命令没有成功，因为权限问题失败了，因此大量 stress 进程初始化失败，导致 CPU 升高。这些都仅仅是<strong>猜测</strong>，下一步是<strong>验证</strong>，通过 <code>perf record -g</code> 和 <code>perf report</code> 查看报告，注意因为在 docker 中运行的进程，需要将报告复制进容器查看，可以发现是 stress 中 random() 函数占用了大量的 CPU 时钟。</p>
<blockquote>
<p>像这类短时进程问题，可以用 <code>execsnoop</code> 工具，它可以直接找到 stress 进程的父进程 PID 以及命令行参数，之后会用到。</p>
</blockquote>
<h2 id="6-大量不可用中断进程与僵尸进程"><a href="#6-大量不可用中断进程与僵尸进程" class="headerlink" title="6. 大量不可用中断进程与僵尸进程"></a>6. 大量不可用中断进程与僵尸进程</h2><p>当 iowait 升高时进程很可能因为得不到硬件相应而处于不可中断状态，从 <code>ps</code> 或 <code>top</code> 都发现它们属于 D 状态，也就是 Uninterruptible Sleep 状态。</p>
<ul>
<li>R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</li>
<li>D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</li>
<li>Z 是 Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。<ul>
<li>一旦父进程没有处理子进程的终止，还一直保持运行状态，那么子进程就会一直处于僵尸状态。</li>
</ul>
</li>
<li>S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。</li>
<li>I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。<ul>
<li>前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。</li>
<li>要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。</li>
</ul>
</li>
<li>T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。<ul>
<li>向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；再向它发送 SIGCONT 信号，进程又会恢复运行。</li>
<li>而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。</li>
</ul>
</li>
<li>X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。</li>
</ul>
<h3 id="6-1-案例表现"><a href="#6-1-案例表现" class="headerlink" title="6.1 案例表现"></a>6.1 案例表现</h3><p>使用 <code>docker run --privileged --name=app -itd feisky/app:iowait</code> 可以运行一个不断产生僵尸进程的应用，通过 <code>ps aux | grep /app</code> 可以看到有一个 <code>Ss+</code> 和多个 <code>D+</code> 的应用。</p>
<blockquote>
<p><code>--privileged</code> 参数使容器拥有了访问任何其它设备的权限。</p>
</blockquote>
<ul>
<li>S 表示可中断睡眠状态；</li>
<li>D 表示不可中断睡眠状态；</li>
<li>s 表示这个进程是一个会话的领导进程；</li>
<li><ul>
<li>表示前台进程组。</li>
</ul>
</li>
</ul>
<p>使用 <code>top</code> 看到如下信息（这里直接用教程的例子了，用单核服务器会卡死）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br><span class="line">top - <span class="number">05</span>:<span class="number">56</span>:<span class="number">23</span> up <span class="number">17</span> days, <span class="number">16</span>:<span class="number">45</span>,  <span class="number">2</span> users,  load average: <span class="number">2.00</span>, <span class="number">1.68</span>, <span class="number">1.39</span></span><br><span class="line">Tasks: <span class="number">247</span> total,   <span class="number">1</span> running,  <span class="number">79</span> sleeping,   <span class="number">0</span> stopped, <span class="number">115</span> zombie</span><br><span class="line">%Cpu0  :  <span class="number">0.0</span> us,  <span class="number">0.7</span> sy,  <span class="number">0.0</span> ni, <span class="number">38.9</span> id, <span class="number">60.5</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">%Cpu1  :  <span class="number">0.0</span> us,  <span class="number">0.7</span> sy,  <span class="number">0.0</span> ni,  <span class="number">4.7</span> id, <span class="number">94.6</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> <span class="number">4340</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">44676</span>   <span class="number">4048</span>   <span class="number">3432</span> R   <span class="number">0.3</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.05</span> top</span><br><span class="line"> <span class="number">4345</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">37280</span>  <span class="number">33624</span>    <span class="number">860</span> D   <span class="number">0.3</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.01</span> app</span><br><span class="line"> <span class="number">4344</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">37280</span>  <span class="number">33624</span>    <span class="number">860</span> D   <span class="number">0.3</span>  <span class="number">0.4</span>   <span class="number">0</span>:<span class="number">00.01</span> app</span><br><span class="line">    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">160072</span>   <span class="number">9416</span>   <span class="number">6752</span> S   <span class="number">0.0</span>  <span class="number">0.1</span>   <span class="number">0</span>:<span class="number">38.59</span> systemd</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>平均负载正在逐渐升高，说明系统很可能已经有了性能瓶颈；</li>
<li>有 1 个正在运行的进程，但僵尸进程比较多，而且还在不停增加，说明有子进程在退出时没被清理；</li>
<li>用户 CPU 和系统 CPU 都不高，但 iowait 分别是 60.5% 和 94.6%；</li>
<li>每个进程的情况，CPU 使用率最高的进程只有 0.3%，看起来并不高；但有两个进程处于 D 状态，它们可能在等待 I/O，但光凭此并不能确定是它们导致了 iowait 升高。</li>
</ul>
<p>通过这四个发现可以得到以下两个结论：</p>
<ol>
<li>iowait 太高了，导致系统的平均负载升高，甚至达到了系统 CPU 的个数；</li>
<li>僵尸进程在不断增多，说明有程序没能正确清理子进程的资源。</li>
</ol>
<h3 id="6-2-案例分析"><a href="#6-2-案例分析" class="headerlink" title="6.2 案例分析"></a>6.2 案例分析</h3><p>查询系统的 IO 情况可以使用 <code>dstat</code> 工具，它可以同时查看 CPU 和 IO 两种资源，使用 <code>dstat 1 10</code> 展示信息如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔1秒输出10组数据</span></span><br><span class="line">dstat <span class="number">1</span> <span class="number">10</span></span><br><span class="line">--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai stl| read  writ| recv  send|  <span class="keyword">in</span>   out | int   csw</span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>  <span class="number">96</span>   <span class="number">4</span>   <span class="number">0</span>|<span class="number">1219</span>k  <span class="number">408</span>k|   <span class="number">0</span>     <span class="number">0</span> |   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">42</span>   <span class="number">885</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">2</span>  <span class="number">98</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> | <span class="number">198</span>B  <span class="number">790</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">42</span>   <span class="number">138</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span> <span class="number">100</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">42</span>   <span class="number">135</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>  <span class="number">84</span>  <span class="number">16</span>   <span class="number">0</span>|<span class="number">5633</span>k    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">52</span>   <span class="number">177</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">3</span>  <span class="number">39</span>  <span class="number">58</span>   <span class="number">0</span>|  <span class="number">22</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">43</span>   <span class="number">144</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span> <span class="number">100</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> | <span class="number">200</span>B  <span class="number">450</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">46</span>   <span class="number">147</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">2</span>  <span class="number">98</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">45</span>   <span class="number">134</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span> <span class="number">100</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">39</span>   <span class="number">131</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>  <span class="number">83</span>  <span class="number">17</span>   <span class="number">0</span>|<span class="number">5633</span>k    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">46</span>   <span class="number">168</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">3</span>  <span class="number">39</span>  <span class="number">59</span>   <span class="number">0</span>|  <span class="number">22</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">37</span>   <span class="number">134</span></span><br></pre></td></tr></table></figure>
<p>首先要处理 IO 高的问题，从上表发现，当 wai 升高即 iowait 上高时，read 请求会很大，可能是磁盘读导致的。通过 <code>top</code> 找到 D 状态的进程，可以找到其 PID，而查看一个进程的使用情况，就可以使用 <code>pidstat</code>，使用 <code>-d</code> 参数可以输出 IO 情况。但是可以发现 D 状态进程不一定存在问题，因此可以直接查看所有进程的 IO 情况。</p>
<p>这时可以发现 app 进程有大量的 kB_rd/s，表示每秒读的 KB 数，找到了进程后可以用 <code>strace -p [pid]</code> 来查看进程的追踪信息，然而追踪失败了，<strong>一般这种情况下，需要看看进程状态是否正常</strong>。</p>
<p>回到 <code>ps aux | grep [pid]</code> 发现其状态变成了 Z，就是说进程变成了僵尸进程，用 <code>perf record -g</code> 和 <code>perf report</code> 找到僵尸进程的调用栈，发现 app 应用中 IO 高是因为应用直接访问了磁盘，更改后的进程 iowait 会明显降低，但是僵尸进程的问题还是存在。</p>
<p>接下来僵尸进程的问题是因为父进程的调用错误，通过 <code>pstree -aps &lt;pid&gt;</code> 查看进程父子关系，<code>a</code> 表示输出命令行选项，<code>p</code> 表示 PID，<code>s</code> 表示指定进程的父进程，发现指向了 app 应用，查看其中调用 <code>wait()</code> 或 <code>waitpid()</code> 的地方，修复问题。</p>
<p>至此，iowait 高和大量僵尸进程的问题被处理。iowait 高不一定代表 I/O 有性能瓶颈。当系统中只有 I/O 类型的进程在运行时，iowait 也会很高，但实际上，磁盘的读写远没有达到性能瓶颈的程度。</p>
<ul>
<li>碰到 iowait 升高时，需要先用 dstat、pidstat 等工具，确认是不是磁盘 I/O 的问题，然后再找是哪些进程导致了 I/O。</li>
<li>等待 I/O 的进程一般是不可中断状态，所以用 ps 命令找到的 D 状态（即不可中断状态）的进程，多为可疑进程。</li>
<li>但这个案例中，在 I/O 操作后，进程又变成了僵尸进程，所以不能用 strace 直接分析这个进程的系统调用。</li>
<li>这种情况下，我们用了 perf 工具，来分析系统的 CPU 时钟事件，最终发现是直接 I/O 导致的问题。这时，再检查源码中对应位置的问题，就很轻松了。</li>
<li>而僵尸进程的问题相对容易排查，使用 pstree 找出父进程后，去查看父进程的代码，检查 wait() / waitpid() 的调用，或是 SIGCHLD 信号处理函数的注册就行了。</li>
</ul>
<h2 id="7-理解-Linux-中断"><a href="#7-理解-Linux-中断" class="headerlink" title="7. 理解 Linux 中断"></a>7. 理解 Linux 中断</h2><p><strong>进程的不可中断状态是系统的一种保护机制，短时间的不可中断状态是正常的</strong>。除了 iowait，软中断 softirq 使得 CPU 使用率升高也是一种常见的性能问题。</p>
<p><strong>中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力</strong>。由于中断处理程序会打断其他进程的运行，所以，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。如果有两个中断一前一后，前一个中断时间长，后一个中断时间短，可能会造成第二个中断处理丢失的情况。</p>
<p>为此，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：</p>
<ul>
<li>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。</li>
<li>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。</li>
</ul>
<p>可以通过 <code>/proc/softirqs</code> 查看软中断，通过 <code>/proc/interrupts</code> 查看硬中断。</p>
<p>软中断的下半部分是内核线程的形式运行的，因此可以通过 <code>ps aux | grep softirq</code> 查看它们的运行状况。</p>
<blockquote>
<p>ps 的输出中，名字在中括号里的，一般都是内核线程，无法获取它们的命令行参数。</p>
</blockquote>
<h2 id="8-软中断-CPU-使用率上升处理"><a href="#8-软中断-CPU-使用率上升处理" class="headerlink" title="8. 软中断 CPU 使用率上升处理"></a>8. 软中断 CPU 使用率上升处理</h2><p>案例需要用到三个新的工具：</p>
<ul>
<li>sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。</li>
<li>hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。</li>
<li>tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。</li>
</ul>
<p>操作流程如下：</p>
<ol>
<li>首先在云服务器上运行一个 Nginx 使用 <code>docker run -itd --name=nginx -p 80:80 nginx</code>，如果下载速度慢可以在 <code>/etc/docker</code> 下设置换源。</li>
<li>启动后在本地使用 <code>curl</code> 查看是否可以访问，然后本地通过 <code>hping</code> 进行请求：<code>hping3 -S -p 80 -i u100 xxx</code>，其中 <code>-S</code> 表示 TCP 协议的 SYN 同步序列号，<code>-i u100</code> 表示每隔 100 ms 发送一个网络帧。<ul>
<li>这是通过 hping3 模拟 SYN FLOOD 攻击。</li>
</ul>
</li>
<li>此时云服务器会有卡顿现象出现，通过 <code>top</code> 发现平均负载很低，CPU 使用率也很低，并且来自 ksoftirqd 的进程。</li>
<li>通过 <code>watch -d cat /proc/softirqs</code> 监控软负载，发现 TIMER、NET_RX、SCHED、RCU 都在不停变化，只有 NET_RX 变化最快，其他都是 Linux 必须的调度。</li>
<li>通过 <code>sar -n DEV 1</code> 查看系统的网络收发以及每秒的情况，，<code>-n DEV</code> 表示显示网络收发的报告。<ul>
<li>第一列：表示报告的时间。</li>
<li>第二列：IFACE 表示网卡。</li>
<li>第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS。</li>
<li>第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS。</li>
</ul>
</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sar -n DEV <span class="number">1</span></span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">46</span>        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">47</span>         eth0  <span class="number">12607.00</span>   <span class="number">6304.00</span>    <span class="number">664.86</span>    <span class="number">358.11</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.01</span></span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">47</span>      docker0   <span class="number">6302.00</span>  <span class="number">12604.00</span>    <span class="number">270.79</span>    <span class="number">664.66</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">47</span>           lo      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">47</span>    veth9f6bbcd   <span class="number">6302.00</span>  <span class="number">12604.00</span>    <span class="number">356.95</span>    <span class="number">664.66</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.05</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在 eth0 中接收的 PPS 比较大，达到 12607，而接收的 BPS 却很小，只有 664 KB。<ul>
<li>664*1024/12607 = 54 字节，说明平均每个网络帧只有 54 字节，这显然是很小的网络帧，也就是我们通常所说的小包问题。</li>
</ul>
</li>
<li>通过 <code>tcpdump -i eth0 -n tcp port 80</code> 可以抓包，<code>-i eth0</code> 只抓取 eth0 网卡，<code>-n</code> 不解析协议名和主机名，<code>tcp port 80</code> 表示只抓取 tcp 协议并且端口号为 80 的网络帧。</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i eth0 -n tcp port <span class="number">80</span></span><br><span class="line"><span class="number">15</span>:<span class="number">11</span>:<span class="number">32.678966</span> IP <span class="number">192.168</span>.<span class="number">0.2</span>.<span class="number">18238</span> &gt; <span class="number">192.168</span>.<span class="number">0.30</span>.<span class="number">80</span>: Flags [S], seq <span class="number">458303614</span>, win <span class="number">512</span>, length <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ol>
<li><code>Flags [S]</code> 则表示这是一个 SYN 包，现在可以确定这是从哪儿来的 SYN FLOOD 攻击。</li>
</ol>
<h2 id="9-分析-CPU-瓶颈"><a href="#9-分析-CPU-瓶颈" class="headerlink" title="9. 分析 CPU 瓶颈"></a>9. 分析 CPU 瓶颈</h2><p>CPU 的性能指标那么多，在实际场景中应该观察什么信息，使用什么工具？</p>
<h3 id="9-1-CPU-性能指标"><a href="#9-1-CPU-性能指标" class="headerlink" title="9.1 CPU 性能指标"></a>9.1 CPU 性能指标</h3><p><strong>首先应该想到的是 CPU 使用率</strong>，具体包括用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。</p>
<ul>
<li>用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态 CPU 使用率（nice），表示 CPU 在用户态运行的时间百分比。用户 CPU 使用率高，通常说明有应用程序比较繁忙。</li>
<li>系统 CPU 使用率，表示 CPU 在内核态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明内核比较繁忙。</li>
<li>等待 I/O 的 CPU 使用率，通常也称为 iowait，表示等待 I/O 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。</li>
<li>软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。</li>
<li>除了上面这些，还有在虚拟化环境中会用到的窃取 CPU 使用率（steal）和客户 CPU 使用率（guest），分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。</li>
</ul>
<p><strong>其次应该想到是平均负载</strong>，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。</p>
<ul>
<li>理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了。</li>
</ul>
<p><strong>接着是进程上下文切换</strong>，包括了无法获取资源而导致的自愿上下文切换和被系统强制调度导致的非自愿上下文切换。</p>
<ul>
<li>过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成为性能瓶颈。</li>
</ul>
<p><strong>还有一个指标是 CPU 缓存命中率</strong>，CPU 在访问内存的时候，免不了要等待内存的响应。为了协调这两者巨大的性能差距，CPU 缓存（通常是多级缓存）就出现了。</p>
<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200626174959.png" alt></p>
<ul>
<li>CPU 缓存的速度介于 CPU 和内存之间，缓存的是热点的内存数据。</li>
<li>缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常用在单核中， L3 则用在多核中。</li>
<li>从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次降低（当然比内存还是好得多）。</li>
<li>它们的命中率，衡量的是 CPU 缓存的复用情况，命中率越高，则表示性能越好。</li>
</ul>
<h3 id="9-2-案例汇总"><a href="#9-2-案例汇总" class="headerlink" title="9.2 案例汇总"></a>9.2 案例汇总</h3><ul>
<li>首先，平均负载的案例。<ul>
<li>我们先用 uptime， 查看了系统的平均负载；</li>
<li>而在平均负载升高后，又用 <code>mpstat</code> 和 <code>pidstat</code> ，分别观察了每个 CPU 和每个进程 CPU 的使用情况，进而找出了导致平均负载升高的进程，也就是我们的压测工具 stress。</li>
</ul>
</li>
<li>第二个，上下文切换的案例。<ul>
<li>我们先用 <code>vmstat</code> ，查看了系统的上下文切换次数和中断次数；</li>
<li>然后通过 <code>pidstat</code> ，观察了进程的自愿上下文切换和非自愿上下文切换情况；</li>
<li>最后通过 <code>pidstat -t</code> ，观察了线程的上下文切换情况，找出了上下文切换次数增多的根源，也就是我们的基准测试工具 sysbench。</li>
</ul>
</li>
<li>第三个，进程 CPU 使用率升高的案例。<ul>
<li>我们先用 <code>top</code> ，查看了系统和进程的 CPU 使用情况，发现 CPU 使用率升高的进程是 php-fpm；</li>
<li>再用 <code>perf top</code> ，观察 php-fpm 的调用链，最终找出 CPU 升高的根源，也就是库函数 sqrt() 。</li>
</ul>
</li>
<li>第四个，系统的 CPU 使用率升高的案例。<ul>
<li>我们先用 <code>top</code> 观察到了系统 CPU 升高，但通过 <code>top</code> 和 <code>pidstat</code> ，却找不出高 CPU 使用率的进程；</li>
<li>于是，我们重新审视 <code>top</code> 的输出，又从 CPU 使用率不高但处于 Running 状态的进程入手，找出了可疑之处；</li>
<li>最终通过 <code>perf record</code> 和 <code>perf report</code> ，发现原来是短时进程在捣鬼。</li>
<li>另外，对于短时进程，还介绍了一个专门的工具 <code>execsnoop</code> ，它可以实时监控进程调用的外部命令。</li>
</ul>
</li>
<li>第五个，不可中断进程和僵尸进程的案例。<ul>
<li>我们先用 <code>top</code> 观察到了 iowait 升高的问题，并发现了大量的不可中断进程和僵尸进程；</li>
<li>接着我们用 <code>dstat</code> 发现是这是由磁盘读导致的；</li>
<li>于是又通过 <code>pidstat</code> 找出了相关的进程；</li>
<li>但我们用 <code>strace</code> 查看进程系统调用却失败了；</li>
<li>最终还是用 <code>perf</code> 分析进程调用链，才发现根源在于磁盘直接 I/O 。</li>
</ul>
</li>
<li>最后一个，软中断的案例。<ul>
<li>我们通过 <code>top</code> 观察到，系统的软中断 CPU 使用率升高；</li>
<li>接着查看 <code>/proc/softirqs</code>， 找到了几种变化速率较快的软中断；</li>
<li>然后通过 <code>sar</code> 命令，发现是网络小包的问题；</li>
<li>最后再用 <code>tcpdump</code> ，找出网络帧的类型和来源，确定是一个 SYN FLOOD 攻击导致的。</li>
</ul>
</li>
</ul>
<h3 id="9-3-从性能指标出发"><a href="#9-3-从性能指标出发" class="headerlink" title="9.3 从性能指标出发"></a>9.3 从性能指标出发</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200626175430.png" alt></p>
<h3 id="9-4-从工具出发"><a href="#9-4-从工具出发" class="headerlink" title="9.4 从工具出发"></a>9.4 从工具出发</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200626175522.png" alt></p>
<h3 id="9-5-工具的联动"><a href="#9-5-工具的联动" class="headerlink" title="9.5 工具的联动"></a>9.5 工具的联动</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200626175859.png" alt></p>
<h2 id="10-CPU-性能优化"><a href="#10-CPU-性能优化" class="headerlink" title="10. CPU 性能优化"></a>10. CPU 性能优化</h2><h3 id="10-1-性能优化方法论"><a href="#10-1-性能优化方法论" class="headerlink" title="10.1 性能优化方法论"></a>10.1 性能优化方法论</h3><p>在进行性能优化时应该想想三个问题：</p>
<ol>
<li>首先，既然要做性能优化，那要怎么判断它是不是有效呢？特别是优化后，到底能提升多少性能呢？</li>
<li>第二，性能问题通常不是独立的，如果有多个性能问题同时发生，你应该先优化哪一个呢？</li>
<li>第三，提升性能的方法并不是唯一的，当有多种方法可以选择时，你会选用哪一种呢？是不是总选那个最大程度提升性能的方法就行了呢？</li>
</ol>
<p>比如我们发现是因为一个进程的直接 I/O ，导致了 iowait 高达 90%。那是不是用“直接 I/O 换成缓存 I/O”的方法，就可以立即优化了呢？</p>
<ol>
<li>第一个问题，直接 I/O 换成缓存 I/O，可以把 iowait 从 90% 降到接近 0，性能提升很明显。</li>
<li>第二个问题，我们没有发现其他性能问题，直接 I/O 是唯一的性能瓶颈，所以不用挑选优化对象。</li>
<li>第三个问题，缓存 I/O 是我们目前用到的最简单的优化方法，而且这样优化并不会影响应用的功能。</li>
</ol>
<h3 id="10-2-性能优化评估"><a href="#10-2-性能优化评估" class="headerlink" title="10.2 性能优化评估"></a>10.2 性能优化评估</h3><p>怎么评估性能优化的效果：</p>
<ol>
<li>确定性能的量化指标。</li>
<li>测试优化前的性能指标。</li>
<li>测试优化后的性能指标。</li>
</ol>
<p>不要局限在单一维度的指标上，你至少要从应用程序和系统资源这两个维度，分别选择不同的指标。比如，以 Web 应用为例：</p>
<ol>
<li>应用程序的维度，我们可以用<strong>吞吐量</strong>和<strong>请求延迟</strong>来评估应用程序的性能。</li>
<li>系统资源的维度，我们可以用 <strong>CPU 使用率</strong>来评估系统的 CPU 使用情况。</li>
</ol>
<h3 id="10-3-多个性能问题"><a href="#10-3-多个性能问题" class="headerlink" title="10.3 多个性能问题"></a>10.3 多个性能问题</h3><p><strong>80% 的问题都是由 20% 的代码导致的。</strong></p>
<ul>
<li>第一，如果发现是系统资源达到了瓶颈，比如 CPU 使用率达到了 100%，那么首先优化的一定是系统资源使用问题。完成系统资源瓶颈的优化后，我们才要考虑其他问题。</li>
<li>第二，针对不同类型的指标，首先去优化那些由瓶颈导致的，性能指标变化幅度最大的问题。比如产生瓶颈后，用户 CPU 使用率升高了 10%，而系统 CPU 使用率却升高了 50%，这个时候就应该首先优化系统 CPU 的使用。</li>
</ul>
<h3 id="10-4-多种优化方式"><a href="#10-4-多种优化方式" class="headerlink" title="10.4 多种优化方式"></a>10.4 多种优化方式</h3><p><strong>性能优化并非没有成本。</strong>性能优化通常会带来复杂度的提升，降低程序的可维护性，还可能在优化一个指标时，引发其他指标的异常。</p>
<p>综合多方面的因素。切记，不要想着“一步登天”，试图一次性解决所有问题；也不要只会“拿来主义”，把其他应用的优化方法原封不动拿来用，却不经过任何思考和分析。</p>
<h3 id="10-5-CPU-优化"><a href="#10-5-CPU-优化" class="headerlink" title="10.5 CPU 优化"></a>10.5 CPU 优化</h3><p>程序优化：</p>
<ul>
<li>编译器优化：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如， gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化。</li>
<li>算法优化：使用复杂度更低的算法，可以显著加快处理速度。比如，在数据比较大的情况下，可以用 O(nlogn) 的排序算法（如快排、归并排序等），代替 O(n^2) 的排序算法（如冒泡、插入排序等）。</li>
<li>异步处理：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题。</li>
<li>多线程代替多进程：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。</li>
<li>善用缓存：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。</li>
</ul>
<p>系统优化：</p>
<ul>
<li>CPU 绑定：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题。</li>
<li>CPU 独占：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU。</li>
<li>优先级调整：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理。</li>
<li>为进程设置资源限制：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。</li>
<li>NUMA（Non-Uniform Memory Access）优化：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。</li>
<li>中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="https://github.com/koonchen">Projects</a></li>
         
          <li><a href="https://valeriehu1995.github.io">PigChain</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是平均负载"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是平均负载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-平均负载高的不同情况"><span class="toc-number">2.</span> <span class="toc-text">2. 平均负载高的不同情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-CPU-密集型进程"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. CPU 密集型进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-IO-密集型进程"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 IO 密集型进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-大量进程的场景"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 大量进程的场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-CPU-上下文切换"><span class="toc-number">3.</span> <span class="toc-text">3. CPU 上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-CPU-上下文切换的三个种类"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 CPU 上下文切换的三个种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-CPU-上下文切换实验"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 CPU 上下文切换实验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-应用-CPU-利用率-100-怎么办？"><span class="toc-number">4.</span> <span class="toc-text">4. 应用 CPU 利用率 100% 怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-什么是-CPU-使用率？"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 什么是 CPU 使用率？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-CPU-使用率过高怎么办？"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 CPU 使用率过高怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-案例分析"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 案例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-找到-CPU-利用率高的应用"><span class="toc-number">5.</span> <span class="toc-text">5. 找到 CPU 利用率高的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-大量不可用中断进程与僵尸进程"><span class="toc-number">6.</span> <span class="toc-text">6. 大量不可用中断进程与僵尸进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-案例表现"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 案例表现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-案例分析"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 案例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-理解-Linux-中断"><span class="toc-number">7.</span> <span class="toc-text">7. 理解 Linux 中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-软中断-CPU-使用率上升处理"><span class="toc-number">8.</span> <span class="toc-text">8. 软中断 CPU 使用率上升处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-分析-CPU-瓶颈"><span class="toc-number">9.</span> <span class="toc-text">9. 分析 CPU 瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-CPU-性能指标"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 CPU 性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-案例汇总"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 案例汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-从性能指标出发"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 从性能指标出发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-从工具出发"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 从工具出发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-工具的联动"><span class="toc-number">9.5.</span> <span class="toc-text">9.5 工具的联动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-CPU-性能优化"><span class="toc-number">10.</span> <span class="toc-text">10. CPU 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-性能优化方法论"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 性能优化方法论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-性能优化评估"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 性能优化评估</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-多个性能问题"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 多个性能问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-多种优化方式"><span class="toc-number">10.4.</span> <span class="toc-text">10.4 多种优化方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-CPU-优化"><span class="toc-number">10.5.</span> <span class="toc-text">10.5 CPU 优化</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://chenzeping.com/technology/2020-04-16-linux-optimize1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&text=Linux CPU 性能优化"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&is_video=false&description=Linux CPU 性能优化"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Linux CPU 性能优化&body=Check out this article: https://chenzeping.com/technology/2020-04-16-linux-optimize1/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&title=Linux CPU 性能优化"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://chenzeping.com/technology/2020-04-16-linux-optimize1/&name=Linux CPU 性能优化&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Koon Chen
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="https://github.com/koonchen">Projects</a></li>
         
          <li><a href="https://valeriehu1995.github.io">PigChain</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<!-- <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"> -->
<link rel="stylesheet" href="//cdn.staticfile.org/font-awesome/5.2.0/css/all.min.css">
<!-- <link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css"> -->
<link rel="stylesheet" href="//cdn.staticfile.org/justifiedGallery/3.6.5/css/justifiedGallery.min.css">

    <!-- jquery -->
<!-- <script src="/lib/jquery/jquery.min.js"></script> -->
<script src="//cdn.staticfile.org/jquery/3.3.1/jquery.min.js"></script>
<!-- <script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script> -->
<script src="//cdn.staticfile.org/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-109260587-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
