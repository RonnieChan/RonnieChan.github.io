<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rust 学习笔记</title>
      <link href="/note/2022-11-06-rust-learning-notes/"/>
      <url>/note/2022-11-06-rust-learning-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="1-入门指南"><a href="#1-入门指南" class="headerlink" title="1. 入门指南"></a>1. 入门指南</h2><ul><li>安装指令 <code>curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li><li>默认启动 <code>export PATH=&quot;$HOME/.cargo/bin:$PATH</code></li><li>更新 <code>rustup update</code></li><li>卸载 <code>rustup self uninstall</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
            <tag> ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探依赖倒置</title>
      <link href="/design-pattern/2021-12-24-DIP/"/>
      <url>/design-pattern/2021-12-24-DIP/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内容"><a href="#1-内容" class="headerlink" title="1. 内容"></a>1. 内容</h2><p>『Dependence Inversion Principle』是 1996 年 Robert C.Martin 在 C++ Report 上发表的文章。</p><blockquote><p>High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions.<br>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p></blockquote><p><strong>要面向接口编程，不要面向实现编程</strong>。简单说即<strong>通过面向接口的编程来降低类间的耦合性</strong>。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h2><p>DIP 的主要作用：</p><ol><li>降低类间的耦合性。</li><li>提高系统的稳定性。</li><li>减少并行开发引起的风险。</li><li>提高代码的可读性和可维护性。</li></ol><h2 id="3-要点"><a href="#3-要点" class="headerlink" title="3. 要点"></a>3. 要点</h2><h3 id="3-1-依赖倒置与控制反转"><a href="#3-1-依赖倒置与控制反转" class="headerlink" title="3.1 依赖倒置与控制反转"></a>3.1 依赖倒置与控制反转</h3><p>控制反转和依赖倒置这两名词仅顾名思义的话，听起来还是『类似』的，其宗旨都是<strong>程序员要在环境或框架既定的规范下工作，而不得不丧失掉一部分代码的主动性</strong>。</p><p>但是控制反转是 Spring 框架中的一个思想，即依赖方不需要关心被依赖对象的创建，只需要使用传进来的被依赖对象即可。</p><h2 id="4-场景"><a href="#4-场景" class="headerlink" title="4. 场景"></a>4. 场景</h2><h3 id="4-1-例一"><a href="#4-1-例一" class="headerlink" title="4.1 例一"></a>4.1 例一</h3><p>商店类中有 <code>sell()</code> 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 <code>ShaoguanShop</code> 购物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(ShaoguanShop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该顾客想从另外一家商店（如婺源网店 <code>WuyuanShop</code>）购物，就要将该顾客的代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(WuyuanShop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。解决方法是：定义婺源网店和韶关网店的共同接口 <code>Shop</code>，顾客类面向该接口编程，其代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(Shop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif" alt></p><h2 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5. 最佳实践"></a>5. 最佳实践</h2><ol><li>每个类尽量提供<strong>接口</strong>或<strong>抽象类</strong>，或者两者都具备。</li><li>变量的声明类型尽量是<strong>接口</strong>或<strong>抽象类</strong>。</li><li>大部分情况下类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ol><h2 id="6-系统优化"><a href="#6-系统优化" class="headerlink" title="6. 系统优化"></a>6. 系统优化</h2><p><em>讨论</em>。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探里氏替换</title>
      <link href="/design-pattern/2021-12-20-LSP/"/>
      <url>/design-pattern/2021-12-20-LSP/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内容"><a href="#1-内容" class="headerlink" title="1. 内容"></a>1. 内容</h2><p>『Liskov Substitution Principle』概念来自 1994 年论文 <a href="https://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf" target="_blank" rel="noopener">A Behavioral Notion Of Subtyping</a>：</p><blockquote><p>If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T.<br>如果 S 是 T 的子类型，对于 S 类型的任意对象，如果将他们看作是 T 类型的对象，则对象的行为也理应与期望的行为一致。</p></blockquote><p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。或者说，<strong>接口的实现必须满足『调用者对接口的所有期望』而不是仅仅是『满足接口的签名』</strong>。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h2><p>主要作用如下：</p><ol><li>LSP 是实现『开闭原则』的重要方式之一。</li><li>LSP 克服了继承中重写父类造成的可复用性变差的缺点。</li><li>LSP 是动作正确性的保证，类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>LSP 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ol><h2 id="3-要点"><a href="#3-要点" class="headerlink" title="3. 要点"></a>3. 要点</h2><h3 id="3-1-什么是替换？"><a href="#3-1-什么是替换？" class="headerlink" title="3.1 什么是替换？"></a>3.1 什么是替换？</h3><p>假设有一个方法可以获取列表的第一个值，方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFirst</span><span class="params">(List&lt;String&gt; list)</span></span>;</span><br></pre></td></tr></table></figure><p>从上面的签名中可以知道它做的事情是从 <code>String</code> 列表中获取了第一个值，并且这个返回值是一个 <code>String</code> 对象。我们在实现时需要根据入参的不同做不同的处理。</p><h3 id="3-2-多态是否违背-LSP？"><a href="#3-2-多态是否违背-LSP？" class="headerlink" title="3.2 多态是否违背 LSP？"></a>3.2 多态是否违背 LSP？</h3><p>不违背。LSP 有两种含义：</p><ol><li>继承是为了代码复用。此时子类与复用公用同一实现，满足『子类对象能够替换父类对象，而程序逻辑不变』。</li><li>继承是为了多态。多态的前提是子类覆盖并重定义父类的方法，此时父类应该是接口类或抽象类，所以不存在父类实例化的情况。</li></ol><h2 id="4-场景"><a href="#4-场景" class="headerlink" title="4. 场景"></a>4. 场景</h2><h3 id="4-1-例一"><a href="#4-1-例一" class="headerlink" title="4.1 例一"></a>4.1 例一</h3><p>假设当前实现一个自定义 <code>List</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时 <code>List</code> 的 <code>get</code> 如下定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment">*         (&lt;tt&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/tt&gt;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><p>由于 <code>get</code> 只声明了会抛出 <code>IndexOutOfBoundsException</code> 异常，因此这个自定义的 <code>List</code> 不满足 LSP。</p><h3 id="4-2-例二"><a href="#4-2-例二" class="headerlink" title="4.2 例二"></a>4.2 例二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，如果列表查出范围返回了 <code>null</code>，而不是描述的异常，因此也不满足 LSP。</p><h3 id="4-3-例三"><a href="#4-3-例三" class="headerlink" title="4.3 例三"></a>4.3 例三</h3><p>鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期：</p><p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q11311094H32.gif" alt></p><p>几维鸟类重写了鸟类的 <code>setSpeed(double speed)</code> 方法，这违背了 LSP，更好的做法是取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0：</p><p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q11311101SN.gif" alt></p><h2 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5. 最佳实践"></a>5. 最佳实践</h2><ol><li>基于行为设计。比如正方形和长方形计算面积，正方形也是一种长方形，但是面积的计算方式不一致。</li><li>基于接口设计。这个接口包括<strong>接口签名、功能描述、参数类型、返回值、异常</strong>，在派生时要时刻保持与接口一致。</li><li>子类实现<strong>抽象方法</strong>，但是尽量不要覆盖父类的<strong>非抽象方法</strong>。</li><li>如果需要覆盖父类的非抽象方法，入参需要比父类宽松，出参要比父类严格。</li></ol><h2 id="6-系统优化"><a href="#6-系统优化" class="headerlink" title="6. 系统优化"></a>6. 系统优化</h2><p><em>讨论</em>。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快捷键记录</title>
      <link href="/resource/2021-12-06-shortcut-record/"/>
      <url>/resource/2021-12-06-shortcut-record/</url>
      
        <content type="html"><![CDATA[<h2 id="Iterm2-相关"><a href="#Iterm2-相关" class="headerlink" title="Iterm2 相关"></a>Iterm2 相关</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul><li>⌃ + a 移动到行首 （ahead）</li><li>⌃ + e 移动到行末 （end）</li><li>⌃ + f 光标向后移动一个字符（after）</li><li>^ + b 光标向前移动一个字符（before）</li></ul><h3 id="文字删除"><a href="#文字删除" class="headerlink" title="文字删除"></a>文字删除</h3><ul><li>^ + k 删除光标后面所有字符（有剪切功能）</li><li>^ + u 删除整行字符(有剪切功能)</li><li>^ + w 向前删除一个单词</li><li>^ + q 删除整行字符</li><li>^ + y （粘贴）</li><li>^ + h 删除光标之前的字符</li></ul><h2 id="IDEA-相关"><a href="#IDEA-相关" class="headerlink" title="IDEA 相关"></a>IDEA 相关</h2><ul><li>^ + tab switch 框</li></ul>]]></content>
      
      
      <categories>
          
          <category> resource </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux CPU 性能优化2</title>
      <link href="/technology/2020-05-01-linux-optimize2/"/>
      <url>/technology/2020-05-01-linux-optimize2/</url>
      
        <content type="html"><![CDATA[<h2 id="new-blog-test"><a href="#new-blog-test" class="headerlink" title="new blog test"></a>new blog test</h2><p>new blog test</p><p>remove meta information</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux CPU 性能优化</title>
      <link href="/technology/2020-04-16-linux-optimize1/"/>
      <url>/technology/2020-04-16-linux-optimize1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是平均负载"><a href="#1-什么是平均负载" class="headerlink" title="1. 什么是平均负载"></a>1. 什么是平均负载</h2><p><code>uptime</code> 指令显示内容如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">02</span>:<span class="number">00</span> up <span class="number">17</span> days, <span class="number">10</span>:<span class="number">57</span>,  <span class="number">1</span> user,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span></span><br></pre></td></tr></table></figure><p>前面：当前时间、系统运行时间、正在运行用户数。后面分别 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。</p><p>平均负载是什么？是 CPU 的使用率吗？明显不对，<strong>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系</strong>。</p><blockquote><p>可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</p><p>不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</p><p><strong>平均负载</strong>不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。只有当 CPU 密集或大量等待 CPU 的时候导致平均负载升高时，平均负载和 CPU 使用率的情况可以对应，在 IO 密集型中平均负载上升而 CPU 使用率不一定高。</p></blockquote><p>既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。</p><p>如何知道 CPU 数呢？通过 <code>grep &#39;model name&#39; /proc/cpuinfo | wc -l</code> 有几行就是几个 CPU 。</p><h2 id="2-平均负载高的不同情况"><a href="#2-平均负载高的不同情况" class="headerlink" title="2. 平均负载高的不同情况"></a>2. 平均负载高的不同情况</h2><h3 id="2-1-CPU-密集型进程"><a href="#2-1-CPU-密集型进程" class="headerlink" title="2.1. CPU 密集型进程"></a>2.1. CPU 密集型进程</h3><ol><li>先用 <code>stress --cpu 1 --timeout 600</code> 模拟一个 CPU 使用率 100% 的场景。</li><li>在第二个终端中用 <code>watch -d uptime</code> 查看平均负载的变化情况，其中 <code>-d</code> 表示高亮变化部分。</li><li>在第三个终端中用 <code>mpstat -P ALL 5</code> 查看 CPU 使用率的变化情况，其中 <code>-P ALL</code> 表示监控所有 CPU，可以发现一个 CPU 的负载会达到 100%。<ul><li>1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。</li></ul></li><li>通过 <code>pidstat -u 5 1</code> 可以查看具体进程情况，其中 <code>-u 5 1</code> 表示每 5 秒输出一次。<ul><li>从这里可以明显看到，stress 进程的 CPU 使用率为 100%。</li></ul></li></ol><h3 id="2-2-IO-密集型进程"><a href="#2-2-IO-密集型进程" class="headerlink" title="2.2 IO 密集型进程"></a>2.2 IO 密集型进程</h3><ol><li>使用 <code>stress -i 1 --timeout 600</code> 模拟 IO 压力。</li><li>同理第二个终端用 <code>watch -d uptime</code> 查看平均负载。</li><li>依然用 <code>mpstat -P ALL 5 1</code> 可以发现 CPU 的使用率情况。<ul><li>从这里可以看到，1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。</li></ul></li><li>最后也是通过 <code>pidstat -u 5 1</code> 找到相应的 pid。</li></ol><h3 id="2-3-大量进程的场景"><a href="#2-3-大量进程的场景" class="headerlink" title="2.3 大量进程的场景"></a>2.3 大量进程的场景</h3><ol><li>使用 <code>stress -c 8 --timeout 600</code> 模拟 8 个进程，阿里云上只有一个 CPU，显然会出现负载过高。</li><li>同理用 <code>watch -d uptime</code> 查看平均负载。<ul><li>由于系统只有 1 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 8 或 9；</li></ul></li><li>通过 <code>pidstat -u 5 1</code> 发现有 8 个 stress 进程占用了 CPU。<ul><li>可以看出，8 个进程在争抢 1 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</li></ul></li></ol><h2 id="3-CPU-上下文切换"><a href="#3-CPU-上下文切换" class="headerlink" title="3. CPU 上下文切换"></a>3. CPU 上下文切换</h2><h3 id="3-1-CPU-上下文切换的三个种类"><a href="#3-1-CPU-上下文切换的三个种类" class="headerlink" title="3.1 CPU 上下文切换的三个种类"></a>3.1 CPU 上下文切换的三个种类</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200611001221.png" alt></p><p>如上为 CPU 上下文的抽象图，根据任务的执行形式的不同，CPU 的下上文切换有：进程上下文切换、线程上下文切换、中断上下文切换这三类。</p><p>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用（特权模式切换）过程中一直是同一个进程在运行，属于同进程内的 CPU 上下文切换。</p><p>进程的切换只能发生在内核态，进程的上下文切换需要比系统调用多做一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p>频繁的进程上下文切换会出现性能隐患，可能出现切换的场景：</p><ol><li>时间片耗尽，当前进程必须挂起；</li><li>资源不足的，在获取到足够资源之前进程挂起；</li><li>进程 sleep 挂起进程；</li><li>高优先级进程导致当前进度挂起；</li><li>硬件中断，导致当前进程挂起；</li></ol><p>进程有上下文切换，线程也有，<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。线程的上下文切换有两种情况：</p><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样；</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，只需要切换线程间不共享的数据。</li></ol><p>除了前面两种上下文切换，还有一个场景也会切换 CPU 上下文，那就是中断。</p><p>快速响应硬件的事件，中断处理会打断进程的正常调度和执行。同一 CPU 内，硬件中断优先级高于进程。切换过程类似于系统调用的时候，不涉及到用户运行态资源。大量的中断上下文切换同样可能引发性能问题。</p><h3 id="3-2-CPU-上下文切换实验"><a href="#3-2-CPU-上下文切换实验" class="headerlink" title="3.2 CPU 上下文切换实验"></a>3.2 CPU 上下文切换实验</h3><p>vmstat 是一个常用的系统性能分析工具，用来分析系统的内存使用情况，也可以分析 CPU 上下文切换和中断的次数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># vmstat 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> <span class="number">6</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128740</span> <span class="number">140324</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">12</span>     <span class="number">6</span>   <span class="number">15</span>   <span class="number">16</span>  <span class="number">1</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128740</span> <span class="number">140332</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">2</span>  <span class="number">309</span>  <span class="number">879</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128740</span> <span class="number">140332</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>  <span class="number">294</span>  <span class="number">859</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128740</span> <span class="number">140332</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>  <span class="number">295</span>  <span class="number">861</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128244</span> <span class="number">140332</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>  <span class="number">323</span>  <span class="number">912</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">128196</span> <span class="number">140336</span> <span class="number">1337544</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">114</span>  <span class="number">297</span>  <span class="number">866</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>cs（context switch）是每秒上下文切换的次数。</li><li>in（interrupt）则是每秒中断的次数。</li><li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</li><li>b（Blocked）则是处于不可中断睡眠状态的进程数。</li></ul><p><code>vmstat</code> 只能看到总体的情况，每个进程的详细情况需要使用 <code>pidstat -w</code> 。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># pidstat -w 5 1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span>-<span class="number">514.26</span>.<span class="number">2</span>.el7.x86_64 (koonchen) <span class="number">06</span>/<span class="number">18</span>/<span class="number">2020</span> _x86_64_(<span class="number">1</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">20</span> AM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>         <span class="number">3</span>      <span class="number">0.40</span>      <span class="number">0.00</span>  ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>         <span class="number">6</span>      <span class="number">0.20</span>      <span class="number">0.00</span>  kworker/u2:<span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>         <span class="number">9</span>     <span class="number">12.45</span>      <span class="number">0.00</span>  rcu_sched</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>        <span class="number">10</span>      <span class="number">0.20</span>      <span class="number">0.00</span>  watchdog/<span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>       <span class="number">745</span>      <span class="number">0.40</span>      <span class="number">0.00</span>  aliyun-service</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>       <span class="number">956</span>     <span class="number">10.04</span>      <span class="number">0.00</span>  AliYunDun</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>      <span class="number">1672</span>      <span class="number">8.43</span>      <span class="number">0.00</span>  kworker/<span class="number">0</span>:<span class="number">2</span></span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>      <span class="number">1673</span>      <span class="number">0.20</span>      <span class="number">0.00</span>  sshd</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>      <span class="number">1700</span>      <span class="number">0.20</span>      <span class="number">0.00</span>  pidstat</span><br><span class="line"><span class="number">01</span>:<span class="number">44</span>:<span class="number">25</span> AM     <span class="number">0</span>      <span class="number">9668</span>     <span class="number">10.04</span>      <span class="number">0.00</span>  AliSecGuard</span><br></pre></td></tr></table></figure><ul><li>cswch 每秒自愿上下文切换（voluntary context switches）的次数；<ul><li>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。</li><li>比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。</li></ul></li><li>nvcswch 每秒非自愿上下文切换（non voluntary context switches）的次数。<ul><li>进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。</li><li>比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。</li></ul></li></ul><p>sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。</p><ol><li>第一个终端使用 <code>sysbench --threads=10 --max-time=300 threads run</code> 表示以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题。</li><li>第二个终端使用 <code>vmstat 1</code> 表示每隔 1 秒输出 1 组数据。<ul><li>cs（上下文切换的次数）的数值达到了 160 万左右。</li><li>r（就绪队列的长度）的数值达到了 8 左右，超过了 CPU 的个数 1 。</li><li>us 表示用户态，sy 表示内核态，可以看到 us 在 10% 左右，sy 在 90% 左右。</li><li>in（每秒中断的次数）的数值在 1300 左右，说明中断处理是一个潜在的问题。</li><li>综上，系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。</li></ul></li><li>第三个终端使用 <code>pidstat -w -u 1</code> ，<code>-w</code> 参数表示输出进程切换指标，而 <code>-u</code> 参数则表示输出 CPU 使用指标。<ul><li>可以发现占用 CPU 最高的是 <code>sysbench</code> 。</li><li>但是在这里自愿与非自愿的上下文切换加起来也远远达不到 <code>vmstat</code> 中 160 万的数值，这是因为 Linux 的调度基本单位是线程， <code>sysbench</code> 模拟的也是线程调度，所以在 <code>pidstat</code> 中加上 <code>-t</code> 参数才会显示线程指标。</li></ul></li><li>剩下的是中断问题，为什么中断达到了 1300 左右，在 <code>/proc/interrupts</code> 文件汇总可以读取，它提供了中断的使用情况，通过 <code>watch -d cat /proc/interrupts</code> 查看。<ul><li>在单核下没有 CPU 切换的展示，事实上这里应该转变最快的是 RES（重调度中断），它表示唤醒空闲状态的 CPU 来调度新的任务运行。</li></ul></li></ol><blockquote><p><code>stress</code> 基于多进程的，会 fork 多个进程，导致进程上下文切换，导致 us 开销很高；</p><p><code>sysbench</code> 基于多线程的，会创建多个线程，单一进程基于内核线程切换，导致 sy 的内核开销很高；</p><p>首先通过 <code>uptime</code> 查看系统负载，然后使用 <code>mpstat</code> 结合 <code>pidstat</code> 来初步判断到底是 CPU 计算量大还是进程争抢过大或者是 io 过多，接着使用 <code>vmstat</code> 分析切换次数，以及切换类型，来进一步判断到底是 io 过多导致问题还是进程争抢激烈导致问题。</p></blockquote><h2 id="4-应用-CPU-利用率-100-怎么办？"><a href="#4-应用-CPU-利用率-100-怎么办？" class="headerlink" title="4. 应用 CPU 利用率 100% 怎么办？"></a>4. 应用 CPU 利用率 100% 怎么办？</h2><h3 id="4-1-什么是-CPU-使用率？"><a href="#4-1-什么是-CPU-使用率？" class="headerlink" title="4.1 什么是 CPU 使用率？"></a>4.1 什么是 CPU 使用率？</h3><p>Linux 事先定义了节拍率 HZ 每当触发一次时间中断，全局变量 Jiffies 就会加 1。这个值在 <code>/boot/config</code> 中被定义。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># grep 'CONFIG_HZ=' /boot/config-3.10.0-1127.10.1.el7.x86_64</span></span><br><span class="line">CONFIG_HZ=<span class="number">1000</span></span><br></pre></td></tr></table></figure><p>这里的 1000 表示每秒钟触发 1000 次时间中断，节拍率是内核选项，用户空间节拍率是 USER_HZ，它总是 100，Linux 通过 <code>/proc</code> 文件向用户提供系统内部的信息，在 <code>/proc/stat</code> 提供系统的 CPU 和任务统计信息。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># cat /proc/stat | grep ^cpu</span></span><br><span class="line">cpu  <span class="number">2070722</span> <span class="number">339</span> <span class="number">978764</span> <span class="number">233911909</span> <span class="number">69735</span> <span class="number">0</span> <span class="number">11212</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu0 <span class="number">2070722</span> <span class="number">339</span> <span class="number">978764</span> <span class="number">233911909</span> <span class="number">69735</span> <span class="number">0</span> <span class="number">11212</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里的第一行是之后每一行的累加结果，具体含义：</p><ul><li>user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</li><li>nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</li><li>system（通常缩写为 sys），代表内核态 CPU 时间。</li><li>idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。</li><li>iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。</li><li>irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li><li>softirq（通常缩写为 si），代表处理软中断的 CPU 时间。</li><li>steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li><li>guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</li><li>guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</li></ul><script type="math/tex; mode=display">平均CPU使用率=1-\frac{\text {空闲时间}_{n e w}-\text { 空闲时间 }_{\text {old }}}{ \text { 总CPU时间 }\left._{n e w}-\text {总CPU时间}\right._{\text {old}}}</script><blockquote><p>重点在于时间间隔，比如 <code>top</code> 里的时间间隔是 3s 的，而 <code>ps</code> 则是进程的整个生命周期。</p></blockquote><p><code>top</code> 对于每个进程没有细分用户态和内核态的 CPU 使用率，可以通过 <code>pidstat</code> 查看每个进程的 CPU 使用详情，包括：</p><ul><li>用户态 CPU 使用率 （%usr）；</li><li>内核态 CPU 使用率（%system）；</li><li>运行虚拟机 CPU 使用率（%guest）；</li><li>等待 CPU 使用率（%wait）；</li><li>以及总的 CPU 使用率（%CPU）。</li></ul><h3 id="4-2-CPU-使用率过高怎么办？"><a href="#4-2-CPU-使用率过高怎么办？" class="headerlink" title="4.2 CPU 使用率过高怎么办？"></a>4.2 CPU 使用率过高怎么办？</h3><p>通过 <code>top</code> <code>ps</code> <code>pidstat</code> 等工具可以找到 CPU 高的进程，但是是哪个函数呢？首先能想到的是 GDB（The GNU Project Debugger），但是它不适合在性能分析的早期使用，因为 GDB 会中断程序，在线上是不允许的，它适合在分析的后期，在线下调试函数内部的问题，这里推荐使用 <code>perf</code>，它是 Linux 2.6.31 后内置的性能分析工具。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># perf top</span></span><br><span class="line">Samples: <span class="number">2</span>K of event <span class="string">'cpu-clock'</span>, <span class="number">4000</span> Hz, Event count (approx.): <span class="number">310098968</span> lost: <span class="number">0</span>/<span class="number">0</span> drop: <span class="number">0</span>/<span class="number">0</span></span><br><span class="line">Overhead  Shared Object                           Symbol</span><br><span class="line">   <span class="number">9.09</span>%  [kernel]                                [k] finish_task_switch</span><br><span class="line">   <span class="number">7.96</span>%  [kernel]                                [k] _raw_spin_unlock_irqrestore</span><br><span class="line">   <span class="number">5.37</span>%  perf                                    [.] rb_next</span><br><span class="line">   <span class="number">5.15</span>%  perf                                    [.] __symbols__insert</span><br><span class="line">   <span class="number">3.99</span>%  [kernel]                                [k] run_timer_softirq</span><br><span class="line">   <span class="number">2.70</span>%  [kernel]                                [k] tick_nohz_idle_enter</span><br><span class="line">   <span class="number">1.92</span>%  [kernel]                                [k] __do_softirq</span><br><span class="line">   <span class="number">1.52</span>%  [kernel]                                [k] kallsyms_expand_symbol.constprop.<span class="number">1</span></span><br><span class="line">   <span class="number">1.47</span>%  perf                                    [.] rb_insert_color</span><br></pre></td></tr></table></figure><p>使用 <code>perf top</code> 的效果如上所示，显示占用 CPU 时钟最多的函数或指令，第一行分别是：采样数、事件类型、事件总量。这里是 2000 个采样，类型是 cpu-clock，事件总量是 310098968。</p><p>之后的 Overhead 表示该符号的性能事件在所有采样中的比例，用百分比来表示；Shared 是该函数或指令所在的动态共享对象；Object 是动态共享对象的类型，比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间；Symbol 是符号名，也就是函数名，当函数名未知时，用十六进制的地址来表示。</p><p>此外还能使用 <code>perf record</code> 和 <code>perf report</code> 进行保存数据、离线分析，输出的报告和 <code>perf top</code> 类似。</p><h3 id="4-3-案例分析"><a href="#4-3-案例分析" class="headerlink" title="4.3 案例分析"></a>4.3 案例分析</h3><p>在虚拟机（1 CPU 2 GB）上运行 Nginx + PHP 的 Web 服务，本地通过 apache bench 进行压力测试，使用并发 10 请求，共发送 100 个请求：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -c <span class="number">10</span> -n <span class="number">100</span> http://xxx:<span class="number">10000</span>/</span><br><span class="line">Requests per second:    <span class="number">11.68</span> [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">856.416</span> [ms] (mean)</span><br></pre></td></tr></table></figure><p>发现每秒平均只有 11.68 ，然后将请求总数提高到 10000，在第一个终端用 <code>top</code> 查看 CPU 的情况。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line"><span class="number">4731</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9372</span>   <span class="number">1692</span> R <span class="number">19.9</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">06.03</span> php-fpm</span><br><span class="line"><span class="number">4730</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9368</span>   <span class="number">1688</span> R <span class="number">19.6</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">06.14</span> php-fpm</span><br><span class="line"><span class="number">4732</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9364</span>   <span class="number">1684</span> R <span class="number">19.6</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">05.94</span> php-fpm</span><br><span class="line"><span class="number">4733</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9364</span>   <span class="number">1684</span> R <span class="number">19.6</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">05.94</span> php-fpm</span><br><span class="line"><span class="number">4734</span> bin       <span class="number">20</span>   <span class="number">0</span>  <span class="number">336684</span>   <span class="number">9364</span>   <span class="number">1684</span> R <span class="number">19.6</span>  <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">05.85</span> php-fpm</span><br><span class="line"> <span class="number">956</span> root      <span class="number">10</span> -<span class="number">10</span>  <span class="number">160856</span>  <span class="number">44608</span>   <span class="number">5880</span> S  <span class="number">0.7</span>  <span class="number">2.4</span> <span class="number">217</span>:<span class="number">43.96</span> AliYunDun</span><br></pre></td></tr></table></figure><p>可以发现用户空间的 php-fpm 使用了几乎 100% 的 CPU，然后通过 <code>perf</code> 查看函数。因为 PHP 与 Nginx 在 docker 内执行，如果直接通过 <code>perf top</code> 是看不到具体方法的，只能看到 16 进制的地址，需要通过 <code>perf record -g -p &lt;pid&gt;</code> 保存结果，然后 <code>docker cp perf.data xxx:/tmp</code> 拷贝，使用 <code>docker exec -i -t xxx bash</code> 进入容器，然后安装 <code>perf</code> 工具即 <code>apt-get update &amp;&amp; apt-get install -y linux-perf linux-tools procps</code>，最后使用 <code>perf report</code> 查看报告。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200619170506.png" alt></p><p>可以发现 sqrt 和 add_function 函数有问题，可以将源码拷出来使用 <code>docker cp phpfpm:/app .</code>。接着从源码发现，问题出在了 sqrt 函数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># grep sqrt -r app/</span></span><br><span class="line">app/index.php:  <span class="variable">$x</span> += sqrt(<span class="variable">$x</span>);</span><br><span class="line">[root@koonchen ~]<span class="comment"># grep add_function -r app/</span></span><br><span class="line">[root@koonchen ~]<span class="comment"># cat app/index.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">// test only.</span><br><span class="line"><span class="variable">$x</span> = <span class="number">0.0001</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt;= <span class="number">1000000</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">  <span class="variable">$x</span> += sqrt(<span class="variable">$x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo <span class="string">"It works!"</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>使用修复结果进行 ab 测试，每秒处理数从 11 变成 271：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -c <span class="number">10</span> -n <span class="number">10000</span> -k http://xxx:<span class="number">10000</span>/</span><br><span class="line">Requests per second:    <span class="number">271.09</span> [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">36.888</span> [ms] (mean)</span><br></pre></td></tr></table></figure><h2 id="5-找到-CPU-利用率高的应用"><a href="#5-找到-CPU-利用率高的应用" class="headerlink" title="5. 找到 CPU 利用率高的应用"></a>5. 找到 CPU 利用率高的应用</h2><p>当 CPU 使用率高的时候，我们不一定能找到相应的高 CPU 使用率进程，现在在虚拟机上启动一个 Nginx 和 PHP 然后通过本地访问 curl：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p <span class="number">10000</span>:<span class="number">80</span> -itd feisky/nginx:sp</span><br><span class="line">docker run --name phpfpm -itd --network container:nginx feisky/php-fpm:sp</span><br><span class="line"></span><br><span class="line">curl http://xxx:<span class="number">10000</span>/</span><br><span class="line">It works!</span><br></pre></td></tr></table></figure><p>通过 ab 进行并发 100 共 1000 的请求：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ab -c <span class="number">100</span> -n <span class="number">1000</span> http://xxx:<span class="number">10000</span>/</span><br><span class="line"></span><br><span class="line">Requests per second:    <span class="number">70.60</span> [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">1416.448</span> [ms] (mean)</span><br></pre></td></tr></table></figure><p>每秒请求数只有 70，接着就来处理这个问题了，现在把并发改成 5，时间为 10 分钟。现在去服务器，发现使用 <code>top</code> 以后 CPU 使用率为 80%，但是显示的进程占用都不高，然后用 <code>pidstat</code> 查看。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># pidstat 1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span>-<span class="number">514.26</span>.<span class="number">2</span>.el7.x86_64 (koonchen) <span class="number">06</span>/<span class="number">21</span>/<span class="number">2020</span> _x86_64_(<span class="number">1</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">35</span> PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">0</span>       <span class="number">956</span>    <span class="number">5.00</span>    <span class="number">2.00</span>    <span class="number">0.00</span>    <span class="number">7.00</span>     <span class="number">0</span>  AliYunDun</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM   <span class="number">101</span>      <span class="number">7560</span>    <span class="number">1.00</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">2.00</span>     <span class="number">0</span>  nginx</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12214</span>    <span class="number">0.00</span>    <span class="number">2.00</span>    <span class="number">0.00</span>    <span class="number">2.00</span>     <span class="number">0</span>  php-fpm</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12221</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">1.00</span>     <span class="number">0</span>  php-fpm</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12228</span>    <span class="number">1.00</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">2.00</span>     <span class="number">0</span>  php-fpm</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12238</span>    <span class="number">1.00</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">2.00</span>     <span class="number">0</span>  php-fpm</span><br><span class="line"><span class="number">01</span>:<span class="number">12</span>:<span class="number">36</span> PM     <span class="number">1</span>     <span class="number">12239</span>    <span class="number">0.00</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">1.00</span>     <span class="number">0</span>  php-fpm</span><br></pre></td></tr></table></figure><p>所有进程的 CPU 使用率也不高，回到 <code>top</code> 再看看是否有遗漏信息。发现 Nginx 和 PHP 进程都处于 Sleep 状态，而 Running 状态的是 stress 进程，随便找到一个查看一下 <code>pidstat -p 25858</code> 竟然不存在，用 <code>ps aux | grep 25858</code> 状态已经变成了 S+，已经暂停了，同时在 <code>top</code> 中这个进程不见了，可能是因为：</p><ol><li>进程不断崩溃重启；</li><li>进程是短时进程。</li></ol><p>如果想要找到这个 stress 进程是怎么被调用的，就需要找到父进程，可以使用 <code>pstree</code> 工具。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># pstree | grep stress</span></span><br><span class="line">        |            |-containerd-shim-+-php-fpm-+-<span class="number">2</span>*[php-fpm---sh---stress---stress]</span><br></pre></td></tr></table></figure><p>发现 stress 进程是被 PHP 调用的，将 PHP 源码拷贝到本地：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@koonchen ~]<span class="comment"># docker cp phpfpm:/app .</span></span><br><span class="line"></span><br><span class="line">[root@koonchen ~]<span class="comment"># grep stress -r app</span></span><br><span class="line">app/index.php:// fake I/O with stress (via write()/unlink()).</span><br><span class="line">app/index.php:<span class="variable">$result</span> = exec(<span class="string">"/usr/local/bin/stress -t 1 -d 1 2&gt;&amp;1"</span>, <span class="variable">$output</span>, <span class="variable">$status</span>);</span><br></pre></td></tr></table></figure><p>找到 index.php 源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// fake I/O with stress (via write()/unlink()).</span></span><br><span class="line">$result = exec(<span class="string">"/usr/local/bin/stress -t 1 -d 1 2&gt;&amp;1"</span>, $output, $status);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">"verbose"</span>]) &amp;&amp; $_GET[<span class="string">"verbose"</span>]==<span class="number">1</span> &amp;&amp; $status != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Server internal error: "</span>;</span><br><span class="line">  print_r($output);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"It works!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>原来这里每一个请求都会调用 <code>stress</code> 命令，模拟了 IO 压力，但是之前只看到 CPU 使用率升高，通过 verbose 参数但因日志：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl http://<span class="number">112.124</span>.<span class="number">14.155</span>:<span class="number">10000</span>\?verbose=<span class="number">1</span></span><br><span class="line">Server internal error: Array</span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; stress: info: [<span class="number">5727</span>] dispatching hogs: <span class="number">0</span> cpu, <span class="number">0</span> io, <span class="number">0</span> vm, <span class="number">1</span> hdd</span><br><span class="line">    [<span class="number">1</span>] =&gt; stress: FAIL: [<span class="number">5731</span>] (<span class="number">563</span>) mkstemp failed: Permission denied</span><br><span class="line">    [<span class="number">2</span>] =&gt; stress: FAIL: [<span class="number">5727</span>] (<span class="number">394</span>) &lt;-- worker <span class="number">5731</span> returned error <span class="number">1</span></span><br><span class="line">    [<span class="number">3</span>] =&gt; stress: WARN: [<span class="number">5727</span>] (<span class="number">396</span>) now reaping child worker processes</span><br><span class="line">    [<span class="number">4</span>] =&gt; stress: FAIL: [<span class="number">5727</span>] (<span class="number">400</span>) kill error: No such <span class="keyword">process</span></span><br><span class="line">    [<span class="number">5</span>] =&gt; stress: FAIL: [<span class="number">5727</span>] (<span class="number">451</span>) failed run completed <span class="keyword">in</span> <span class="number">0</span>s</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>因为 stress 命令没有成功，因为权限问题失败了，因此大量 stress 进程初始化失败，导致 CPU 升高。这些都仅仅是<strong>猜测</strong>，下一步是<strong>验证</strong>，通过 <code>perf record -g</code> 和 <code>perf report</code> 查看报告，注意因为在 docker 中运行的进程，需要将报告复制进容器查看，可以发现是 stress 中 random() 函数占用了大量的 CPU 时钟。</p><blockquote><p>像这类短时进程问题，可以用 <code>execsnoop</code> 工具，它可以直接找到 stress 进程的父进程 PID 以及命令行参数，之后会用到。</p></blockquote><h2 id="6-大量不可用中断进程与僵尸进程"><a href="#6-大量不可用中断进程与僵尸进程" class="headerlink" title="6. 大量不可用中断进程与僵尸进程"></a>6. 大量不可用中断进程与僵尸进程</h2><p>当 iowait 升高时进程很可能因为得不到硬件相应而处于不可中断状态，从 <code>ps</code> 或 <code>top</code> 都发现它们属于 D 状态，也就是 Uninterruptible Sleep 状态。</p><ul><li>R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</li><li>D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</li><li>Z 是 Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。<ul><li>一旦父进程没有处理子进程的终止，还一直保持运行状态，那么子进程就会一直处于僵尸状态。</li></ul></li><li>S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。</li><li>I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。<ul><li>前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。</li><li>要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。</li></ul></li><li>T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。<ul><li>向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；再向它发送 SIGCONT 信号，进程又会恢复运行。</li><li>而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。</li></ul></li><li>X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。</li></ul><h3 id="6-1-案例表现"><a href="#6-1-案例表现" class="headerlink" title="6.1 案例表现"></a>6.1 案例表现</h3><p>使用 <code>docker run --privileged --name=app -itd feisky/app:iowait</code> 可以运行一个不断产生僵尸进程的应用，通过 <code>ps aux | grep /app</code> 可以看到有一个 <code>Ss+</code> 和多个 <code>D+</code> 的应用。</p><blockquote><p><code>--privileged</code> 参数使容器拥有了访问任何其它设备的权限。</p></blockquote><ul><li>S 表示可中断睡眠状态；</li><li>D 表示不可中断睡眠状态；</li><li>s 表示这个进程是一个会话的领导进程；</li><li><ul><li>表示前台进程组。</li></ul></li></ul><p>使用 <code>top</code> 看到如下信息（这里直接用教程的例子了，用单核服务器会卡死）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br><span class="line">top - <span class="number">05</span>:<span class="number">56</span>:<span class="number">23</span> up <span class="number">17</span> days, <span class="number">16</span>:<span class="number">45</span>,  <span class="number">2</span> users,  load average: <span class="number">2.00</span>, <span class="number">1.68</span>, <span class="number">1.39</span></span><br><span class="line">Tasks: <span class="number">247</span> total,   <span class="number">1</span> running,  <span class="number">79</span> sleeping,   <span class="number">0</span> stopped, <span class="number">115</span> zombie</span><br><span class="line">%Cpu0  :  <span class="number">0.0</span> us,  <span class="number">0.7</span> sy,  <span class="number">0.0</span> ni, <span class="number">38.9</span> id, <span class="number">60.5</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">%Cpu1  :  <span class="number">0.0</span> us,  <span class="number">0.7</span> sy,  <span class="number">0.0</span> ni,  <span class="number">4.7</span> id, <span class="number">94.6</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> <span class="number">4340</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">44676</span>   <span class="number">4048</span>   <span class="number">3432</span> R   <span class="number">0.3</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.05</span> top</span><br><span class="line"> <span class="number">4345</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">37280</span>  <span class="number">33624</span>    <span class="number">860</span> D   <span class="number">0.3</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.01</span> app</span><br><span class="line"> <span class="number">4344</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">37280</span>  <span class="number">33624</span>    <span class="number">860</span> D   <span class="number">0.3</span>  <span class="number">0.4</span>   <span class="number">0</span>:<span class="number">00.01</span> app</span><br><span class="line">    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">160072</span>   <span class="number">9416</span>   <span class="number">6752</span> S   <span class="number">0.0</span>  <span class="number">0.1</span>   <span class="number">0</span>:<span class="number">38.59</span> systemd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>平均负载正在逐渐升高，说明系统很可能已经有了性能瓶颈；</li><li>有 1 个正在运行的进程，但僵尸进程比较多，而且还在不停增加，说明有子进程在退出时没被清理；</li><li>用户 CPU 和系统 CPU 都不高，但 iowait 分别是 60.5% 和 94.6%；</li><li>每个进程的情况，CPU 使用率最高的进程只有 0.3%，看起来并不高；但有两个进程处于 D 状态，它们可能在等待 I/O，但光凭此并不能确定是它们导致了 iowait 升高。</li></ul><p>通过这四个发现可以得到以下两个结论：</p><ol><li>iowait 太高了，导致系统的平均负载升高，甚至达到了系统 CPU 的个数；</li><li>僵尸进程在不断增多，说明有程序没能正确清理子进程的资源。</li></ol><h3 id="6-2-案例分析"><a href="#6-2-案例分析" class="headerlink" title="6.2 案例分析"></a>6.2 案例分析</h3><p>查询系统的 IO 情况可以使用 <code>dstat</code> 工具，它可以同时查看 CPU 和 IO 两种资源，使用 <code>dstat 1 10</code> 展示信息如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔1秒输出10组数据</span></span><br><span class="line">dstat <span class="number">1</span> <span class="number">10</span></span><br><span class="line">--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai stl| read  writ| recv  send|  <span class="keyword">in</span>   out | int   csw</span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>  <span class="number">96</span>   <span class="number">4</span>   <span class="number">0</span>|<span class="number">1219</span>k  <span class="number">408</span>k|   <span class="number">0</span>     <span class="number">0</span> |   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">42</span>   <span class="number">885</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">2</span>  <span class="number">98</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> | <span class="number">198</span>B  <span class="number">790</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">42</span>   <span class="number">138</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span> <span class="number">100</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">42</span>   <span class="number">135</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>  <span class="number">84</span>  <span class="number">16</span>   <span class="number">0</span>|<span class="number">5633</span>k    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">52</span>   <span class="number">177</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">3</span>  <span class="number">39</span>  <span class="number">58</span>   <span class="number">0</span>|  <span class="number">22</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">43</span>   <span class="number">144</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span> <span class="number">100</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> | <span class="number">200</span>B  <span class="number">450</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">46</span>   <span class="number">147</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">2</span>  <span class="number">98</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">45</span>   <span class="number">134</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span> <span class="number">100</span>   <span class="number">0</span>|  <span class="number">34</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">39</span>   <span class="number">131</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">0</span>  <span class="number">83</span>  <span class="number">17</span>   <span class="number">0</span>|<span class="number">5633</span>k    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">46</span>   <span class="number">168</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">3</span>  <span class="number">39</span>  <span class="number">59</span>   <span class="number">0</span>|  <span class="number">22</span>M    <span class="number">0</span> |  <span class="number">66</span>B  <span class="number">342</span>B|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">37</span>   <span class="number">134</span></span><br></pre></td></tr></table></figure><p>首先要处理 IO 高的问题，从上表发现，当 wai 升高即 iowait 上高时，read 请求会很大，可能是磁盘读导致的。通过 <code>top</code> 找到 D 状态的进程，可以找到其 PID，而查看一个进程的使用情况，就可以使用 <code>pidstat</code>，使用 <code>-d</code> 参数可以输出 IO 情况。但是可以发现 D 状态进程不一定存在问题，因此可以直接查看所有进程的 IO 情况。</p><p>这时可以发现 app 进程有大量的 kB_rd/s，表示每秒读的 KB 数，找到了进程后可以用 <code>strace -p [pid]</code> 来查看进程的追踪信息，然而追踪失败了，<strong>一般这种情况下，需要看看进程状态是否正常</strong>。</p><p>回到 <code>ps aux | grep [pid]</code> 发现其状态变成了 Z，就是说进程变成了僵尸进程，用 <code>perf record -g</code> 和 <code>perf report</code> 找到僵尸进程的调用栈，发现 app 应用中 IO 高是因为应用直接访问了磁盘，更改后的进程 iowait 会明显降低，但是僵尸进程的问题还是存在。</p><p>接下来僵尸进程的问题是因为父进程的调用错误，通过 <code>pstree -aps &lt;pid&gt;</code> 查看进程父子关系，<code>a</code> 表示输出命令行选项，<code>p</code> 表示 PID，<code>s</code> 表示指定进程的父进程，发现指向了 app 应用，查看其中调用 <code>wait()</code> 或 <code>waitpid()</code> 的地方，修复问题。</p><p>至此，iowait 高和大量僵尸进程的问题被处理。iowait 高不一定代表 I/O 有性能瓶颈。当系统中只有 I/O 类型的进程在运行时，iowait 也会很高，但实际上，磁盘的读写远没有达到性能瓶颈的程度。</p><ul><li>碰到 iowait 升高时，需要先用 dstat、pidstat 等工具，确认是不是磁盘 I/O 的问题，然后再找是哪些进程导致了 I/O。</li><li>等待 I/O 的进程一般是不可中断状态，所以用 ps 命令找到的 D 状态（即不可中断状态）的进程，多为可疑进程。</li><li>但这个案例中，在 I/O 操作后，进程又变成了僵尸进程，所以不能用 strace 直接分析这个进程的系统调用。</li><li>这种情况下，我们用了 perf 工具，来分析系统的 CPU 时钟事件，最终发现是直接 I/O 导致的问题。这时，再检查源码中对应位置的问题，就很轻松了。</li><li>而僵尸进程的问题相对容易排查，使用 pstree 找出父进程后，去查看父进程的代码，检查 wait() / waitpid() 的调用，或是 SIGCHLD 信号处理函数的注册就行了。</li></ul><h2 id="7-理解-Linux-中断"><a href="#7-理解-Linux-中断" class="headerlink" title="7. 理解 Linux 中断"></a>7. 理解 Linux 中断</h2><p><strong>进程的不可中断状态是系统的一种保护机制，短时间的不可中断状态是正常的</strong>。除了 iowait，软中断 softirq 使得 CPU 使用率升高也是一种常见的性能问题。</p><p><strong>中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力</strong>。由于中断处理程序会打断其他进程的运行，所以，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。如果有两个中断一前一后，前一个中断时间长，后一个中断时间短，可能会造成第二个中断处理丢失的情况。</p><p>为此，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：</p><ul><li>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。</li><li>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。</li></ul><p>可以通过 <code>/proc/softirqs</code> 查看软中断，通过 <code>/proc/interrupts</code> 查看硬中断。</p><p>软中断的下半部分是内核线程的形式运行的，因此可以通过 <code>ps aux | grep softirq</code> 查看它们的运行状况。</p><blockquote><p>ps 的输出中，名字在中括号里的，一般都是内核线程，无法获取它们的命令行参数。</p></blockquote><h2 id="8-软中断-CPU-使用率上升处理"><a href="#8-软中断-CPU-使用率上升处理" class="headerlink" title="8. 软中断 CPU 使用率上升处理"></a>8. 软中断 CPU 使用率上升处理</h2><p>案例需要用到三个新的工具：</p><ul><li>sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。</li><li>hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。</li><li>tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。</li></ul><p>操作流程如下：</p><ol><li>首先在云服务器上运行一个 Nginx 使用 <code>docker run -itd --name=nginx -p 80:80 nginx</code>，如果下载速度慢可以在 <code>/etc/docker</code> 下设置换源。</li><li>启动后在本地使用 <code>curl</code> 查看是否可以访问，然后本地通过 <code>hping</code> 进行请求：<code>hping3 -S -p 80 -i u100 xxx</code>，其中 <code>-S</code> 表示 TCP 协议的 SYN 同步序列号，<code>-i u100</code> 表示每隔 100 ms 发送一个网络帧。<ul><li>这是通过 hping3 模拟 SYN FLOOD 攻击。</li></ul></li><li>此时云服务器会有卡顿现象出现，通过 <code>top</code> 发现平均负载很低，CPU 使用率也很低，并且来自 ksoftirqd 的进程。</li><li>通过 <code>watch -d cat /proc/softirqs</code> 监控软负载，发现 TIMER、NET_RX、SCHED、RCU 都在不停变化，只有 NET_RX 变化最快，其他都是 Linux 必须的调度。</li><li>通过 <code>sar -n DEV 1</code> 查看系统的网络收发以及每秒的情况，，<code>-n DEV</code> 表示显示网络收发的报告。<ul><li>第一列：表示报告的时间。</li><li>第二列：IFACE 表示网卡。</li><li>第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS。</li><li>第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS。</li></ul></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sar -n DEV <span class="number">1</span></span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">46</span>        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">47</span>         eth0  <span class="number">12607.00</span>   <span class="number">6304.00</span>    <span class="number">664.86</span>    <span class="number">358.11</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.01</span></span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">47</span>      docker0   <span class="number">6302.00</span>  <span class="number">12604.00</span>    <span class="number">270.79</span>    <span class="number">664.66</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">47</span>           lo      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">15</span>:<span class="number">03</span>:<span class="number">47</span>    veth9f6bbcd   <span class="number">6302.00</span>  <span class="number">12604.00</span>    <span class="number">356.95</span>    <span class="number">664.66</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.05</span></span><br></pre></td></tr></table></figure><ol><li>在 eth0 中接收的 PPS 比较大，达到 12607，而接收的 BPS 却很小，只有 664 KB。<ul><li>664*1024/12607 = 54 字节，说明平均每个网络帧只有 54 字节，这显然是很小的网络帧，也就是我们通常所说的小包问题。</li></ul></li><li>通过 <code>tcpdump -i eth0 -n tcp port 80</code> 可以抓包，<code>-i eth0</code> 只抓取 eth0 网卡，<code>-n</code> 不解析协议名和主机名，<code>tcp port 80</code> 表示只抓取 tcp 协议并且端口号为 80 的网络帧。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i eth0 -n tcp port <span class="number">80</span></span><br><span class="line"><span class="number">15</span>:<span class="number">11</span>:<span class="number">32.678966</span> IP <span class="number">192.168</span>.<span class="number">0.2</span>.<span class="number">18238</span> &gt; <span class="number">192.168</span>.<span class="number">0.30</span>.<span class="number">80</span>: Flags [S], seq <span class="number">458303614</span>, win <span class="number">512</span>, length <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li><code>Flags [S]</code> 则表示这是一个 SYN 包，现在可以确定这是从哪儿来的 SYN FLOOD 攻击。</li></ol><h2 id="9-分析-CPU-瓶颈"><a href="#9-分析-CPU-瓶颈" class="headerlink" title="9. 分析 CPU 瓶颈"></a>9. 分析 CPU 瓶颈</h2><p>CPU 的性能指标那么多，在实际场景中应该观察什么信息，使用什么工具？</p><h3 id="9-1-CPU-性能指标"><a href="#9-1-CPU-性能指标" class="headerlink" title="9.1 CPU 性能指标"></a>9.1 CPU 性能指标</h3><p><strong>首先应该想到的是 CPU 使用率</strong>，具体包括用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。</p><ul><li>用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态 CPU 使用率（nice），表示 CPU 在用户态运行的时间百分比。用户 CPU 使用率高，通常说明有应用程序比较繁忙。</li><li>系统 CPU 使用率，表示 CPU 在内核态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明内核比较繁忙。</li><li>等待 I/O 的 CPU 使用率，通常也称为 iowait，表示等待 I/O 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。</li><li>软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。</li><li>除了上面这些，还有在虚拟化环境中会用到的窃取 CPU 使用率（steal）和客户 CPU 使用率（guest），分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。</li></ul><p><strong>其次应该想到是平均负载</strong>，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。</p><ul><li>理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了。</li></ul><p><strong>接着是进程上下文切换</strong>，包括了无法获取资源而导致的自愿上下文切换和被系统强制调度导致的非自愿上下文切换。</p><ul><li>过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成为性能瓶颈。</li></ul><p><strong>还有一个指标是 CPU 缓存命中率</strong>，CPU 在访问内存的时候，免不了要等待内存的响应。为了协调这两者巨大的性能差距，CPU 缓存（通常是多级缓存）就出现了。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200626174959.png" alt></p><ul><li>CPU 缓存的速度介于 CPU 和内存之间，缓存的是热点的内存数据。</li><li>缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常用在单核中， L3 则用在多核中。</li><li>从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次降低（当然比内存还是好得多）。</li><li>它们的命中率，衡量的是 CPU 缓存的复用情况，命中率越高，则表示性能越好。</li></ul><h3 id="9-2-案例汇总"><a href="#9-2-案例汇总" class="headerlink" title="9.2 案例汇总"></a>9.2 案例汇总</h3><ul><li>首先，平均负载的案例。<ul><li>我们先用 uptime， 查看了系统的平均负载；</li><li>而在平均负载升高后，又用 <code>mpstat</code> 和 <code>pidstat</code> ，分别观察了每个 CPU 和每个进程 CPU 的使用情况，进而找出了导致平均负载升高的进程，也就是我们的压测工具 stress。</li></ul></li><li>第二个，上下文切换的案例。<ul><li>我们先用 <code>vmstat</code> ，查看了系统的上下文切换次数和中断次数；</li><li>然后通过 <code>pidstat</code> ，观察了进程的自愿上下文切换和非自愿上下文切换情况；</li><li>最后通过 <code>pidstat -t</code> ，观察了线程的上下文切换情况，找出了上下文切换次数增多的根源，也就是我们的基准测试工具 sysbench。</li></ul></li><li>第三个，进程 CPU 使用率升高的案例。<ul><li>我们先用 <code>top</code> ，查看了系统和进程的 CPU 使用情况，发现 CPU 使用率升高的进程是 php-fpm；</li><li>再用 <code>perf top</code> ，观察 php-fpm 的调用链，最终找出 CPU 升高的根源，也就是库函数 sqrt() 。</li></ul></li><li>第四个，系统的 CPU 使用率升高的案例。<ul><li>我们先用 <code>top</code> 观察到了系统 CPU 升高，但通过 <code>top</code> 和 <code>pidstat</code> ，却找不出高 CPU 使用率的进程；</li><li>于是，我们重新审视 <code>top</code> 的输出，又从 CPU 使用率不高但处于 Running 状态的进程入手，找出了可疑之处；</li><li>最终通过 <code>perf record</code> 和 <code>perf report</code> ，发现原来是短时进程在捣鬼。</li><li>另外，对于短时进程，还介绍了一个专门的工具 <code>execsnoop</code> ，它可以实时监控进程调用的外部命令。</li></ul></li><li>第五个，不可中断进程和僵尸进程的案例。<ul><li>我们先用 <code>top</code> 观察到了 iowait 升高的问题，并发现了大量的不可中断进程和僵尸进程；</li><li>接着我们用 <code>dstat</code> 发现是这是由磁盘读导致的；</li><li>于是又通过 <code>pidstat</code> 找出了相关的进程；</li><li>但我们用 <code>strace</code> 查看进程系统调用却失败了；</li><li>最终还是用 <code>perf</code> 分析进程调用链，才发现根源在于磁盘直接 I/O 。</li></ul></li><li>最后一个，软中断的案例。<ul><li>我们通过 <code>top</code> 观察到，系统的软中断 CPU 使用率升高；</li><li>接着查看 <code>/proc/softirqs</code>， 找到了几种变化速率较快的软中断；</li><li>然后通过 <code>sar</code> 命令，发现是网络小包的问题；</li><li>最后再用 <code>tcpdump</code> ，找出网络帧的类型和来源，确定是一个 SYN FLOOD 攻击导致的。</li></ul></li></ul><h3 id="9-3-从性能指标出发"><a href="#9-3-从性能指标出发" class="headerlink" title="9.3 从性能指标出发"></a>9.3 从性能指标出发</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200626175430.png" alt></p><h3 id="9-4-从工具出发"><a href="#9-4-从工具出发" class="headerlink" title="9.4 从工具出发"></a>9.4 从工具出发</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200626175522.png" alt></p><h3 id="9-5-工具的联动"><a href="#9-5-工具的联动" class="headerlink" title="9.5 工具的联动"></a>9.5 工具的联动</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200626175859.png" alt></p><h2 id="10-CPU-性能优化"><a href="#10-CPU-性能优化" class="headerlink" title="10. CPU 性能优化"></a>10. CPU 性能优化</h2><h3 id="10-1-性能优化方法论"><a href="#10-1-性能优化方法论" class="headerlink" title="10.1 性能优化方法论"></a>10.1 性能优化方法论</h3><p>在进行性能优化时应该想想三个问题：</p><ol><li>首先，既然要做性能优化，那要怎么判断它是不是有效呢？特别是优化后，到底能提升多少性能呢？</li><li>第二，性能问题通常不是独立的，如果有多个性能问题同时发生，你应该先优化哪一个呢？</li><li>第三，提升性能的方法并不是唯一的，当有多种方法可以选择时，你会选用哪一种呢？是不是总选那个最大程度提升性能的方法就行了呢？</li></ol><p>比如我们发现是因为一个进程的直接 I/O ，导致了 iowait 高达 90%。那是不是用“直接 I/O 换成缓存 I/O”的方法，就可以立即优化了呢？</p><ol><li>第一个问题，直接 I/O 换成缓存 I/O，可以把 iowait 从 90% 降到接近 0，性能提升很明显。</li><li>第二个问题，我们没有发现其他性能问题，直接 I/O 是唯一的性能瓶颈，所以不用挑选优化对象。</li><li>第三个问题，缓存 I/O 是我们目前用到的最简单的优化方法，而且这样优化并不会影响应用的功能。</li></ol><h3 id="10-2-性能优化评估"><a href="#10-2-性能优化评估" class="headerlink" title="10.2 性能优化评估"></a>10.2 性能优化评估</h3><p>怎么评估性能优化的效果：</p><ol><li>确定性能的量化指标。</li><li>测试优化前的性能指标。</li><li>测试优化后的性能指标。</li></ol><p>不要局限在单一维度的指标上，你至少要从应用程序和系统资源这两个维度，分别选择不同的指标。比如，以 Web 应用为例：</p><ol><li>应用程序的维度，我们可以用<strong>吞吐量</strong>和<strong>请求延迟</strong>来评估应用程序的性能。</li><li>系统资源的维度，我们可以用 <strong>CPU 使用率</strong>来评估系统的 CPU 使用情况。</li></ol><h3 id="10-3-多个性能问题"><a href="#10-3-多个性能问题" class="headerlink" title="10.3 多个性能问题"></a>10.3 多个性能问题</h3><p><strong>80% 的问题都是由 20% 的代码导致的。</strong></p><ul><li>第一，如果发现是系统资源达到了瓶颈，比如 CPU 使用率达到了 100%，那么首先优化的一定是系统资源使用问题。完成系统资源瓶颈的优化后，我们才要考虑其他问题。</li><li>第二，针对不同类型的指标，首先去优化那些由瓶颈导致的，性能指标变化幅度最大的问题。比如产生瓶颈后，用户 CPU 使用率升高了 10%，而系统 CPU 使用率却升高了 50%，这个时候就应该首先优化系统 CPU 的使用。</li></ul><h3 id="10-4-多种优化方式"><a href="#10-4-多种优化方式" class="headerlink" title="10.4 多种优化方式"></a>10.4 多种优化方式</h3><p><strong>性能优化并非没有成本。</strong>性能优化通常会带来复杂度的提升，降低程序的可维护性，还可能在优化一个指标时，引发其他指标的异常。</p><p>综合多方面的因素。切记，不要想着“一步登天”，试图一次性解决所有问题；也不要只会“拿来主义”，把其他应用的优化方法原封不动拿来用，却不经过任何思考和分析。</p><h3 id="10-5-CPU-优化"><a href="#10-5-CPU-优化" class="headerlink" title="10.5 CPU 优化"></a>10.5 CPU 优化</h3><p>程序优化：</p><ul><li>编译器优化：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如， gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化。</li><li>算法优化：使用复杂度更低的算法，可以显著加快处理速度。比如，在数据比较大的情况下，可以用 O(nlogn) 的排序算法（如快排、归并排序等），代替 O(n^2) 的排序算法（如冒泡、插入排序等）。</li><li>异步处理：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题。</li><li>多线程代替多进程：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。</li><li>善用缓存：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。</li></ul><p>系统优化：</p><ul><li>CPU 绑定：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题。</li><li>CPU 独占：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU。</li><li>优先级调整：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理。</li><li>为进程设置资源限制：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。</li><li>NUMA（Non-Uniform Memory Access）优化：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。</li><li>中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 探索</title>
      <link href="/technology/2020-04-15-elasticsearch-learn2/"/>
      <url>/technology/2020-04-15-elasticsearch-learn2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基于词项和基于全文的检索"><a href="#1-基于词项和基于全文的检索" class="headerlink" title="1. 基于词项和基于全文的检索"></a>1. 基于词项和基于全文的检索</h2><h3 id="1-1-基于-Term-查询"><a href="#1-1-基于-Term-查询" class="headerlink" title="1.1 基于 Term 查询"></a>1.1 基于 Term 查询</h3><ul><li>Term 是语义的最小单位，Term Level Query 包括了 Term Query / Range Query / Exists Query / Prefix Query /Wildcard Query 等。由 <code>query</code> 嵌套 <code>term</code> 组成。</li><li>在 es 中的 Term 不会对输入进行分词，而是将输入作为一个整体，在倒排索引中查找准确的词项，并且使⽤相关度算分公式，为每个包含该词项的⽂档进⾏相关度算分。</li><li>可以通过 Constant Score 将查询转换成一个 Filtering，避免算分，利用了缓存。</li><li>Term 查询不会做分词，如果希望完全匹配，应该用 <code>xxx.keyword</code> 字段来进行查询。</li><li><code>query</code> 内嵌套 <code>constant_score</code> 和 <code>filter</code> 可以将 Query 转换成 Fileter，忽略 TF-IDF 计算，避免算分性能开销。</li></ul><h3 id="1-2-全文查询"><a href="#1-2-全文查询" class="headerlink" title="1.2 全文查询"></a>1.2 全文查询</h3><ul><li>全文查询包括了 Match Query / Match Phrase Query / Query String Query 等。由 <code>query</code> 嵌套 <code>match</code> 组成。</li><li>索引和搜索对会进行分词，查询字符串会先传递到一个分词器，然后生成一个可以查询的词项列表。</li><li>查询时，会先对输入进行分词，然后逐个进行底层查询，最终合并结果，并为每个文档生成一个算分。</li><li>可以通过 <code>operator</code> 对分词关系进行控制，或者直接使用 <code>+</code> <code>-</code> 符号也一样。</li><li>可以通过 <code>minimum_should_match</code> 参数控制最小匹配，用 <code>~</code> 符号也一样。</li><li>可以通过 <code>match_phrase</code> 嵌套 <code>slop</code> 允许误差，设置范围。</li></ul><h2 id="2-结构化搜索"><a href="#2-结构化搜索" class="headerlink" title="2. 结构化搜索"></a>2. 结构化搜索</h2><ul><li>所谓结构化的数据指日期、布尔、数字，文本也可以是结构化的，比如颜色、标签、标识。</li><li>结构化数据即有精确的格式，可以逻辑操作，同时有范围课比较。</li><li>结构话数据可以 Term 查询或 Perfix 前缀查询。</li><li>结构化的结构只有是或否两个值。</li><li>在 <code>query</code> 中嵌套 <code>constant_score</code> 和 <code>filter</code> 和 <code>range</code> 可以进行范围查询。<code>gte</code> 是大于等于，<code>lte</code> 是小于等于。</li><li>在日期的查询中可以使用 <code>now-1y</code> 这样的语法，y 是年，M 是月，w 是周，d 是天，H/h 是小时，m 是分钟，s 是秒。</li><li>可以通过 <code>constant_score</code> 嵌套 <code>filter</code> 和 <code>exists</code> 来确定非空字段。</li><li>es 中的 Term 查询是包含而不是相等，需要增加一个 count 字段，通过 bool query 进行精确匹配。</li></ul><h2 id="3-搜索的相关性算分"><a href="#3-搜索的相关性算分" class="headerlink" title="3. 搜索的相关性算分"></a>3. 搜索的相关性算分</h2><ul><li>相关性是指一个文档和语句的匹配程度，es 5 前使用 TF-IDF，之后使用 BM25。</li><li>Term Frequency 检索词在文档中出现的词频。</li><li>最简单的方式是将各个词的 TF 相加，需要考虑一些 Stop Word 是否需要算进去。</li><li>Document Frequency 检索词在所有文档中出现的词频。</li><li>Inverse Document Frequency 是 log(全部文档数/检索词出现的文档数)。从 IDF 中可以知道一个词的重要性。</li><li>TF-IDF 算法本质上是 TF 求和变成加权求和。<ul><li>将各个词的 TF*IDF 相加求和。</li></ul></li><li>BM25 在 TF 无限增加时，TF-IDF 会不断增加分值，而 BM25 会趋向一个值。</li><li>在 lucene 中有 boosting 的概念，它也会影响打分，可以在 <code>query</code> 下嵌套 <code>boosting</code> 使用。<ul><li>当 boosting &gt; 1 时，打分的相关度提升</li><li>当 0 &lt; boosting &lt; 1 时，打分相关性下降</li><li>当 boosting &lt; 0 时，贡献为负</li></ul></li></ul><h2 id="4-Query-amp-Filtering-与多字符串多字段查询"><a href="#4-Query-amp-Filtering-与多字符串多字段查询" class="headerlink" title="4. Query &amp; Filtering 与多字符串多字段查询"></a>4. Query &amp; Filtering 与多字符串多字段查询</h2><ul><li>在 es 中有 Query 和 Filter 两种不同的上下文。<ul><li>Query 有相关性算分。</li><li>Filter 不需要算分。</li></ul></li><li>bool query 在 <code>query</code> 中嵌套 <code>bool</code> 使用，是一个或多个查询的组合。<ul><li>must 必须满足条件，算分。</li><li>should 选择性匹配，算分。</li><li>must_not 必须不能匹配，Filter Context 中不算分。</li><li>filter 必须匹配，Filter COntext 中不算分。</li><li><code>bool</code> 下可以嵌套 must should 等四种等级继续嵌套 <code>bool</code>，这样算分的等级就变了。</li><li>同样通过设置 <code>boost</code> 的值也能影响算分的权重。</li></ul></li><li>可以在 <code>query</code> 中嵌套 <code>boosting</code> 进行查询，可以指定 <code>positive</code> 项、<code>negative</code> 项，同时可以指定 <code>negative_boost</code> 的值，他们都是在影响 Query 的算分结果，最后得到的排名会有变化。</li></ul><h2 id="5-单字符串多字段查询-Dis-Max-Query"><a href="#5-单字符串多字段查询-Dis-Max-Query" class="headerlink" title="5. 单字符串多字段查询 Dis Max Query"></a>5. 单字符串多字段查询 Dis Max Query</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs/_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"Quick brown rabbits"</span>,</span><br><span class="line">    <span class="string">"body"</span>:  <span class="string">"Brown rabbits are commonly seen."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /blogs/_doc/<span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"Keeping pets healthy"</span>,</span><br><span class="line">    <span class="string">"body"</span>:  <span class="string">"My quick brown fox eats rabbits on a regular basis."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"should"</span>: [</span><br><span class="line">                &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"Brown fox"</span> &#125;&#125;,</span><br><span class="line">                &#123; <span class="string">"match"</span>: &#123; <span class="string">"body"</span>:  <span class="string">"Brown fox"</span> &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的例子中，我们希望第二个查询排在第一个之前，但是事实是第一个排在第二个之前。</p></blockquote><p><code>should</code> 的算分过程：</p><ul><li>查询 should 语句中的两个查询。</li><li>对查询评分求和，求和乘以匹配总数，最后除以所有语句数，得到一个平均值。</li></ul><p>上面的例子不应该是简单的相加，而是找到最匹配的字段，因此可以使用 Disjunction Max Query，它将查询文档中最高的内容评分作为最终评分。 </p><ul><li>在 <code>query</code> 下嵌套 <code>dis_max</code> 和 <code>queries</code> 组成 Disjunction Max Query。</li><li>单纯使用 Disjunction Max Query 可能结果总是相同的，因此可以使用 <code>tie_breaker</code> (最好在 0 ~ 1 之间)，它将其他匹配语句的评分与 tie_breaker 相乘，让分数不都相同。</li></ul><h2 id="6-单字符串多字段查询-Multi-Match"><a href="#6-单字符串多字段查询-Multi-Match" class="headerlink" title="6. 单字符串多字段查询 Multi Match"></a>6. 单字符串多字段查询 Multi Match</h2><p>单字符串多字段查询有三种场景：</p><ul><li>最佳字段 Best Fields<ul><li>当字段之间相互竞争，又相互关联时，评分来自最匹配的字段。</li></ul></li><li>多数字段 Most Fields<ul><li>在处理英文内容时，在主字段抽取词干，加入同义词，用以匹配更多的文档。对于相同的文本，加入子字段，以提供更加精确的匹配，其他字段则作为匹配文档提高相关度的信号，匹配字段越多越好。</li></ul></li><li>混合字段 Cross Fields<ul><li>对于某些实体，例如人名、地址、图书信息。需要在多个字段中确认信息，单个字段只能作为整体的一部分，希望在任何这些列出的字段中找到尽可能多的词。</li></ul></li></ul><p>Multi Match Query 在 <code>query</code> 下使用 <code>multi_match</code> 进行声明，其中要说明 <code>type</code> 类型，默认为 Best Fields，同时在 <code>fields</code> 中说明在哪些字段上，<code>tie_breaker</code> 也可以进行指定，而 <code>minimum_should_match</code> 用来说明最小匹配度，说明最小匹配多少个条件。</p><p>比如在使用英文分词器进行搜索时，可能两个句子中短的那条容易排在前面，可以通过增加一个字段，使用 standard 分词器，同时在搜索时使用 <code>multi_match</code> 的 <code>most_fields</code> 找内容，在 <code>fields</code> 中可以使用 <code>&quot;title^10&quot;,&quot;title.std&quot;</code> 来指定权重。</p><p>在使用 <code>operator</code> 为 <code>and</code> 的时候往往比较严格，如果用 copy to 处理会需要额外的存储空间，这个时候使用 <code>type</code> 为 <code>cross_fields</code> 就比较好了。</p><h2 id="7-多语言和中文分词与检索"><a href="#7-多语言和中文分词与检索" class="headerlink" title="7. 多语言和中文分词与检索"></a>7. 多语言和中文分词与检索</h2><ul><li>当处理语言时，可能搜索和原文不完全匹配，但是希望能够搜索。<ul><li>Quick brown fox 和 Fast brown fox / Jumping fox 和 Jumped foxes 。</li></ul></li><li>可用策略：<ul><li>归一化词元，清除变音符号。</li><li>抽取词根，清除单复数和时态。</li><li>包含同义词。</li><li>拼写错误，处理同音异形词。</li></ul></li></ul><h2 id="8-Space-Jam-全文搜索"><a href="#8-Space-Jam-全文搜索" class="headerlink" title="8. Space Jam 全文搜索"></a>8. Space Jam 全文搜索</h2><h2 id="9-Search-Template-和-Index-Alias-查询"><a href="#9-Search-Template-和-Index-Alias-查询" class="headerlink" title="9. Search Template 和 Index Alias 查询"></a>9. Search Template 和 Index Alias 查询</h2><h2 id="10-综合排序-Function-Score-Query-优化算分"><a href="#10-综合排序-Function-Score-Query-优化算分" class="headerlink" title="10. 综合排序 Function Score Query 优化算分"></a>10. 综合排序 Function Score Query 优化算分</h2><h2 id="11-Term-amp-Phrase-Suggester"><a href="#11-Term-amp-Phrase-Suggester" class="headerlink" title="11. Term &amp; Phrase Suggester"></a>11. Term &amp; Phrase Suggester</h2><h2 id="12-自动补全与基于上下文的提示"><a href="#12-自动补全与基于上下文的提示" class="headerlink" title="12. 自动补全与基于上下文的提示"></a>12. 自动补全与基于上下文的提示</h2><h2 id="13-配置跨集群搜索"><a href="#13-配置跨集群搜索" class="headerlink" title="13. 配置跨集群搜索"></a>13. 配置跨集群搜索</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 入门</title>
      <link href="/technology/2020-04-01-elasticsearch-learn1/"/>
      <url>/technology/2020-04-01-elasticsearch-learn1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装与准备"><a href="#1-安装与准备" class="headerlink" title="1. 安装与准备"></a>1. 安装与准备</h2><p>安装 es 就是按部就班：</p><ul><li>查看插件：<code>./elasticsearch-plugin list</code></li><li>安装插件：<code>./elasticsearch-plugin install xxx</code></li><li>部署：<code>./elasticsearch</code></li><li>多节点部署：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./elasticsearch -E node.name=node1 -E cluster.name=geektime -E path.data=node1_data -d</span><br><span class="line">./elasticsearch -E node.name=node2 -E cluster.name=geektime -E path.data=node2_data -d</span><br><span class="line">./elasticsearch -E node.name=node3 -E cluster.name=geektime -E path.data=node3_data -d</span><br></pre></td></tr></table></figure><ul><li>删除部署的节点：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep elasticsearch | awk <span class="string">'&#123;print $2&#125;'</span> | xargs kill -<span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li>部署查询：<a href="http://localhost:9200/_cat/nodes" target="_blank" rel="noopener">http://localhost:9200/_cat/nodes</a></li></ul><p>安装一下 Kibana ，端口是 5601 :</p><ul><li>查看插件 <code>./kibana-plugin list</code></li><li>安装插件 <code>./kibana-plugin install xxx</code></li></ul><p>当然也能用 docker 装。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  cerebro:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">lmenezes/cerebro:0.9.1</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">cerebro</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9000:9000"</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">-Dhosts.0.host=http://elasticsearch:9200</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">es7net</span></span><br><span class="line"><span class="attr">  kibana:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">docker.elastic.co/kibana/kibana:7.7.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">kibana7</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">I18N_LOCALE=zh-CN</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">XPACK_GRAPH_ENABLED=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">TIMELION_ENABLED=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">XPACK_MONITORING_COLLECTION_ENABLED="true"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5601:5601"</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">es7net</span></span><br><span class="line"><span class="attr">  elasticsearch:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.7.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">es7_01</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.name=geektime</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node.name=es7_01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">discovery.seed_hosts=es7_01,es7_02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.initial_master_nodes=es7_01,es7_02</span></span><br><span class="line"><span class="attr">    ulimits:</span></span><br><span class="line"><span class="attr">      memlock:</span></span><br><span class="line"><span class="attr">        soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">        hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - es7data1:</span><span class="string">/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">es7net</span></span><br><span class="line"><span class="attr">  elasticsearch2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.7.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">es7_02</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.name=geektime</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node.name=es7_02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">discovery.seed_hosts=es7_01,es7_02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.initial_master_nodes=es7_01,es7_02</span></span><br><span class="line"><span class="attr">    ulimits:</span></span><br><span class="line"><span class="attr">      memlock:</span></span><br><span class="line"><span class="attr">        soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">        hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - es7data2:</span><span class="string">/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">es7net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  es7data1:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  es7data2:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  es7net:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><blockquote><p>一个 cerebro 0.9.1、一个 kibana 7.7.0、两个 es 7.7.0。</p></blockquote><p>接着是 Logstash ，尝试将 movielens 数据集写入 es ，使用指令：<code>./logstash -f logstash.conf</code> 执行。</p><blockquote><p>需要提前准备数据集。不再继续打印输信息了，就算结束了。logstash 会监听文件，如有变化，会继续更新。</p></blockquote><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><p>ES 是面向文档的，文档被保存成 JSON 格式，每一个文档都有一个 Unique ID。</p><blockquote><p>每一个文档都有『元数据』，<code>_index</code> 文档索引名，<code>_type</code> 文档所属的类型名，<code>_id</code> 唯一 ID，<code>_source</code> 原始 JSON，<code>_all</code> 整合所有内容（已经废除），<code>_version</code> 文档版本信息，<code>_score</code> 相关性打分。</p></blockquote><p><strong>索引 Index 是文档的容器，表示一类文档的集合。</strong></p><ul><li>Index 提现了逻辑空间的概念。每个索引都有自己的 Mapping ，用于定义包含文档的字段与类型。</li><li>Shard 是物理空间的概念。索引中的数据分散在 Shard 中。</li><li>Mapping 定义字段类型，Setting 定义不同的数据分布。</li></ul><p>索引在 es 中也可以给表示动词：索引（动）文档到 es 的索引（名）中。</p><blockquote><p>动词『索引』指保存的意思。</p></blockquote><p>在 7.0 前，一个 Index 可以设置多个 Type ，但是 7.0 开始一个索引只能设置一个 Type <code>_doc</code> 。</p><p>与 RDBMS 相比，es 中与之对应的概念：</p><div class="table-container"><table><thead><tr><th>RDBMS</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>Table</td><td>Index(Type)</td></tr><tr><td>Row</td><td>Document</td></tr><tr><td>Column</td><td>Filed</td></tr><tr><td>Schema</td><td>Mapping</td></tr><tr><td>SQL</td><td>DSL</td></tr></tbody></table></div><ul><li>es 偏向于相关性的全文检索；</li><li>RDBMS 事务性更强。</li></ul><p>节点与分片是重要的概念：</p><ul><li>es 不同的集群通过名字来划分，默认为『elasticsearch』。通过 <code>-E cluster.name=xxx</code> 来设置集群名字，一个集群有一个或多个节点。</li><li>节点是一个 es 的实例，本质上是一个进程，生产环境推荐一台机器一个实例（节点），每个节点都有名字通过 <code>-E node.name=xxx</code> 来设置，每个节点启动后会有一个 UID，保存在 data 目录下。</li><li>每个节点启动默认是一个『Master-eligible』节点，可以通过设置 <code>node.master: false</code> 禁止，只有 Master 节点可以修改集群的状态信息。<ul><li>Data Node 是可以保存数据的节点，负责保存分片数据；</li><li>Coordinating Node 负责接收 Client 的请求，将请求分发到合适的节点上，最终将结果聚集返回（每个节点默认都有 Coordinating Node 的职责）；</li><li>Hot Node 是配置比较高的节点（一般而言），而 Warm Node 则保存比较旧的数据（一般配置较低）；</li><li>Machine Learning Node 负责机器学习的 Job ，用来异常检测；</li><li>Tribe Node 逐渐淘汰，改用 Cross Cluster Search 用于连接不同的集群，将这些集群当做一个集群。</li></ul></li></ul><blockquote><p>开发环境一个节点可以承担多个角色，生产环境则应该设置单一角色。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> master eligible</span><br><span class="line">node.master = true</span><br><span class="line"><span class="meta">#</span> data</span><br><span class="line">node.data = true</span><br><span class="line"><span class="meta">#</span> ingest</span><br><span class="line">node.ingest = true</span><br><span class="line"><span class="meta">#</span> ml</span><br><span class="line">node.ml = true</span><br><span class="line"><span class="meta">#</span> coordinating</span><br><span class="line"><span class="meta">#</span> 无</span><br></pre></td></tr></table></figure><ul><li>Primary Shard，主分片，解决水平扩展的问题，将数据分布到集群内所有节点上。<ul><li>一个分片是一个 Lucene 实例。</li><li>主分片数在索引创建时指定，后续不能更改，除非 Reindex。</li></ul></li><li>Replica Shard，副本，用于解决数据高可用的问题，分片是主分片的拷贝。<ul><li>副本分片可以动态调整。</li><li>增加副本数，可以在一定程度上提高服务的可用性。</li></ul></li><li>主分片如果过小，导致无法增加节点实现水平扩展，同时单个节点数据量过大，数据查询耗时。</li><li>主分片如果过大，默认是 1 ，将影响搜索结果的相关性打分，同时单个节点上分片过多，会资源浪费，同时影响性能。</li></ul><p>集群有健康状况 <code>GET _cluster/health</code> ，Green 都正常，Yellow 主正常部分副本不正常，Red 主不正常。</p><h2 id="3-CRUD-与批量操作"><a href="#3-CRUD-与批量操作" class="headerlink" title="3. CRUD 与批量操作"></a>3. CRUD 与批量操作</h2><p>Http Method + Index Name + Type + Doc Id。</p><ul><li>Type 约定用 <code>_doc</code>；</li><li>Create 如果 Id 存在，会失败；</li><li>Index 如果 Id 不存在，创建新的文档，否则删除现有文档，再创建新的文档，版本会增加；</li><li>Update 如果文档存在，更新只会对相应字段做增量操作；</li></ul><h3 id="3-1-Create"><a href="#3-1-Create" class="headerlink" title="3.1 Create"></a>3.1 Create</h3><ul><li>通过 <code>post /users/_doc</code> 系统自动生成 Doc Id；</li><li>使用 <code>put user/_create/1</code> 或 <code>put users/_doc/1?op_type=create</code> 显式指定 Id ，如果 Id 存在，则失败；<ul><li>先执行了自动生成，再执行手动指定的时候，会成功，但是第二次执行会失败（因为自动生成的 Id 是随机的，不会在这里发生冲突）</li></ul></li></ul><h3 id="3-2-Get"><a href="#3-2-Get" class="headerlink" title="3.2 Get"></a>3.2 Get</h3><ul><li>找到则返回 200 <code>get users/_doc/1</code>；<ul><li><code>_version</code> 表示文档经过多少次改动；</li></ul></li><li>找不到则 404</li></ul><h3 id="3-3-Index"><a href="#3-3-Index" class="headerlink" title="3.3 Index"></a>3.3 Index</h3><blockquote><p>如果文档不存在，就创建新的文档；否则现有文档被删除，再创建新的文档，版本增加。</p></blockquote><ul><li>使用 <code>put user/_doc/1</code> 进行操作；</li></ul><h3 id="3-4-Update"><a href="#3-4-Update" class="headerlink" title="3.4 Update"></a>3.4 Update</h3><blockquote><p>不会删除原有的文档，而是实现真正的数据更新。</p></blockquote><ul><li>使用 <code>post users/_update/1</code> 进行操作；</li><li>在执行时必须指明 <code>doc</code> ；</li></ul><h3 id="3-5-Bulk-API"><a href="#3-5-Bulk-API" class="headerlink" title="3.5 Bulk API"></a>3.5 Bulk API</h3><ul><li>在一次 API 调用中，对不同的索引进行操作，支持：Index Create Update Delete。</li><li>单条操作失败不会影响其他结果；最终结果包含每一条操作。</li><li>以 <code>post _bulk</code> 开始，其中指定各种 Index 。</li></ul><h3 id="3-6-批量读取-mget"><a href="#3-6-批量读取-mget" class="headerlink" title="3.6 批量读取 mget"></a>3.6 批量读取 mget</h3><ul><li>批量操作，用 Id 获得详情，减少网络连接所产生的开销，提高性能。</li><li>以 <code>get _mget</code> 开始，可以在 URI 中指定 Index，也可以在请求体中说明 Index。</li></ul><h3 id="3-7-批量查询-msearch"><a href="#3-7-批量查询-msearch" class="headerlink" title="3.7 批量查询 msearch"></a>3.7 批量查询 msearch</h3><ul><li>以 <code>post _msearch</code> 开始，API 更加丰富，根据条件进行查询。</li></ul><blockquote><p>429 集群繁忙。</p></blockquote><h2 id="4-倒排索引"><a href="#4-倒排索引" class="headerlink" title="4. 倒排索引"></a>4. 倒排索引</h2><p>目录是正排索引 Id -&gt; 内容，书的结尾的索引页是倒排索引 内容 -&gt; Id。</p><p>倒排索引包括两个部分：</p><ul><li>单词词典 Term Dictionary，记录所有文档的单词，记录单词到倒排索引的关系，可以用 B+ 树或哈希拉链，满足高性能的插入与查询。</li><li>倒排列表 Posting List，记录单词对应的文档结合，由倒排索引项组成。倒排索引项包括：<ul><li>文档 Id</li><li>词频 TF</li><li>位置，用于语句搜索</li><li>偏移，单词开始到结束的位置，高亮显示</li></ul></li></ul><h2 id="5-Analyzer-分词"><a href="#5-Analyzer-分词" class="headerlink" title="5. Analyzer 分词"></a>5. Analyzer 分词</h2><p>Analysis 文本分析可以把全文文本转化成一系列单词，也就是分词。Analysis 是通过 Analyzer 实现的。</p><p>Analyzer 分词器由三个部分组成：Character Filters 针对原始文本进行处理、Tokenizer 根据一定规则进行字符串切分、Token Filters 将切分结果进行二次加工。</p><ul><li>Standard Analyzer - 是默认分词器，按词进行切分，小写处理。</li><li>Simple Analyzer – 按照非字母切分（符号、数字被过滤），小写处理</li><li>Stop Analyzer – 小写处理，停用词过滤（the，a，is）</li><li>Whitespace Analyzer – 按照空格切分，不转小写</li><li>Keyword Analyzer – 不分词，直接将输入当作输出</li><li>Patter Analyzer – 正则表达式，默认 \W+ (非字符分隔)</li><li>Language – 提供了30多种常见语言的分词器</li><li>ICU Analyzer - 中文分词，提供 Unicode 支持，Character Filters 是 Normalization，Tokenizer 是 ICU Tokenizer，Token Filters 是 Normalization + Folding + Collation + Transform。</li></ul><blockquote><p><code>get /_analyze</code> 指定 Analyzer 进行分词，<code>post xxx/_analyze</code> 指定索引字段进行分词，<code>post /_analyzer</code> 自定义分词器进行分词。</p></blockquote><h2 id="6-Search-API-概览"><a href="#6-Search-API-概览" class="headerlink" title="6. Search API 概览"></a>6. Search API 概览</h2><ul><li>URI Search<ul><li>在 URL 中使用查询参数。</li><li>使用 get 方法，在 URL 中使用 <code>q</code> 指定查询字符串，字符串是 <code>k:v</code> 形式的键值对。</li></ul></li><li>Request Body Search<ul><li>使用 es 提供的，基于 JSON 格式的更加完备的 DSL 。</li><li>使用 get 或 post 方法，在请求体中使用 DSL 。</li><li><code>/_search</code> 查询集群上所有的索引。</li><li><code>/index1/_search</code> 查询 index1 索引上的内容。</li><li><code>/index1,index2/_search</code> 查询 index1 和 index2 索引上的内容。</li><li><code>/index*/_search</code> 匹配 index 开头的索引上的内容。</li></ul></li></ul><p>响应结果中：</p><ul><li>took 花费时间。</li><li>total 符合条件的文档总数。</li><li>hits 结果集，默认前 10 个文档。</li></ul><p>另外一个重点在于 score ：</p><ul><li>搜索结果会根据 score 进行排名。</li><li>Precision 查准率 = True Positive / 全部返回的结果</li><li>Recall 查全率 = True Positive / 所有应该返回的结果</li><li>使用 es 的查询和相关参数可以改善搜索的 Precision 和 Recall 。</li></ul><h2 id="7-URI-Search-详解"><a href="#7-URI-Search-详解" class="headerlink" title="7. URI Search 详解"></a>7. URI Search 详解</h2><ul><li><code>q</code> 查询语句，使用 Query String Syntax。</li><li><code>df</code> 默认字段，不指定时，返回所有字段的查询。</li><li><code>sort</code> 排序。</li><li><code>from</code> 和 <code>size</code> 用于分页。</li><li>请求体里的 <code>Profile</code> 查看查询是如何被执行的。</li><li>指定字段查询 <code>q=title:2012</code>，范查询则是 <code>q=2012</code>。</li><li>Term vs Phrase<ul><li>Beautiful Mind 等效于 Beautiful OR Mind <code>title:(Beautiful AND Mind)</code>。</li><li>“Beautiful Mind” 等效于 Beautiful AND Mind，同时要求顺序一致 <code>title=&quot;Beautiful Mind&quot;</code>。</li></ul></li><li>布尔操作<ul><li><code>AND</code> <code>$$</code></li><li><code>OR</code> <code>||</code></li><li><code>NOT</code> <code>!</code></li></ul></li><li>分组操作<ul><li><code>+</code> 或 <code>%2B</code> 必须要。</li><li><code>-</code> 一定不要。</li><li><code>title:(Beautiful %2BMind)</code> 这种情况下 Mind 不需要有，Beautiful 可以没有。</li></ul></li><li>范围查询<ul><li><code>[]</code> 闭区间，<code>{}</code> 开区间。</li><li><code>year:{2018 TO 2019]</code></li><li><code>year:[* TO 2019]</code></li></ul></li><li>数学符号<ul><li><code>year:&gt;2010</code></li><li><code>year:(&gt;2010 %% &lt;=2018)</code></li><li><code>year:(+&gt;2010 +&lt;=2018)</code></li></ul></li><li>当然也能有通配符、正则.</li><li>模糊与近似查询<ul><li><code>title:beautifl~1</code> 可以找到拼写完整的 befautiful。</li><li><code>title:&quot;lord rings&quot;~2</code> 可以找到 lord of the rings。</li></ul></li></ul><h2 id="8-Request-Body-与-Query-DSL"><a href="#8-Request-Body-与-Query-DSL" class="headerlink" title="8. Request Body 与 Query DSL"></a>8. Request Body 与 Query DSL</h2><ul><li>推荐用 Request Body Search，有些操作这能在这里用。</li><li>请求体的 <code>query</code> 中 <code>&quot;match_all&quot;:{}</code> 查询所有文档。</li><li>请求体的 <code>from</code> 从 0 开始，默认返回 10 个结果。</li><li>请求体的 <code>sort</code> 可以进行排序，比如 <code>&quot;sort&quot;:[{&quot;order_date&quot;:&quot;desc&quot;}]</code>。最好是数字和日期。</li><li>请求体的 <code>_source</code> 可以进行过滤，比如 <code>&quot;_source&quot;:[&quot;order_date&quot;,&quot;category.keyword&quot;]</code>。</li><li>URI 中的参数 <code>ignore_unavailable=true</code> 可以忽略访问不存在的索引导致的报错。</li><li>请求体中使用 <code>script_fields</code> 表示脚本字段，比如如下例子：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET kibana_sample_data_ecommerce/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"script_fields"</span>: &#123;</span><br><span class="line">    <span class="string">"test_field"</span>: &#123; <span class="comment"># 自定义的名称</span></span><br><span class="line">      <span class="string">"script"</span>: &#123;</span><br><span class="line">        <span class="string">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="string">"source"</span>: <span class="string">"doc['order_date'].value+'hello'"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>:[<span class="string">"order_date"</span>],</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比如计算汇率的时候可以用到。</p></blockquote><ul><li>Match 请求对应了 Term 操作，在请求体的 <code>query</code> 中使用 <code>match</code> 开始，默认的 <code>operator</code> 是 OR，比如如下例子：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"title"</span>: &#123;</span><br><span class="line">        <span class="string">"query"</span>: <span class="string">"last christmas"</span>,</span><br><span class="line">        <span class="string">"operator"</span>: <span class="string">"AND"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>响应的也有 Match Phrase 查询对应了 Phrase 操作，在请求体的 <code>query</code> 中使用 <code>match_phrase</code> 开始，如下：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_phrase"</span>: &#123;</span><br><span class="line">      <span class="string">"title"</span>:&#123;</span><br><span class="line">        <span class="string">"query"</span>: <span class="string">"one love"</span>,</span><br><span class="line">        <span class="string">"slop"</span>: <span class="number">1</span> <span class="comment"># 表示允许中间可以有 1 个其他的字符</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以输出 <code>&quot;title&quot; : &quot;One I Love, The&quot;</code>。</p></blockquote><h2 id="9-Query-String-和-Simple-Query-String-查询"><a href="#9-Query-String-和-Simple-Query-String-查询" class="headerlink" title="9. Query String 和 Simple Query String 查询"></a>9. Query String 和 Simple Query String 查询</h2><ul><li>类似与 URI Query。</li><li>在请求体的 <code>query</code> 中使用 <code>query_string</code> 进行填充，df = default_field，在其中也能用到 <code>query</code>。</li><li><code>simple_query_string</code> 和 <code>query_string</code> 类似，但是会忽略一些错误的语法，同时只支持部分查询。<ul><li>不支持 AND OR NOT，都当做字符串处理。</li><li>Term 之间默认关系是 OR，但是可以指定 Operator。</li><li>支持逻辑，<code>+</code> 代替 <code>AND</code>，<code>|</code> 代替 <code>OR</code>，<code>-</code> 代替 <code>NOT</code>。</li></ul></li></ul><h2 id="10-Dynamic-Mapping-和常见字段类型"><a href="#10-Dynamic-Mapping-和常见字段类型" class="headerlink" title="10. Dynamic Mapping 和常见字段类型"></a>10. Dynamic Mapping 和常见字段类型</h2><ul><li>Mapping 和 Dynamic Mapping<ul><li>Mapping 类似于 DB 中的 schema，可以定义索引中的字段，定义字段类型，进行倒排索引配置。</li><li>Mapping 会将 JSON 映射成 Lucene 所需要的扁平格式。</li></ul></li><li>字段类型自动识别<ul><li>简单类型有 Text/Keyword，Date，Integer/Floating，Boolean，IPv4/IPv6。</li><li>复杂类型有对象和嵌套类型。</li><li>特殊类型有 geo_point/geo_shape/percolator。</li></ul></li><li>控制 Mapping 的 Dynamic 属性<ul><li>一个 Mapping 属于一个索引的 Type，现在一个索引只能有一个 Type。</li></ul></li><li>Dynamic Mapping 是在写入文档的时候，如果索引不存在就会自动创建索引，但是类型推断有时候会发生错误。<ul><li>字符串且匹配日期格式，自动为 Date。</li><li>字符串且匹配数字，设置 float 或 long，该转换默认关闭。</li><li>其他字符串则为 Text。</li><li>布尔对应 boolean。</li><li>浮点对应 float。</li><li>整数对应 long。</li><li>对象对应 Object。</li><li>数组由第一个非空数值类型决定。</li><li>控制直接忽略。</li></ul></li><li>如果 Dynamic 为 true，一旦有新字段加入，Mapping 会更新；如果 Dynamic 为 false，新字段无法被索引，但是信息会在 <code>_source</code> 中；如果 Dynamic 是 strict，文档写入失败。</li><li>对于已经有了的字段，一旦已经有数据写入，则不再支持字段定义的更改。</li><li>更改字段类型需要 Reindex API，重建索引。</li></ul><h2 id="11-显式-Mapping-设置与常见参数"><a href="#11-显式-Mapping-设置与常见参数" class="headerlink" title="11. 显式 Mapping 设置与常见参数"></a>11. 显式 Mapping 设置与常见参数</h2><ul><li>可以参考 API 手册，纯手写。<ul><li>创建一个临时 Index，写入一些样本数据。</li><li>通过访问 Mapping API 获得该临时文件的动态 Mapping 定义。</li><li>修改该定义为你的索引。</li><li>删除临时索引。</li></ul></li><li><code>index</code> 控制是否字段被索引，false 时，倒排索引就不会被生成了。</li><li><code>index_options</code> 倒排索引的四个级别。<ul><li><code>docs</code> 记录 doc id。（除 Text 默认）</li><li><code>freqs</code> 记录 doc id 和 term frequencies。</li><li><code>positions</code> 记录 doc id 和 term frequencies 和 term position。（Text 默认）</li><li><code>offsets</code> 记录 doc id 和 term frequencies 和 term position 和 character offects。</li></ul></li><li>如果需要对 Null 值进行搜索，在 Keyword 类型下支持设定 <code>null_value</code>，在搜索时是真正的 Null 值。</li><li><code>_all</code> 被 <code>copy_to</code> 替代，将字段值拷贝到目标字段，搜索可以用目标字段搜索，<code>copy_to</code> 字段不会出现在 <code>_source</code> 中。</li><li>es 没有专门的数组类型，但是任何字段都可以包含多个相同类型的数值。</li></ul><h2 id="12-多字段特性与-Mapping-中自定义-Analyzer"><a href="#12-多字段特性与-Mapping-中自定义-Analyzer" class="headerlink" title="12. 多字段特性与 Mapping 中自定义 Analyzer"></a>12. 多字段特性与 Mapping 中自定义 Analyzer</h2><ul><li>对某一个字段增加一个子字段，也可以指定不同的 Analyzer 进行分词。</li><li>es 中的 Keyword 是一种精确值，包括数字、日期、具体的字符串，没有必要对其进一步分词；而全文本是非结构化的文本数据，就是 es 中的 Text。</li><li>当自带分词器无法满足需求，可以自定义分词器。<ul><li>Character Filter 分此前对文本进行特殊处理，会影响 position 和 offset 的信息，HTML Strip 去除 html 标签，Mapping 字符串替换，Pattern Replace 正则替换。</li><li>Tokenizer 分词时把文本按照一定规则分成词，比如空格、正则、不处理、文件路径等。</li><li>Token Filter 分词后进行二次加工，将输出的单词进行增加、修改、删除。</li></ul></li></ul><h2 id="13-Index-Template-和-Dynamic-Template"><a href="#13-Index-Template-和-Dynamic-Template" class="headerlink" title="13. Index Template 和 Dynamic Template"></a>13. Index Template 和 Dynamic Template</h2><ul><li>Index Templates 帮助设置 Mappings 和 Settings，按照一定的规则自动匹配到新创建的索引之上。<ul><li>模板仅在一个索引被创建时才会有用，模板不会影响已经创建的索引。</li><li>可以设置多个索引模板，这些设置会被 merge 在一起。</li><li>可以指定 <code>order</code> 的数值，用来控制 merge 的过程。</li></ul></li><li>当一个索引被创建：<ul><li>应用 es 默认的 Settings 和 Mappings。</li><li>应用 <code>order</code> 值低的 Index Template 中的设定。</li><li>用高 <code>order</code> 设置覆盖低 <code>order</code> 设定。</li><li>用户指定的 Settings 和 Mappings 覆盖之前的设定。</li></ul></li><li>Dynamic Template 是应用在一个具体的索引上的，结合字段名称，数据类型，来动态设置字段类型。<ul><li>比如所有字符串都设置为 keyword，所有 is 开头都为 boolean，所有 long_ 开头都设置为 long 等。</li></ul></li></ul><h2 id="14-es-聚合分析"><a href="#14-es-聚合分析" class="headerlink" title="14. es 聚合分析"></a>14. es 聚合分析</h2><ul><li>所谓聚合就是数据统计分析，过滤结果。<ul><li>Bucket Aggregation 满足一些特定条件的文档的集合。</li><li>Metric Aggregation 数学运算，可以对文档字段进行统计分析。</li><li>Pipeline Aggregation 对其他的聚合结果进行二次聚合。</li><li>Matrix Aggregation 支持对多个字段的操作提供一个结果矩阵。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(brand) <span class="comment"># Metrix</span></span><br><span class="line"><span class="keyword">FROM</span> cars</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> brand <span class="comment"># Bucket</span></span><br></pre></td></tr></table></figure><ul><li>聚合功能 <code>aggs</code> 可以叠加也可以嵌套。</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">GET kibana_sample_data_flights/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"aggs"</span>:&#123;</span><br><span class="line">    <span class="string">"flight_dest"</span>:&#123;</span><br><span class="line">      <span class="string">"terms"</span>:&#123; <span class="comment"># Bucket</span></span><br><span class="line">        <span class="string">"field"</span>:<span class="string">"DestCountry"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"aggs"</span>:&#123;</span><br><span class="line">        <span class="string">"stats_price"</span>:&#123;</span><br><span class="line">          <span class="string">"stats"</span>:&#123; <span class="comment"># Metrix</span></span><br><span class="line">            <span class="string">"field"</span>:<span class="string">"AvgTicketPrice"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"wather"</span>:&#123;</span><br><span class="line">          <span class="string">"terms"</span>: &#123; <span class="comment"># Bucket</span></span><br><span class="line">            <span class="string">"field"</span>: <span class="string">"DestWeather"</span>,</span><br><span class="line">            <span class="string">"size"</span>: <span class="number">5</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h2><ul><li>判断题：ES 支持使用 Http Put 写入新文档,并通过 Elasticsearch 生成文档 id<ul><li>错，需要用 POST 命令创建</li></ul></li><li>判断题：Update 一个文档，需要使用 Http Put<ul><li>错，Update 文档，使用 POST，PUT 只能用来做 Index 或者 Create</li></ul></li><li>判断题：Index 一个已存在的文档，旧的文档会先被删除，新的文档再被写入，同时版本号加 1<ul><li>对</li></ul></li><li>尝试描述创建一个新的文档到一个不存在的索引中，背后会发生一些什么<ul><li>默认情况下，会创建相应的索引，并且自己设置 Mapping，当然，实际情况还是要看是否有合适的 Index Template</li></ul></li><li>ES7 中的合法的 type 是什么<ul><li>_doc</li></ul></li><li>精确值和全文的本质区别是什么<ul><li>精确值不会被 Analyzer 分词，全文本会</li></ul></li><li>Analyzer 由哪几个部分组成<ul><li>三部分，Character Filter + Tokenizer + Token filter</li></ul></li><li>尝试描述 match 和 match_phrase 的区别<ul><li>Match 中的 terms 之间是 or 的关系，Match phrase 的 terms 之间是 and 的关系,并且 term 之间位置关系也影响搜索的结果</li></ul></li><li>如果你希望 match_phrase 匹配到更多结果，你应该配置查询中什么参数<ul><li>slop</li></ul></li><li>如果 Mapping 的 dynamic 设置成 strict，索引一个包含新增字段的文档时会发生什么<ul><li>直接报错</li></ul></li><li>如果 Mapping 的 dynamic 设置成 false，索引一个包含新增字段的文档时会发生什么<ul><li>文档被索引，新的字段在 _source 中可见。但是该字段无法被搜索</li></ul></li><li>判断题：可以把一个字段的类型从 integer 改成 long，因为这两个类型是兼容的<ul><li>错。字段类型修改，需要重新 reindex</li></ul></li><li>判断题：你可以在 Mapping 文件中为 indexing 和 searching 指定不同的 analyzer<ul><li>对。可以在 Mapping 中为 index 和 search 指定不同的 analyzer</li></ul></li><li>判断题：字段类型为 Text 的字段，一定可以被全文搜索<ul><li>错。可以通过为 Text 类型的字段指定 Not Indexed，使其无法被搜索</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统初始化</title>
      <link href="/technology/2020-02-15-linux-learn2/"/>
      <url>/technology/2020-02-15-linux-learn2/</url>
      
        <content type="html"><![CDATA[<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><h3 id="从-BIOS-到-bootloader"><a href="#从-BIOS-到-bootloader" class="headerlink" title="从 BIOS 到 bootloader"></a>从 BIOS 到 bootloader</h3><p>在主板上，有一个东西叫 ROM（Read Only Memory，只读存储器）。这和咱们平常说的内存 RAM（Random Access Memory，随机存取存储器）不同。ROM 是只读的，上面早就固化了一些初始化的程序，也就是 BIOS（Basic Input and Output System，基本输入输出系统）。</p><p>在 Linux 里面有一个工具，叫 Grub2，全称 Grand Unified Bootloader Version 2。顾名思义，就是搞系统启动的。可以通过 <code>grub2-mkconfig -o /boot/grub2/grub.cfg</code> 来配置系统启动的选项。</p><p>grub2 第一个要安装的就是 boot.img。boot.img 做不了太多的事情。它能做的最重要的一个事情就是加载 grub2 的另一个镜像 core.img。diskboot.img 的任务就是将 core.img 的其他部分加载进来。先是解压缩程序 lzma_decompress.img，再往下是 kernel.img，最后是各个模块 module 对应的映像。</p><blockquote><p>  注意这里加载的是 grub 内核，不是 Linux 内核。</p></blockquote><p>在这之前，我们所有遇到过的程序都非常非常小，完全可以在实模式下运行，但是随着我们加载的东西越来越大，实模式这 1M 的地址空间实在放不下了，所以在真正的解压缩之前，lzma_decompress.img 做了一个重要的决定，就是调用 <code>real_to_prot</code>，切换到保护模式，这样就能在更大的寻址空间里面，加载更多的东西。</p><h3 id="从实模式到保护模式"><a href="#从实模式到保护模式" class="headerlink" title="从实模式到保护模式"></a>从实模式到保护模式</h3><p>实模式，只能寻址 1M，每个段最多 64K；保护模式，对于 32 位系统，能够寻址 4G。</p><p>从实模式到保护模式，将启用分段, 辅助进程管理；启动分页, 辅助内存管理；打开其他地址线。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200521134858.png" alt></p><h3 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h3><p>运行 <code>start_kernel()</code> 函数(位于 init/main.c), 初始化做三件事：</p><ul><li>创建样板进程及各个模块初始化；<ul><li>创建第一个进程， 0 号进程， <code>set_task_stack_end_magic(&amp;init_task)</code> and <code>struct task_struct init_task = INIT_TASK(init_task)</code></li><li>初始化中断， <code>trap_init()</code>，系统调用也是通过发送中断进行，由 <code>set_system_intr_gate()</code> 完成</li><li>初始化内存管理模块， <code>mm_init()</code></li><li>初始化进程调度模块， <code>sched_init()</code></li><li>初始化基于内存的文件系统 rootfs， <code>vfs_caches_init()</code> ，VFS(虚拟文件系统)将各种文件系统抽象成统一接口</li><li>调用 <code>rest_init()</code> 完成其他初始化工作</li></ul></li><li>创建管理/创建用户态进程的进程，1 号进程；<ul><li><code>rest_init()</code> 通过 <code>kernel_thread(kernel_init,...)</code> 创建 1号进程(工作在用户态)。</li><li>权限管理<ul><li>x86 提供 4个 Ring 分层权限</li><li>操作系统利用: Ring0-内核态(访问核心资源); Ring3-用户态(普通程序)</li></ul></li><li>用户态调用系统调用: 用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态</li><li>新进程执行 kernel_init 函数，先运行 ramdisk 的 /init 程序(位于内存中)<ul><li>首先加载 ELF 文件</li><li>设置用于保存用户态寄存器的结构体</li><li>返回进入用户态</li><li>/init 加载存储设备的驱动</li></ul></li><li>kernel_init 函数启动存储设备文件系统上的 init</li></ul></li><li>创建管理/创建内核态进程的进程，2 号进程；<ul><li><code>rest_init()</code> 通过 <code>kernel_thread(kthreadd,...)</code> 创建 2号进程(工作在内核态).</li><li><code>kthreadd</code> 负责所有内核态线程的调度和管理</li></ul></li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200521162025.png" alt></p><p>0 号进程是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个。1 号进程管所有用户态，2 号进程管所有内核态。</p><p>当处于用户态的代码想要执行更高权限的指令，这种行为是被禁止的，要防止他们为所欲为。因此程序的执行是：<strong>用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，然后接着运行</strong>。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200521162010.png" alt></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户进程调用 open 函数：</p><ul><li>glibc 的 syscal.list 列出 glibc 函数对应的系统调用；</li><li>glibc 的脚本 make_syscall.sh 根据 syscal.list 生成对应的宏定义(函数映射到系统调用)；</li><li>glibc 的 syscal-template.S 使用这些宏, 定义了系统调用的调用方式(也是通过宏)；</li><li>其中会调用 DO_CALL (也是一个宏), 32位与 64位实现不同；</li></ul><p>32 位系统调用：</p><ul><li>用户态下：<ul><li>将请求参数保存到寄存器；</li><li>将系统调用名称转为系统调用号保存到寄存器 eax 中；</li><li>通过软中断 ENTER_KERNEL 进入内核态；</li></ul></li><li>内核态下：<ul><li>将用户态的寄存器保存到 pt_regs 中；</li><li>在系统调用函数表 sys_call_table 中根据调用号找到对应的函数；</li><li>执行函数实现, 将返回值写入 pt_regs 的 ax 位置；</li><li>通过 INTERRUPT_RETURN 根据 pt_regs 恢复用户态进程；</li></ul></li></ul><p>64 位系统调用：</p><ul><li>用户态下：<ul><li>将请求参数保存到寄存器；</li><li>将系统调用名称转为系统调用号保存到寄存器 rax 中；</li><li><strong>通过 syscall 进入内核态</strong>；</li></ul></li><li>内核态下：<ul><li>将用户态的寄存器保存到 pt_regs 中；</li><li>在系统调用函数表 sys_call_table 中根据调用号找到对应的函数；</li><li>执行函数实现, 将返回值写入 pt_regs 的 ax 位置；</li><li><strong>通过 sysretq 返回用户态</strong>；</li></ul></li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200521175102.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统综述</title>
      <link href="/technology/2020-02-01-linux-learn1/"/>
      <url>/technology/2020-02-01-linux-learn1/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-系统综述"><a href="#Linux-系统综述" class="headerlink" title="Linux 系统综述"></a>Linux 系统综述</h2><h3 id="安装与管理"><a href="#安装与管理" class="headerlink" title="安装与管理"></a>安装与管理</h3><p>在 Linux 上面，没有双击安装这一说，因此想要安装，我们还得需要命令。CentOS 下面使用 <code>rpm -i jdk-XXX_linux-x64_bin.rpm</code> 进行安装，Ubuntu 下面使用 <code>dpkg -i jdk-XXX_linux-x64_bin.deb</code> 。其中 <code>-i</code> 就是 install 的意思。</p><blockquote><p>  主要记 CentOs 的指令。</p></blockquote><p>在 Linux 下面，凭借 <code>rpm -qa</code> 和 <code>dpkg -l</code> 就可以查看安装的软件列表，<code>-q</code> 就是 query，<code>a</code> 就是 all，<code>-l</code> 的意思就是 list。</p><blockquote><p>  跟上 <code>grep</code> 更好用，如果单纯要查看，最好用 <code>more</code> 或 <code>less</code> 跟一下。前者只能向后翻页，后者更加强大。</p></blockquote><p>如果要删除，可以用 <code>rpm -e</code> 和 <code>dpkg -r</code> 。<code>-e</code> 就是 erase，<code>-r</code> 就是 remove。</p><p>上面这些都是有『安装包』的情况下的操作，如何在没有安装包的情况下安装呢？CentOS 下面是 <code>yum</code> ，Ubuntu 下面是 <code>apt-get</code> 。例如搜索 jdk 、<code>yum search jdk</code> 和 <code>apt-cache search jdk</code> ，可以搜索出很多很多可以安装的 jdk 版本。</p><blockquote><p>  选中一个之后，我们就可以进行安装了。你可以用 <code>yum install java-11-openjdk.x86_64</code> 和 <code>apt-get install openjdk-9-jdk</code> 来进行安装。</p><p>  安装以后，如何卸载呢？我们可以使用 <code>yum erase java-11-openjdk.x86_64</code> 和 <code>apt-get purge openjdk-9-jdk</code> 。</p></blockquote><p>对于 CentOs 来说，配置文件在 <code>/etc/yum.repos.d/CentOS-Base.repo</code> 里，在这里可以进行 yum 换源等操作。</p><p><strong>其实无论是先下载再安装，还是通过软件管家进行安装，都是下载一些文件，然后将这些文件放在某个路径下，然后在相应的配置文件中配置一下。</strong></p><h3 id="运行与关闭"><a href="#运行与关闭" class="headerlink" title="运行与关闭"></a>运行与关闭</h3><p>配置环境变量和 MacOs 一样，就不记录了。</p><p>后台运行使用 <code>nohup</code> 命令，就是 no hang up（不挂起）的意思，最后加一个 <code>&amp;</code> ，就表示后台运行。最终命令的一般形式为 <code>nohup command &gt;out.file 2&gt;&amp;1 &amp;</code> 。这里面，“1”表示文件描述符 1，表示标准输出，“2”表示文件描述符 2，意思是标准错误输出，“2&gt;&amp;1”表示标准输出和错误输出合并了。合并到哪里去呢？到 out.file 里。</p><p>关闭指定进程：<code>ps -ef |grep 关键字 |awk &#39;{print $2}&#39;|xargs kill -9</code> 。</p><blockquote><p>  <code>ps -ef</code> 可以单独执行，列出所有正在运行的程序；</p><p>  <code>awk &#39;{print $2}&#39;</code> 是指第二列的内容，是运行的程序 ID ；</p><p>  可以通过 <code>xargs</code> 传递给 <code>kill -9</code>，也就是发给这个运行的程序一个信号，让它关闭。</p></blockquote><p>Linux 也有相应的服务，这就是程序运行的第三种方式，以服务的方式运行。比如 MySQL ，安装完成以后通过命令 <code>systemctl start mysql</code> 启动 MySQL，通过 <code>systemctl enable mysql</code> 设置开机启动。之所以成为服务并且能够开机启动，是因为在 <code>/lib/systemd/system</code> 目录下会创建一个 <code>XXX.service</code> 的配置文件，里面定义了如何启动、如何关闭。</p><h3 id="分支进程"><a href="#分支进程" class="headerlink" title="分支进程"></a>分支进程</h3><p>在 Linux 里，要创建一个新的进程，需要一个老的进程调用 <code>fork</code> 来实现，其中老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。对于 <code>fork</code> 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。对于子进程进行 <code>execve</code> 执行另外的操作，就形成了分支。</p><blockquote><p>  有个系统调用 <code>waitpid</code> ，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。</p></blockquote><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>系统分配内存时，当分配的内存数量比较小的时候，使用 <code>brk</code>，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了；当分配的内存数量比较大的时候，使用 <code>mmap</code>，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。</p><p>Linux 里有一个特点，<strong>那就是一切皆文件</strong>。每个文件，Linux 都会分配一个文件描述符（File Descriptor），这是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。</p><h3 id="信号与异常"><a href="#信号与异常" class="headerlink" title="信号与异常"></a>信号与异常</h3><p>对于一些不严重的信号，可以忽略，该干啥干啥，但是像 <code>SIGKILL</code>（用于终止一个进程的信号）和 <code>SIGSTOP</code>（用于中止一个进程的信号）是不能忽略的，可以执行对于该信号的默认动作。每种信号都定义了默认的动作，例如硬件故障，默认终止；也可以提供信号处理函数，可以通过 <code>sigaction</code> 系统调用，注册一个信号处理函数。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>首先就是发个消息，不需要一段很长的数据，这种方式称为<strong>消息队列</strong>（Message Queue）。由于一个公司内的多个项目组沟通时，这个消息队列是在内核里的，我们可以通过 <code>msgget</code> 创建一个新的队列，<code>msgsnd</code> 将消息发送到消息队列，而消息接收方可以使用 <code>msgrcv</code> 从队列中取消息。</p><p>当消息内容较大，可以用<strong>内存共享</strong>，这时候，我们可以通过 <code>shmget</code> 创建一个共享内存块，通过 <code>shmat</code> 将共享内存映射到自己的内存空间，然后就可以读写了。共用内存可能存在竞争，这就是信号量的机制 Semaphore。</p><blockquote><p>  对于只允许一个人访问的需求，我们可以将信号量设为 1。当一个人要访问的时候，先调用 <code>sem_wait</code> 。如果这时候没有人访问，则占用这个信号量，他就可以开始访问了。</p><p>  如果这个时候另一个人要访问，也会调用 <code>sem_wait</code> 。由于前一个人已经在访问了，所以后面这个人就必须等待上一个人访问完之后才能访问。当上一个人访问完毕后，会调用 <code>sem_post</code> 将信号量释放，于是下一个人等待结束，可以访问这个资源了。</p></blockquote><h3 id="Glib-与中介"><a href="#Glib-与中介" class="headerlink" title="Glib 与中介"></a>Glib 与中介</h3><p>Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。</p><p>每个特定的系统调用对应了至少一个 Glibc 封装的库函数，比如说，系统提供的打开文件系统调用 <code>sys_open</code> 对应的是 Glibc 中的 <code>open</code> 函数。</p><p>有时候，Glibc 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 <code>printf</code> 函数就会调用如 <code>sys_open</code>、<code>sys_mmap</code>、<code>sys_write</code>、<code>sys_close</code> 等等系统调用。</p><p>也有时候，多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 <code>malloc</code>、<code>calloc</code>、<code>free</code> 等函数用来分配和释放内存，都利用了内核的 <code>sys_brk</code> 的系统调用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200521162124.png" alt></p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200521162359.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从玩具到产品</title>
      <link href="/technology/2020-01-01-netty-geek5/"/>
      <url>/technology/2020-01-01-netty-geek5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写一个 Netty 玩具</title>
      <link href="/technology/2019-12-10-netty-geek4/"/>
      <url>/technology/2019-12-10-netty-geek4/</url>
      
        <content type="html"><![CDATA[<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200515104103.png" alt></p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200515104145.png" alt></p><h2 id="案例与数据结构"><a href="#案例与数据结构" class="headerlink" title="案例与数据结构"></a>案例与数据结构</h2><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200515104435.png" alt></p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200515104511.png" alt></p><blockquote><p>  这里 Message Body 使用 JSON 格式，当然也能用其他的格式。</p></blockquote><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ol><li>首先要解决粘包、半包问题。</li><li>接着二次解码，处理各种格式的包内容。</li><li>然后是具体的 handler 方法编写。</li><li>然后是服务器端、客户端内容。值得注意的是对于服务端的逻辑流程与客户端相反，只要注意 request 和 response 的填写即可。</li><li><code>MessageToMessageEncoder</code> 中会自动匹配类型，类型不符合会在 pipline 中跳过。</li></ol><h2 id="完善客户端"><a href="#完善客户端" class="headerlink" title="完善客户端"></a>完善客户端</h2><p>请求与请求之间不应该有联系：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200519153813.png" alt></p><p>为了达到上图的目的，我们需要有 <code>id-future</code> 的关系，在 <code>request</code> 里 new 一个 <code>future</code> ，保存关系，然后用 <code>future.get()</code> 来等待结果，结果带有相同的 <code>id</code> 。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><code>LengthFieldBasedFrameDecoder</code> 中 <code>initialBytesToStrip</code> 未考虑设置；<ul><li>如果不设置，结果含有 <code>length</code> 字段，会解析失败。</li><li>默认该值为 0 ，但是不一定正确。</li></ul></li><li><code>ChannelHandler</code> 顺序不正确，<code>ChannelHandler</code> 该共享不共享，不该共享却共享；<ul><li><code>pipline</code> 里的顺序非常重要，先解码，再处理，再编码，注意编码穿插在解码后。</li></ul></li><li>分配 <code>ByteBuf</code> ：分配器直接用 <code>ByteBufAllocator.DEFAULT</code> 等，而不是采用 <code>ChannelHandlerContext.alloc()</code>；<ul><li>大多数情况没有问题，<code>ctx.alloc()</code> 是可以切换堆外、堆内等情况的，如果换了实现，<code>ByteBufAllocator.DEFAULT</code> 就不支持了。</li></ul></li><li>未考虑 <code>ByteBuf</code> 的释放；<ul><li>在 Handler 中使用 <code>SimpleChannelInboundHandler</code> 的好处就是有内置的释放 <code>ByteBuf</code> ，即 <code>release()</code> 方法。</li></ul></li><li>错以为 <code>ChannelHandlerContext.write(msg)</code> 就写出数据了；<ul><li><code>write</code> 仅仅是加到队列而不是发出去。</li></ul></li><li>乱用 <code>ChannelHandlerContext.channel().writeAndFlush(msg)</code>；<ul><li>还有一种 <code>ctx.channel().writeAndFlush(msg)</code> 是完整的 pipline 重新走一遍（客户端可能会用），而 <code>ctx.writeAndFlush()</code> 仅仅是在当前 pipline 的位置寻找下一个可以走的位置（服务端常用）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从请求处理剖析 Netty</title>
      <link href="/technology/2019-11-20-netty-geek3/"/>
      <url>/technology/2019-11-20-netty-geek3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Netty-总览"><a href="#1-Netty-总览" class="headerlink" title="1. Netty 总览"></a>1. Netty 总览</h2><p>Netty 编译需要操作系统 64 位，保证下载 jar 包为 64 位，下图是 Netty 的核心包。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200429125759.png" alt></p><p>底部是工具类，左边是 Netty 实现的 tcp 等协议支持，右边是编解码和 handler 。</p><p>codec 主要存放编解码；common 方工具类、过线程包、日志；example 用来抄代码；handler 用来实现人性化功能，方便大家使用；proxy 代理；microbench 测试用；resolver 地址解析；transport 主要是 tcp udp ；rxtx 和 udt 被放弃。</p><h2 id="2-启动服务"><a href="#2-启动服务" class="headerlink" title="2. 启动服务"></a>2. 启动服务</h2><blockquote><p>记录顺序：主线、源码、知识点</p></blockquote><ul><li>our thread<ul><li>创建 selector</li><li>创建 server socket channel</li><li>初始化 server socket channel</li><li>给 server socket channel 从 boss group 选择一个 NioEventLoop</li></ul></li><li>boss thread<ul><li>将 server socket channel 注册到选择的 NioEventLoop 的 selector</li><li>绑定地址启动</li><li>注册接受连接事件 OP_ACCEPT 到 selector 上</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = sun.nio.ch.SelectorProviderImpl.openSelector()</span><br><span class="line"></span><br><span class="line">ServerSocketChannel serverSocketChannel = provider.openServerSocketChannel()</span><br><span class="line"></span><br><span class="line">selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line"></span><br><span class="line">selectionKey.interestOps(OP_ACCEPT);</span><br></pre></td></tr></table></figure><ul><li>Selector 是在 <code>new NioEventLoopGroup()</code>（创建一批 NioEventLoop）时创建。</li><li>第一次 Register 并不是监听 OP_ACCEPT，而是 0:<ul><li><code>javaChannel().register(eventLoop().unwrappedSelector(), 0, this)</code></li></ul></li><li>最终监听 OP_ACCEPT 是通过 bind 完成后的 <code>fireChannelActive()</code> 来触发的。</li><li>NioEventLoop 是通过 Register 操作的执行来完成启动的。</li><li>类似 ChannelInitializer，一些 Hander 可以设计成一次性的，用完就移除，例如授权。</li></ul><blockquote><p>channel 是连接；</p><p>eventloop 是为连接服务的执行器，或者说一个死循环 loop 轮询，处理 channel 上的事件 event ；</p><p>一个 channel 只会绑定到一个 eventloop ，但是一个 eventloop 可以服务多个 channel ；</p><p>eventloopgroup 相当于 eventloop 的多线程。</p></blockquote><h2 id="3-构建连接"><a href="#3-构建连接" class="headerlink" title="3. 构建连接"></a>3. 构建连接</h2><ul><li>boss thread<ul><li>NioEventLoop 中的 selector 轮询创建连接事件（OP_ACCEPT）</li><li>创建 socket channel</li><li>初始化 socket channel 并从 worker group 中选择一个 NioEventLoop</li></ul></li><li>worker thread<ul><li>将 socket channel 注册到选择的 NioEventLoop 的 selector</li><li>注册读事件（OP_READ）到 selector 上</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">接收连接：</span><br><span class="line"></span><br><span class="line">selector.select()/selectNow()/select(timeoutMillis)</span><br><span class="line"></span><br><span class="line">发现 OP_ACCEPT 事件，处理：</span><br><span class="line"></span><br><span class="line">SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">selectionKey.interestOps(OP_READ);</span><br></pre></td></tr></table></figure><ul><li>创建连接的初始化和注册是通过 pipeline.fireChannelRead 在 ServerBootstrapAcceptor 中完成的。</li><li>第一次 Register 并不是监听 OP_READ ，而是 0 ：<ul><li><code>javaChannel().register(eventLoop().unwrappedSelector(), 0, this)</code></li></ul></li><li>最终监听 OP_READ 是通过“Register”完成后的 fireChannelActive （<code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code>中）来触发的。</li><li>Worker’s NioEventLoop 是通过 Register 操作执行来启动。</li><li>接受连接的读操作，不会尝试读取更多次（16次）。</li></ul><h2 id="4-接收数据"><a href="#4-接收数据" class="headerlink" title="4. 接收数据"></a>4. 接收数据</h2><p>读数据技巧：</p><ol><li>自适应数据大小的分配器 AdaptiveRecvByteBufAllocator ：发放东西时，用多大桶装？小了不够，大了浪费。</li><li>连续度 defaultMaxMessagesPerRead ：加入发放时，桶装满了，如果还要继续所以直接拿新的桶装，直到没有了或者需要给别人机会了才放弃。</li></ol><hr><ul><li>worker thread<ul><li>多路复用器（ Selector ）接收到 OP_READ 事件</li><li>处理 OP_READ 事件：<code>NioSocketChannel.NioSocketChannelUnsafe.read()</code><ul><li>分配一个初始 1024 字节的 byte buffer 来接受数据</li><li>从 Channel 接受数据到 byte buffer</li><li>记录实际接受数据大小，调整下次分配 byte buffer 大小</li><li>触发 <code>pipeline.fireChannelRead(byteBuf)</code> 把读取到的数据传播出去</li><li>判断接受 byte buffer 是否满载而归：是，尝试继续读取直到没有数据或满 16 次； 否，结束本轮读取，等待下次 OP_READ 事件</li></ul></li></ul></li></ul><hr><ul><li>读取数据本质：<code>sun.nio.ch.SocketChannelImpl#read(java.nio.ByteBuffer)</code></li><li><code>NioSocketChannel read()</code> 是读数据， <code>NioServerSocketChannel read()</code>是创建连接</li><li><code>pipeline.fireChannelReadComplete()</code> 一次读事件处理完成</li><li><code>pipeline.fireChannelRead(byteBuf)</code> 一次读数据完成，一次读事件处理可能会包含多次读数据操作。</li><li>为什么最多只尝试读取 16 次？NioEventLoop 是复用的，需要“雨露均沾”。</li><li>AdaptiveRecvByteBufAllocator 对 bytebuf 的猜测：放大果断，缩小谨慎（需要连续 2 次判断）。</li></ul><h2 id="5-业务处理"><a href="#5-业务处理" class="headerlink" title="5. 业务处理"></a>5. 业务处理</h2><ul><li>worker thread<ul><li><del>多路复用器（ Selector ）接收到 OP_READ 事件</del></li><li><del>处理 OP_READ 事件：<code>NioSocketChannel.NioSocketChannelUnsafe.read()</code></del><ul><li><del>分配一个初始 1024 字节的 byte buffer 来接受数据</del></li><li><del>从 Channel 接受数据到 byte buffer</del></li><li><del>记录实际接受数据大小，调整下次分配 byte buffer 大小</del></li><li><strong>触发 <code>pipeline.fireChannelRead(byteBuf)</code> 把读取到的数据传播出去</strong></li><li><del>判断接受 byte buffer 是否满载而归：是，尝试继续读取直到没有数据或满 16 次； 否，结束本轮读取，等待下次 OP_READ 事件</del></li></ul></li></ul></li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200504211532.png" alt></p><p>在 pipline 上的 handler 不会都执行，需要实现 <code>ChannelInboundHandler</code> ，同时不能加注解 @Skip 。</p><ul><li>处理业务本质：数据在 pipeline 中所有的 handler 的 <code>channelRead()</code> 执行过程</li><li>Handler 要实现 <code>io.netty.channel.ChannelInboundHandler#channelRead (ChannelHandlerContext ctx, Object msg)</code>，且不能加注解 @Skip 才能被执行到。</li><li>中途可退出，不保证执行到 Tail Handler。</li><li>默认处理线程就是 Channel 绑定的 NioEventLoop 线程，也可以设置其他：<code>pipeline.addLast(new UnorderedThreadPoolEventExecutor(10), serverHandler)</code></li></ul><h2 id="6-发送数据"><a href="#6-发送数据" class="headerlink" title="6. 发送数据"></a>6. 发送数据</h2><ul><li>write : 将数据放到一个 buffer 里；</li><li>flush : 从 buffer 中将数据发送出去；</li><li>writeAndFlush : 写到 buffer 并发送；</li><li>write 与 flush 之间有一个 ChannelOutboundBuffer 。</li></ul><hr><p>写数据技巧：</p><ol><li><p>Netty 写数据，写不进去时，会停止写，然后注册一个 OP_WRITE 事件，来通知什么时候可以写进去了再写。</p></li><li><p>Netty 批量写数据时，如果想写的都写进去了，接下来的尝试写更多（调整maxBytesPerGatheringWrite）。</p></li><li><p>Netty 只要有数据要写，且能写的出去，则一直尝试，直到写不出去或者满 16 次（writeSpinCount）。</p></li><li><p>Netty 待写数据太多，超过一定的水位线 <code>writeBufferWaterMark.high()</code> ，会将可写的标志位改成false ，让应用端自己做决定要不要发送数据了。</p></li></ol><hr><ul><li>Write - 写数据到 buffer ：<ul><li><code>ChannelOutboundBuffer#addMessage</code></li></ul></li><li>Flush - 发送 buffer 里面的数据：<ul><li><code>AbstractChannel.AbstractUnsafe#flush</code></li><li>准备数据: <code>ChannelOutboundBuffer#addFlush</code></li><li>发送：<code>NioSocketChannel#doWrite</code></li></ul></li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200504225721.png" alt></p><hr><ul><li>写的本质：<ul><li>single write: <code>sun.nio.ch.SocketChannelImpl#write(java.nio.ByteBuffer)</code></li><li>gathering write：<code>sun.nio.ch.SocketChannelImpl#write(java.nio.ByteBuffer[], int, int)</code></li></ul></li><li>写数据写不进去时，会停止写，注册一个 OP_WRITE 事件，来通知什么时候可以写进去了，再来 flush。</li><li><strong>OP_WRITE 不是说有数据可写，而是说可以写进去</strong>，所以正常情况，不能注册，否则一直触发。</li><li>批量写数据时，如果尝试写的都写进去了，接下来会尝试写更多（ maxBytesPerGatheringWrite ）。</li><li>只要有数据要写，且能写，则一直尝试，直到 16 次（ writeSpinCount ），写 16 次还没有写完，就直 接 schedule 一个 task 来继续写，而不是用注册写事件来触发，更简洁有力。</li><li>待写数据太多，超过一定的水位线（ <code>writeBufferWaterMark .high()</code>），会将可写的标志位改成 false ， 让应用端自己做决定要不要继续写。</li><li><code>channelHandlerContext.channel().write()</code> ：从 TailContext 开始执行。</li><li><code>channelHandlerContext.write()</code> : 从当前的 Context 开始。</li></ul><h2 id="7-断开连接"><a href="#7-断开连接" class="headerlink" title="7. 断开连接"></a>7. 断开连接</h2><ul><li>多路复用器（Selector）接收到 OP_READ 事件。</li><li>处理 OP_READ 事件，即 <code>NioSocketChannel.NioSocketChannelUnsafe.read()</code>：<ul><li>接受数据</li><li>判断接受的数据大小是否 &lt; 0 , 如果是，说明是关闭，开始执行关闭：<ul><li>关闭 channel（包含 cancel 多路复用器的 key）。</li><li>清理消息：不接受新信息，fail 掉所有 queue 中消息。</li><li>触发 fireChannelInactive 和 fireChannelUnregistered 。</li></ul></li></ul></li></ul><hr><ul><li>关闭连接本质：<ul><li><code>java.nio.channels.spi.AbstractInterruptibleChannel#close</code><ul><li><code>java.nio.channels.SelectionKey#cancel</code></li></ul></li></ul></li><li>要点：<ul><li>关闭连接，会触发 OP_READ 方法。读取字节数是 -1 代表关闭。</li><li>数据读取进行时，强行关闭，触发 IO Exception，进而执行关闭。</li><li>Channel 的关闭包含了 SelectionKey 的 cancel 。</li></ul></li></ul><h2 id="8-关闭服务"><a href="#8-关闭服务" class="headerlink" title="8. 关闭服务"></a>8. 关闭服务</h2><ul><li><code>bossGroup.shutdownGracefully();</code></li><li><code>workerGroup.shutdownGracefully();</code></li><li>关闭所有 Group 中的 NioEventLoop ：<ul><li>修改 NioEventLoop 的 State 标志位</li><li>NioEventLoop 判断 State 执行退出</li></ul></li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200504231226.png" alt></p><hr><ul><li>关闭服务本质：<ul><li>关闭所有连接及 Selector ：<ul><li><code>java.nio.channels.Selector#keys</code><ul><li><code>java.nio.channels.spi.AbstractInterruptibleChannel#close</code></li><li><code>java.nio.channels.SelectionKey#cancel</code></li></ul></li><li><code>selector.close()</code></li></ul></li><li>关闭所有线程：退出循环体 for (;;)</li></ul></li></ul><hr><ul><li>关闭服务要点：<ul><li>优雅（DEFAULT_SHUTDOWN_QUIET_PERIOD），静默期</li><li>可控（DEFAULT_SHUTDOWN_TIMEOUT），默认退出时间</li><li>先不接活，后尽量干完手头的活（先关 boss 后关 worker：不是100%保证）</li></ul></li></ul><blockquote><p>Netty 的主线就是基于 Java NIO 的编程。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从领域知识剖析 Netty</title>
      <link href="/technology/2019-10-15-netty-geek2/"/>
      <url>/technology/2019-10-15-netty-geek2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Netty-下三种-I-O"><a href="#1-Netty-下三种-I-O" class="headerlink" title="1. Netty 下三种 I/O"></a>1. Netty 下三种 I/O</h2><ul><li>阻塞与非阻塞：要不要死等，阻塞会等待直到有数据；非阻塞会直接返回。</li><li>同步与异步：数据就绪后谁来操作，自己去读是同步；主动回调是异步。</li></ul><p>BIO——阻塞同步；NIO——非阻塞同步；AIO——非阻塞异步。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200409205216.png" alt></p><p>Netty 对三者都有过支持，阻塞导致资源占用多因此不用，而 AIO 的弃用是因为 Linux 下 AIO 相较于 NIO 性能提升不明显，效益不够高，同时 Linux 下 AIO 的实现不够完善。</p><p>BIO 在连接数少，并发不高的情况下性能不输于 NIO ，所以我们应该结合具体场景进行分析。</p><h2 id="2-Netty-如何切换-I-O-模式？"><a href="#2-Netty-如何切换-I-O-模式？" class="headerlink" title="2. Netty 如何切换 I/O 模式？"></a>2. Netty 如何切换 I/O 模式？</h2><p>我们需要换 <code>EventLoopGroup</code> （开发模式）与 <code>Channel</code> （I/O 模式）即可，</p><p><code>Channel</code> 通过<strong>泛型+反射+工厂</strong>实现 I/O 模式的切换，可以跟进源码看到 <code>ReflectiveChannelFactory</code> 的实现，它作为一个工厂方法会生产通过传入的 class 进行 <code>Channel</code> 的反射实例化。这里 Netty 的 <code>Channel</code> 会帮助我们创建 <code>socketChannel</code> 。</p><p>而 <code>EventLoopGroup</code> 是一种开发模式，这也是 Netty 标语中『事件驱动』的意义，也就是 Reactor 模式的实现。</p><h2 id="3-Netty-对-Reactor-的支持"><a href="#3-Netty-对-Reactor-的支持" class="headerlink" title="3. Netty 对 Reactor 的支持"></a>3. Netty 对 Reactor 的支持</h2><ul><li>Reactor 单线程——一个人包揽所有工作；</li><li>Reactor 多线程——多个人做所有事情；</li><li>Reactor 主从——一个或多个人专门做某些事情。</li></ul><p>对于 BIO 是 Thead-Per-Connection 模式，对于 NIO 是 Reactor 模式，对于 AIO 是 Proactor 模式。</p><p>对于 Reactor 而言，核心流程：</p><ol><li>注册感兴趣的事件；</li><li>扫描是否有感兴趣的事件发生；</li><li>事件发生后做出相应的处理。</li></ol><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200410011726.png" alt></p><h3 id="3-1-Thread-Per-Connection-模式"><a href="#3-1-Thread-Per-Connection-模式" class="headerlink" title="3.1 Thread-Per-Connection 模式"></a>3.1 Thread-Per-Connection 模式</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200410011855.png" alt></p><p>线程池可以解决这个问题吗？仅仅解决线程无限增多的问题，事实上我们还增加了等待线程的阻塞，下面是对应代码。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200410012456.png" alt></p><p>值得注意的是上文的 read 和 write 都是阻塞操作。</p><h3 id="3-2-Reactor-单线程"><a href="#3-2-Reactor-单线程" class="headerlink" title="3.2 Reactor 单线程"></a>3.2 Reactor 单线程</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200410012731.png" alt></p><p>所有一切都是一个线程在做，如果线程挂了自然就都挂了。</p><h3 id="3-3-Reactor-多线程"><a href="#3-3-Reactor-多线程" class="headerlink" title="3.3 Reactor 多线程"></a>3.3 Reactor 多线程</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200410012842.png" alt></p><p>它在单线程的基础上把 decode compute encode 这些操作放到一个单独的线程池中操作。</p><h3 id="3-4-Reactor-主从"><a href="#3-4-Reactor-主从" class="headerlink" title="3.4 Reactor 主从"></a>3.4 Reactor 主从</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200410013023.png" alt></p><p>它把接收连接和具体操作进一步分离，让专业的人做专业的事。</p><h3 id="3-5-以主从为例"><a href="#3-5-以主从为例" class="headerlink" title="3.5 以主从为例"></a>3.5 以主从为例</h3><h4 id="3-5-1-如何实现-Reactor-模式？"><a href="#3-5-1-如何实现-Reactor-模式？" class="headerlink" title="3.5.1 如何实现 Reactor 模式？"></a>3.5.1 如何实现 Reactor 模式？</h4><p>这里要注意一下，Netty 代码量非常大，我们通过 Usage of xxx 和 Hierarchy caller 先找调用处再看调用层次，非常有效。</p><p>可以从代码里发现两种 channel (<code>ServerSocketChannel</code> 和 <code>SocketChannel</code>)绑定到两种 group (<code>parentGroup</code> 和 <code>childGroup</code>)中，这就完成了一个主从 Reactor 的支持。</p><h4 id="3-5-2-为什么说的-Netty-main-reactor-大多都不能用到一个线程组？"><a href="#3-5-2-为什么说的-Netty-main-reactor-大多都不能用到一个线程组？" class="headerlink" title="3.5.2 为什么说的 Netty main reactor 大多都不能用到一个线程组？"></a>3.5.2 为什么说的 Netty main reactor 大多都不能用到一个线程组？</h4><p>通过调用栈可以发现，Netty 的 <code>group</code> 方法被 <code>doBind</code> 方法调用，它的作用是绑定地址和端口，对于一个服务器而言我们一般绑定一个地址和一个端口，也因此我们只会在一个 <code>group</code> 中绑定到一个子元素。</p><h4 id="3-5-3-Netty-给-Channel-分配-NIO-event-loop-的规则是什么？"><a href="#3-5-3-Netty-给-Channel-分配-NIO-event-loop-的规则是什么？" class="headerlink" title="3.5.3 Netty 给 Channel 分配 NIO event loop 的规则是什么？"></a>3.5.3 Netty 给 Channel 分配 NIO event loop 的规则是什么？</h4><p>从 <code>ServerBootstrap</code> 类的 <code>channelRead</code> 方法可以找到一个 <code>register</code> 调用，它是对 <code>EventLoopGroup</code> 接口的调用，也就是这个问题的答案了。这个 <code>register</code> 方法有两个实现，进到 <code>MultithreadEventLoopGroup</code> 的实现中，发现 <code>next().register(channel)</code> 这样的代码，显然这是一个调用链，跟进 <code>next()</code> 找到 <code>chooser.next()</code> ，这里有一个选择器，它的 <code>next</code> 方法有两种，一种是 <code>GenericEventExecutorChooser</code> 另一种是 <code>PowerOfTwoEventExecutorChooser</code> ，找到了。</p><ul><li>对于一个数组而言，第一种方式 <code>generic</code> 采用的是——递增、取模、取正值的方式；</li><li>第二种则要求数组长度为 2 的幂次，它会用 <code>&amp;</code> 进行操作，运算效率更高，但需要数组长度符合要求。</li></ul><h4 id="3-5-4-Netty-如何跨平台？"><a href="#3-5-4-Netty-如何跨平台？" class="headerlink" title="3.5.4 Netty 如何跨平台？"></a>3.5.4 Netty 如何跨平台？</h4><p>比如在 <code>NioEventLoopGroup</code> 类里有一个构造器，使用了 <code>SelectorProvider.provider()</code> 方法，有一句 <code>provider = sun.nio.ch.DefaultSelectorProvider.create()</code> 这里的 <code>create</code> 方法是跨平台的，在 mac 下实现是返回一个 <code>KQueueSelectorProvider</code> ，在 win 下返回的是 <code>WindowsSelectorProvider</code> ，这是 JDK 的不同返回的不同实现。</p><h2 id="4-TCP-粘包、半包-Netty-处理"><a href="#4-TCP-粘包、半包-Netty-处理" class="headerlink" title="4. TCP 粘包、半包 Netty 处理"></a>4. TCP 粘包、半包 Netty 处理</h2><p>比如我们发 ABC DEF 收到的就不一定是原样，收到如果是 ABCDEF 就是粘包，收到如果是 AB CD EF 则是半包现象。</p><p>粘包原因：</p><ul><li>发送方写入数据 &lt; 套接字缓冲区大小；</li><li>对方读取数据不够及时。</li></ul><p>半包原因：</p><ul><li>发送方写如数据 &gt; 套接字缓冲区大小；</li><li>发送的数据大于 MTU ，必须拆包。</li></ul><p>传输原因：</p><ul><li>一个发送可能被多次接收，多个发送可能被一次接收；</li><li>一个发送可能占用多个传输包，多个发送可能共用一个传输包。</li></ul><p>真正的原因则是——<strong>TCP 是一个流式协议，消息无边界</strong>。</p><blockquote><p>UDP 则是有界限的，所以没有粘包和半包的现象。</p></blockquote><p>所以解决之本就是找到消息的边界。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200410142247.png" alt></p><p>Netty 在封装成帧的实现上有如下支持。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200410142703.png" alt></p><p>这三个解码类都继承自 <code>ByteToMessageDecoder</code> ，这个类就是用来解决粘包和半包问题的。解码入口在 <code>channelRead</code> 方法，这里有一个参数 <code>cumulation</code> 这是一个数据积累器，其后它就是方法参数中的 <code>ByteBuf</code> 对象，代码会走到 <code>decode</code> 这是一个模板方法，以 <code>FixedLengthFrameDecoder</code> 为例，当 <code>cumulation</code> 的数据长度满足 <code>frameLegnth</code> 的时候就会解析，多出来的数据还会保留，我们就这样解决了粘包和半包问题。</p><p>说回 <code>cumulation</code> 的累加，它有两种方式，一种是内存复制，按需扩容；另一种方式是组合，它不是内存复制，而是一种视图。内存复制的是默认的使用，因为累加器最后还是服务于 <code>decode</code> 的行为，行为不同可能会因为内存复制与非内存复制的方式产生实现误差，因此选用更为通用的内存复制的方式。</p><p>这里看一下 <code>LengthFieldBasedFrameDecoder</code> ，其文档非常强大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * lengthFieldOffset   =  0 // 偏移量</span></span><br><span class="line"><span class="comment"> * lengthFieldLength   =  2 // 长度字段的长度</span></span><br><span class="line"><span class="comment"> * lengthAdjustment    =  0 // 插在长度和实际内容直接的字段长度</span></span><br><span class="line"><span class="comment"> * initialBytesToStrip =  0 // 解析开始位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="comment"> * | Length | Actual Content |-----&gt;| Length | Actual Content |</span></span><br><span class="line"><span class="comment"> * | 0x000C | "HELLO, WORLD" |      | 0x000C | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><h2 id="5-二次编解码"><a href="#5-二次编解码" class="headerlink" title="5. 二次编解码"></a>5. 二次编解码</h2><p>第一次解码是解决半包、粘包时的解码，这里我们得到了字节；接着我们还需要一层解码用来进行对象转换，也就是所谓的二次解码。</p><ul><li>一次解码：<code>ByteToMessageDecoder</code> ByteBuf 的转换</li><li>二次解码：<code>MessageToMessageDecoder</code> 将 ByteBuf 转换成 Java Object</li></ul><p>这样做是为了分层、降耦合。Java 序列化、Marshaling、XML、JSON、MessagePack、Protobuf、其他…二次解码非常多。</p><ul><li><p>JSON、MessagePack、Protobuf 在时间和空间上较优；</p></li><li><p>可读性 JSON &gt; MessagePack；</p></li><li>最流行的是 Protobuf ，是一个灵活、高效的序列化数据的协议，但是它的可读性比较差。</li></ul><p>在 <code>netty-codec</code> 子工程下可以找到大量的编解码类。</p><p>同时，Netty 下有一个世界时钟的例子，它是使用 <code>Protobuf</code> 进行二次编解码的。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200411020901.png" alt></p><p>这里有 5 个 add 的内容，分别是一次编解码，二次编解码，执行内容。执行的顺序应该是一次解码、二次解码、执行、二次编码、一次编码。</p><h2 id="6-keepalive-与-Idle-监测"><a href="#6-keepalive-与-Idle-监测" class="headerlink" title="6. keepalive 与 Idle 监测"></a>6. keepalive 与 Idle 监测</h2><h3 id="6-1-什么是-keepalive-？"><a href="#6-1-什么是-keepalive-？" class="headerlink" title="6.1 什么是 keepalive ？"></a>6.1 什么是 keepalive ？</h3><p>keepalive 就是一次 request 期望得到 response 。TCP 的 keepalive 有这样几个参数：</p><ul><li>net.ipv4.tcp_keepalive_time = 7200</li><li>net.ipv4.tcp_keepalive_intvl = 75</li><li>net.ipv4.tcp_keepalive_probes = 9</li></ul><p>通过的7200秒后发送 keepalive 消息，当探测没有确认时， 按75秒的重试频率重发，一直发 9 个探测包都没有确认，就认定 连接失效。所以总耗时一般为：2 小时 11 分钟 (7200 秒 + 75 秒* 9 次)。</p><h3 id="6-2-为什么还需要应用层-keepalive-？"><a href="#6-2-为什么还需要应用层-keepalive-？" class="headerlink" title="6.2 为什么还需要应用层 keepalive ？"></a>6.2 为什么还需要应用层 keepalive ？</h3><p>传输层 TCP 的 keepalive 是判断是否『通路』，应用层的 keepalive 是用来判断服务是否存在；TCP 的 keepalive 是默认关闭的；TCP 的 keepalive 时间太长了。</p><blockquote><p>HTTP 的 keepalive 和这个不是一回事，它特指『长连接』。</p></blockquote><h3 id="6-3-什么是-Idle-检测？"><a href="#6-3-什么是-Idle-检测？" class="headerlink" title="6.3 什么是 Idle 检测？"></a>6.3 什么是 Idle 检测？</h3><p>Idle 检测仅仅负责诊断，而后做出不同行为，下面是两种 Idle 检测的使用方式。</p><ul><li>配合 keepalive ：当有数据传输时，不发送 keepalive，当没有数据传输时，先发 Idle 再发 keepalive ；</li><li>直接关闭连接：简单粗暴。</li></ul><h3 id="6-4-Netty-中的-keepalive-如何生效"><a href="#6-4-Netty-中的-keepalive-如何生效" class="headerlink" title="6.4 Netty 中的 keepalive 如何生效"></a>6.4 Netty 中的 keepalive 如何生效</h3><p>在 <code>ServerBootStrap</code> 里有一个 <code>childOption</code> 方法，这里的 child 就是客户端使用的含义，把设置的值配置到 child 的 <code>Channel</code> 中，一路向下可以找到 <code>setOption</code> 方法，它有两种方式设置 keepalive 之类的参数：</p><ul><li>一种是通过配置 <code>NioSocketChannel</code> 它的实现是通过 Java NIO 的 api 来进行配置；</li><li>另外一种是通过 <code>DefaultSocketChannelConfig</code>  的实现，堆砌 if else 代码。</li></ul><h3 id="6-5-Netty-中的-Idle-如何生效"><a href="#6-5-Netty-中的-Idle-如何生效" class="headerlink" title="6.5 Netty 中的 Idle 如何生效"></a>6.5 Netty 中的 Idle 如何生效</h3><p>Idle 对于 Netty 是一个扩展能力在 <code>handler/timeout</code> 下，被分为 read / write / all 三种。</p><blockquote><p>对于写而言，具有写意图和写成功是两回事，比如写了但是缓存满了，或者没有写了但是没有写完。</p></blockquote><p>这三种 Idle 的实现都是线程中执行的，是一种监控行为。</p><p><code>ReadTimeoutHandler</code> 是由 <code>ReadTimeoutIdle</code> 触发的，但是 <code>WriteTimeoutHandler</code> 不是由 <code>WriteTimeoutIdle</code> 触发的，这是一个 Netty 的坑，前者是用来判断 read 空闲的，后者是判断 write 是否完成。</p><h2 id="7-Netty-锁事"><a href="#7-Netty-锁事" class="headerlink" title="7. Netty 锁事"></a>7. Netty 锁事</h2><p>同步三要素：原子、可见、有序。</p><p>如果我们需要一个原子 Long ，应该会最先想到使用 <code>AtomicLong</code> ，但是在 Netty 中使用了另外一种方式，它使用 <code>volatile long</code> ，同时定义一个 <code>AtomicLongFieldUpdater</code> ，这么做的好处就是节省空间，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLongFieldUpdater&lt;ChannelOutboundBuffer&gt; TOTAL_PENDING_SIZE_UPDATER = AtomicLongFieldUpdater.newUpdater(ChannelOutboundBuffer.class, <span class="string">"totalPendingSize"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> totalPendingSize;</span><br></pre></td></tr></table></figure><p><code>volatile long</code> 占用 8 byte ；而 <code>AtomicLong</code> 则是 8(volatile long) + 16(对象头) + 8 (引用) 共 32 byte ，当然也有指针压缩、对齐之类的技术，最后可能比 32 大也有可能比 32 小，但总归是大了 3 倍以上。</p><p>当 JDK &gt;=8 时会尽量使用 <code>LongAdder</code> ，其效率高于 <code>AtomicLong</code> ，底层是一个 base 域和一个 cells 数组(保存计数值)，低并发（没有竞争/ CAS 不失败）直接修改 base ，高并发更新到 cells 数组，分离出热点更新，如果要获取真正的long值，只要将各个槽中的变量值与 base 累加返回。</p><p>此外还有比如针对 JDK8 前的 <code>ConcurrentHashMapV8</code> 这样的实现（现在已经不用了），还有针对多写单读使用 <code>MpscChunkedArrayQueue</code> 而不是使用 <code>LinkedBlockingQueue</code> 。</p><p>Netty 中大量使用局部串行，也就是 <code>Channel</code> 中的 I/O 请求都是 Pipeline 的方式执行，而同时它又是整体并行的方式：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200412174544.png" alt></p><p>这里一个 <code>EventLoop</code> 服务于多个 <code>Channel</code> ，同时每一个 <code>Channel</code> 中都是局部串行：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200412174641.png" alt></p><p>最后在 Netty 中能不用锁就不用锁，比如 <code>ThreadLocal</code> ，来避免资源争用，Netty 中实现了一个轻量级的 <code>ThreadLocal</code> 即 <code>FastThreadLocal</code> 。</p><h2 id="8-Netty-的内存使用"><a href="#8-Netty-的内存使用" class="headerlink" title="8. Netty 的内存使用"></a>8. Netty 的内存使用</h2><p>目标：</p><ul><li>占用内存少；</li><li>应用速度快。</li></ul><p>Netty 的实现方式：</p><ol><li>能用基本类型就不用包装类型；</li><li>能定义成类变量就不要定义成实例变量；（实例越多，浪费越多）</li><li>AtomicLong -&gt; volatile long + static AtomicLongFieldUpdater ，减少对象本身大小；</li><li>对分配内存进行预估，比如 <code>HashMap</code> 提前给预估大小；</li><li>Zero-Copy ，使用逻辑组合来替代实际的复制；使用包装来代替实际复制；调用 JDK 的 Zero-Copy 接口，比如使用 NIO 的 <code>FileChannel.transferTo()</code> 方法；</li><li>堆外内存，堆——heap，非堆——non heap，堆外——off heap。堆外更大减轻了 GC 压力，但是速度慢，而且收 OS 管理风险更大；</li><li>内存池，开源可以用 Apache Commons Pool ，Netty 有一个自己的内存池 <code>io.netty.util.Recycler</code> 。</li></ol><p>Netty 源码中内存的使用：</p><ul><li>Netty 默认使用了池化的实现，<code>io.netty.allocator.type</code> 默认值是 <code>pooled</code> ；<ul><li>在 <code>PooledDirectBuf</code> 类下，可以找到 <code>PooledDirectByteBuf buf = RECYCLER.get()</code> 这里就是从对象池中获取了一个对象，本质上是通过 stack 的 <code>pop</code> 获取一个，没有再新建；</li><li>再在调用 <code>PooledByteBuf.deallocate()</code> 的时候使用 <code>recycle()</code> 归还对象，还到 stack 中。</li></ul></li><li>Netty 切换堆内和堆外内存；<ul><li>参数设置，<code>io.netty.noPreferDirect = true</code> 可以使用堆外内存；</li><li>类 <code>PooledByByteBufAllocator</code> 的构造方法写 <code>true</code> ，可以同样进行切换。</li></ul></li><li>本质上，Netty 通过 <code>ByteBuffer.allocateDirect(initialCapacity)</code> 方法可以调用 JDK 的方法来分配堆外内存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么选择用 Netty</title>
      <link href="/technology/2019-09-13-netty-geek1/"/>
      <url>/technology/2019-09-13-netty-geek1/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么选择用-Netty"><a href="#为什么选择用-Netty" class="headerlink" title="为什么选择用 Netty"></a>为什么选择用 Netty</h2><ul><li>支持常用应用层协议；</li><li>解决传输问题：粘包、半包现象；</li><li>支持流量整形；</li><li>完善的连接、Idle 等异常处理。</li></ul><h3 id="1-应对-epoll-bug"><a href="#1-应对-epoll-bug" class="headerlink" title="1.  应对 epoll bug"></a>1.  应对 epoll bug</h3><p>此 bug 的详细地址——<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302" target="_blank" rel="noopener">传送门</a>，现在的状态依然是未修复，简单说这个 bug 是异常唤醒空转导致 CPU 100% 。看下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建、配置 ServerSocketChannel</span></span><br><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">serverChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9998</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Selector</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    selector.select();  <span class="comment">// select 可能在无就绪事件时异常返回！</span></span><br><span class="line"></span><br><span class="line">    Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = readyKeys.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = it.next();</span><br><span class="line">        ...  <span class="comment">// 处理事件</span></span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>selector.select()</code> 方法应该一直阻塞，然而 Java NIO 可能会在没有任何就绪事件的情况下返回！导致 while 逻辑不断执行，最后 CPU 达到 100% 。</p><p>Netty 的应对是检测 epoll 空转的次数，如果大于一定阈值，新建 selector 。</p><blockquote><p>大部分框架的解决也都类似，差别仅在检测方式的不同，其后重建 Selector 。</p></blockquote><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200409161915.png" alt></p><h3 id="2-应对-IP-TOS-参数"><a href="#2-应对-IP-TOS-参数" class="headerlink" title="2.  应对 IP_TOS 参数"></a>2.  应对 IP_TOS 参数</h3><p>在使用 http 的 IP_TOS 参数时会抛出异常，<a href="https://bugs.openjdk.java.net/browse/JDK-8209152" target="_blank" rel="noopener">传送门</a>。</p><p>Netty 的方式是绕着走，不支持这个选项。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200409162239.png" alt></p><h3 id="3-比原生更友好"><a href="#3-比原生更友好" class="headerlink" title="3.  比原生更友好"></a>3.  比原生更友好</h3><p>Netty 的 API 更加友好：</p><ul><li>比如 Java 里的 <code>ByteBuffer</code> 只有一个指针，所以在写完开始读的时候要做 <code>flip</code> 操作，本身是一个 final 的数组，不好扩容，但是 Netty 的 <code>ByteBuf</code> 就更友好了。</li><li>Netty 有自己的 <code>FastThreadLocal</code> 在高并发下性能更好。</li></ul><h3 id="4-隔离变化"><a href="#4-隔离变化" class="headerlink" title="4.  隔离变化"></a>4.  隔离变化</h3><p>Netty 隔离了变化，屏蔽了细节：</p><ul><li>JDK 在变化比如 1.4 引入了 NIO ，在 1.7 引入了 AIO ，如果用原生实现就非常复杂，但是如果使用 Netty 就非常方便。</li><li>Netty 屏蔽了 JDK NIO 的实现细节。</li></ul><h3 id="5-一群人的战斗"><a href="#5-一群人的战斗" class="headerlink" title="5.  一群人的战斗"></a>5.  一群人的战斗</h3><p>Java NIO 至今有 5 千多个 bug issue ，Netty 代码量多达 18w 行，如果我们选择 NIO 就是一个人的战斗，我们可能需要扫一眼这么多 bug 起码能知道遇到了什么问题，Netty 2004 年至今的发展，我们也不会做的比 Netty 更好了。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 总结</title>
      <link href="/technology/2019-08-13-leetcode-sum/"/>
      <url>/technology/2019-08-13-leetcode-sum/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</li><li>我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</li><li>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</li><li>重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</li></ol><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>明确一点，dp 就是暴力，dp 多的仅仅是使用 dp table 或备忘录优化递归树，同时确定状态转移方程，计算机没有奇技淫巧，只有暴力穷举。</p><ul><li>备忘录、dp table 的作用是将冗余的递归树剪枝。</li><li>『自顶向下』是指我们的问题是逐步拆分的，比如斐波那契数列的第 20 项，从 19、18 … 向下求解。递归解一般用的是自顶向下的方式解。</li><li>『自底向上』是 dp 的说法，我们如果要求斐波那契额数列的第 20 项，应该从 1、 2 … 向上求解。dp 数组解一般用自底向上的方式解。</li><li>状态转移方程是，前后两个『状态』，他们存在推导关系，同时『子问题』相互独立。</li><li>最优子结构，可以从子问题的最优结果推出更大规模问题的最优结果。</li></ul><p>比如给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。</p><p>状态转移方程：</p><script type="math/tex; mode=display">d p(n)=\left\{\begin{array}{l}0, n=0 \\-1, n<0 \\\min \{d p(n-\operatorname{coin})+1 | \operatorname{coin} \in \operatorname{coin} s\}, n>0\end{array}\right.</script><p>自顶向下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>自底向上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="comment"># 备忘录</span></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 查备忘录，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><blockquote><p>dp 遍历存在技巧：</p><ol><li>遍历的过程，所需的状态必须是计算出来的。</li><li>遍历的终点必须是存储结果的位置。</li></ol></blockquote><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>背包分多种，首先是<strong>01背包</strong>，给你一个可装载重量为 <code>W</code> 的背包和 <code>N</code> 个物品，每个物品有重量和价值两个属性。其中第 <code>i</code> 个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input：</span><br><span class="line">N = 3, W = 4</span><br><span class="line">wt = [2, 1, 3]</span><br><span class="line">val = [4, 2, 3]</span><br><span class="line"></span><br><span class="line">Output：</span><br><span class="line">6 // 选择前两件物品</span><br></pre></td></tr></table></figure><p>动态规划问题要先明确两个问题：「状态」和「选择」。状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。套框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划状态转移方程框架</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2</span>...)</span><br></pre></td></tr></table></figure><ul><li><code>dp[i][w]</code> 的定义如下：对于前 <code>i</code> 个物品，当前背包的容量为 <code>w</code>，这种情况下可以装的最大价值是 <code>dp[i][w]</code> 。</li><li>我们想求的最终答案就是 <code>dp[N][W]</code>。base case 就是 <code>dp[0][..] = dp[..][0] = 0</code>，因为没有物品或者背包没有空间的时候，能装的最大价值就是 <code>0</code>。</li><li>01 背包的状态转移方程即：<code>dp[i][w] = max(dp[i-1][w], dp[i-1][w - wt[i-1]] + val[i-1])</code> 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01背包模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; wt, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case 已初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 装不下了，这种情况下只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = max(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接着是<strong>子集背包</strong>，给一个正整数数组分割成两个子集，令两个子集和相等。用背包问题的口吻说，即给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？</p><p>状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p><ul><li><code>dp[i][j] = x</code> 表示，对于前 <code>i</code> 个物品，当前背包的容量为 <code>j</code> 时，若 <code>x</code> 为 <code>true</code>，则说明可以恰好将背包装满；若 <code>x</code> 为 <code>false</code>，则说明不能恰好将背包装满。</li><li>我们想求的最终答案就是 <code>dp[N][sum/2]</code>，base case 就是 <code>dp[..][0] = true</code> 和 <code>dp[0][..] = false</code>，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。</li><li>子集背包的状态转移方程：<code>dp[i][j] = dp[i - 1][j] | dp[i - 1][j-nums[i-1]];</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子集背包模板</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="comment">// 和为奇数时，不可能划分成两个和相等的集合</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; </span><br><span class="line">        dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(sum + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或不装入背包</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>01 背包，和现在的子集背包中的 <code>dp[i][j]</code> 都只和 <code>dp[i-1][...]</code> 相关，所以只要 <code>i-1</code> 保留，<code>dp</code> 数组可以压缩到一维。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子集背包状态压缩模板</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(sum + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sum; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">            <span class="keyword">if</span> (j - nums[i] &gt;= <span class="number">0</span>) </span><br><span class="line">                dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">    <span class="keyword">return</span> dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>然后<strong>完全背包</strong>问题，有一个背包，最大容量为 <code>amount</code>，有一系列物品 <code>coins</code>，每个物品的重量为 <code>coins[i]</code>，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？</p><p>状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」嘛，背包问题的套路都是这样。</p><ul><li><code>dp[i][j]</code> 表示若只使用前 <code>i</code> 个物品，当背包容量为 <code>j</code> 时，有 <code>dp[i][j]</code> 种方法可以装满背包。</li><li>base case 为 <code>dp[0][..] = 0</code>， <code>dp[..][0] = 1</code>。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 <code>0</code>，那么什么都不用就是唯一的一种凑法。</li><li>完全背包的状态转移方程：<code>dp[i][j] = dp[i - 1][j] + dp[i][j-coins[i-1]];</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = amount <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">            <span class="keyword">if</span> (j - coins[i-<span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i-<span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同样，这里的 <code>dp[i][j]</code> 仅和上一行的 <code>dp[i-1][...]</code> 有关，这一行反正是要另算的，因此也可以状态压缩。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包状态压缩模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">            <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[j] = dp[j] + dp[j-coins[i]];</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><p>子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，用最长公共子序列问题抛砖引玉一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: str1 = &quot;abcde&quot;, str2 = &quot;ace&quot; </span><br><span class="line">输出: 3  </span><br><span class="line">解释: 最长公共子序列是 &quot;ace&quot;，它的长度是 3</span><br></pre></td></tr></table></figure><ul><li><code>dp[i][j]</code> 的含义是：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。</li><li>我们专门让索引为 0 的行和列表示空串，<code>dp[0][..]</code> 和 <code>dp[..][0]</code> 都应该初始化为 0，这就是 base case。因为有一个字符串是空串。</li><li>LCS 的状态转移方程：<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])</code> 或者 <code>dp[i][j] = 1 + dp[i-1][j-1]</code> ，前者是当前 <code>str1[i - 1] != str2[j - 1]</code> 。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LCS 模板</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(str1, str2)</span> -&gt; int:</span></span><br><span class="line">    m, n = len(str1), len(str2)</span><br><span class="line">    <span class="comment"># 构建 DP table 和 base case</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 找到一个 lcs 中的字符</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 谁能让 lcs 最长，就听谁的</span></span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li><code>dp[i-1][j-1]</code> 对应的 lcs 长度不可能比前两种情况大，所以只需要 <code>max(dp[i-1][j], dp[i][j-1])</code> ，没有必要参与比较。</li></ul><hr><p><strong>子序列问题考察的是动态规划技巧，时间复杂度一般都是 O(n^2)</strong>。</p><p>第一种思路模板是一个一维的 dp 数组，比如 LIS 最长递增自序列就能用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子序列问题一维数组模板</span></span><br><span class="line"><span class="keyword">int</span> n = array.length;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种思路模板是一个二维的 dp 数组，比如 LCS 最长公共子序列问题就能用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子序列问题二维数组模板</span></span><br><span class="line"><span class="keyword">int</span> n = arr.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[n][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>涉及两个字符串/数组时，我们要求的子序列（最长公共子序列）长度为 <code>dp[i][j]</code> 。</li><li>只涉及一个字符串/数组时，在子数组 <code>array[i..j]</code> 中，我们要求的子序列（最长回文子序列）的长度为 <code>dp[i][j]</code> 。</li></ul><hr><p>最长回文子序列比如 <code>bbbab</code> 中，最长的回文子序列是 <code>bbbb</code> ，很好理解。</p><ul><li>dp 数组的定义是：在子串 <code>s[i..j]</code> 中，最长回文子序列的长度为 <code>dp[i][j]</code>。</li><li>如果 <code>s[i]</code> 和 <code>s[j]</code> 相等，<code>dp[i][j] = dp[i + 1][j - 1] + 2</code> ；否则 <code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code> 。</li><li>如果只有一个字符，显然最长回文子序列长度是 1，也就是 <code>dp[i][j] = 1 if (i == j)</code> 。</li><li>因为 <code>i</code> 肯定小于等于 <code>j</code>，所以对于那些 <code>i &gt; j</code> 的位置，根本不存在什么子序列，应该初始化为 0。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长回文子序列模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="comment">// dp 数组全部初始化为 0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 反着遍历保证正确的状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整个 s 的最长回文子串长度</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种遍历较为特殊，因为结果在 <code>dp[0][n - 1]</code> ，所以遍历方向是从下到上，从左到右。</li></ul><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>编辑距离问题就是给我们两个字符串 s1 和 s2，只能用增、删、改三种操作，让我们把 s1 变成 s2，求最少的操作数。需要明确的是，不管是把 s1 变成 s2 还是反过来，结果都是一样的，所以后文就以 s1 变成 s2 举例。</p><ul><li><code>dp[i,j]</code> 表示 <code>s1[0..i]</code> 转变成 <code>s2[0..j]</code> 的最小操作数。</li><li><code>dp[..][0]</code> 和 <code>dp[0][..]</code> 对应 base case 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最短编辑距离模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="comment">// 自底向上求解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>               </span><br><span class="line">                dp[i][j] = min(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                    dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                );</span><br><span class="line">    <span class="comment">// 储存着整个 s1 和 s2 的最小编辑距离</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以将这里的 <code>int[] dp</code> 实现一个类比如 <code>Node[][] dp</code>，其中保存 <code>val</code> 为具体操作，可以以此反推编辑细节。</li></ul><h2 id="扔鸡蛋问题"><a href="#扔鸡蛋问题" class="headerlink" title="扔鸡蛋问题"></a>扔鸡蛋问题</h2><p>题目是这样：你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 &lt;= F &lt;= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？</p><ul><li><code>m = dp[K, N]</code> 表示当前状态为 k 个鸡蛋，面对 n 层楼，这个状态下最少的扔鸡蛋次数 m。</li><li><code>min(res, max(dp,dp) + 1)</code> 的含义是最坏情况下的最少次数，外层 <code>for</code> 枚举的是 <code>N</code> ，选择出尝试次数最少的哪一层。</li></ul><script type="math/tex; mode=display">d p(K, N)=\min _{0<=i<=N}\{\max \{d p(K-1, i-1), d p(K, N-i)\}+1\}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扔鸡蛋问题枚举鸡蛋和楼层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(K, N)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (K, N) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="comment"># 用二分搜索代替线性搜索</span></span><br><span class="line">        lo, hi = <span class="number">1</span>, N</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            broken = dp(K - <span class="number">1</span>, mid - <span class="number">1</span>) <span class="comment"># 碎</span></span><br><span class="line">            not_broken = dp(K, N - mid) <span class="comment"># 没碎</span></span><br><span class="line">            <span class="comment"># res = min(max(碎，没碎) + 1)</span></span><br><span class="line">            <span class="keyword">if</span> broken &gt; not_broken:</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">                res = min(res, broken + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">                res = min(res, not_broken + <span class="number">1</span>)</span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure><ul><li>这样的时间复杂度是 <code>O(N*K*logN)</code> 。</li></ul><p>我们上面的想法 <code>dp[k][n] = m</code> 当前状态为 k 个鸡蛋，面对 n 层楼，最少的扔鸡蛋次数为 m 。</p><p>可以反过来想，<code>dp[k][m] = n</code> ，当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋，这个状态下，最坏情况下最多能确切测试一栋 n 层的楼。</p><p>总的楼层数 = 楼上的楼层数 + 楼下的楼层数 + 1 当前这层楼），此时状态转移方程变了：<code>dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扔鸡蛋问题枚举鸡蛋和次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// m 最多不会超过 N 次（线性扫描）</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case:</span></span><br><span class="line">    <span class="comment">// dp[0][..] = 0</span></span><br><span class="line">    <span class="comment">// dp[..][0] = 0</span></span><br><span class="line">    <span class="comment">// Java 默认初始化数组都为 0</span></span><br><span class="line">    <span class="keyword">while</span> (dp[K][m] &lt; N) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">            dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度是 <code>O(KN)</code> 。</li><li>另外注意到 <code>dp[m][k]</code> 转移只和左边和左上的两个状态有关，所以很容易优化成一维 <code>dp</code> 数组。</li></ul><h2 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h2><p>有一些智力题是可以靠推算直接得到结果的，比如『石头游戏』等，你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。</p><p>如果理性分析，可以发现是可以将数组分成奇数和偶数两组，以保证先手者的胜利，但是更一般的做法则是博弈。</p><ul><li>状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的人。</li><li>选择有两个：选择最左边的那堆石头，或者选择最右边的那堆石头。 </li><li><code>dp[i][j]</code> 被定义为一个类的对象，从 <code>piles[i..j]</code> 得到的前手和后手分。</li><li>状态转移方程：<code>dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)</code> 。我作为先手，面对 <code>piles[i...j]</code> 时，有两种选择，要么我选择最左边的那一堆石头，然后面对 <code>piles[i+1...j]</code>，要么我选择最右边的那一堆石头，然后面对 <code>piles[i...j-1]</code> ，下一轮我一定是后手。</li></ul><p>base case 有点意思：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j].fir = piles[i]</span><br><span class="line">dp[i][j].sec = <span class="number">0</span></span><br><span class="line">其中 <span class="number">0</span> &lt;= i == j &lt; n</span><br><span class="line"><span class="comment"># 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]</span></span><br><span class="line"><span class="comment"># 那么显然先手的得分为 piles[i]</span></span><br><span class="line"><span class="comment"># 后手没有石头拿了，得分为 0</span></span><br></pre></td></tr></table></figure><p>最终结果是 <code>dp[0][n-1]</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 石头游戏博弈模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fir, sec;</span><br><span class="line">    Pair(<span class="keyword">int</span> fir, <span class="keyword">int</span> sec) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fir = fir;</span><br><span class="line">        <span class="keyword">this</span>.sec = sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回游戏最后先手和后手的得分之差 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoneGame</span><span class="params">(<span class="keyword">int</span>[] piles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = piles.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    Pair[][] dp = <span class="keyword">new</span> Pair[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++)</span><br><span class="line">            dp[i][j] = <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 填入 base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i].fir = piles[i];</span><br><span class="line">        dp[i][i].sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 斜着遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = l + i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 先手选择最左边或最右边的分数</span></span><br><span class="line">            <span class="keyword">int</span> left = piles[i] + dp[i+<span class="number">1</span>][j].sec;</span><br><span class="line">            <span class="keyword">int</span> right = piles[j] + dp[i][j-<span class="number">1</span>].sec;</span><br><span class="line">            <span class="comment">// 套用状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                dp[i][j].fir = left;</span><br><span class="line">                dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j].fir = right;</span><br><span class="line">                dp[i][j].sec = dp[i][j-<span class="number">1</span>].fir;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Pair res = dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res.fir - res.sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="股票买卖"><a href="#股票买卖" class="headerlink" title="股票买卖"></a>股票买卖</h2><p>一个数组，比如 <code>[2,4,1]</code> 表示股票价格，同时定义参数 <code>k</code> 表示最多进行的操作，操作包括：买、卖、无操作，问最大利润。</p><ul><li><code>dp</code> 状态有三个：第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态。</li><li>比如说 <code>dp[3][2][1]</code> 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 <code>dp[2][3][0]</code> 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。 <code>[1]</code> 代表手上还持有股票，<code>[0]</code> 表示手上的股票已经卖出去了.</li><li>最终答案是 <code>dp[n - 1][K][0]</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 股票买卖模板</span></span><br><span class="line">dp[i][k][<span class="number">0</span> or <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n-<span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line"><span class="comment">// n 为天数，大 K 为最多交易数</span></span><br><span class="line"><span class="comment">// 此问题共 n × K × 2 种状态，全部穷举就能搞定。</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dp[i][k][s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure><ul><li>状态转移方程：<code>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</code> 。表示要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</li><li>或者：<code>dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</code> 。表示要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">// 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">// 解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">// 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">// 解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span></span><br></pre></td></tr></table></figure><p>对于 <code>k</code> 的不同要求，代码需要不同处理，但是状态转移方程可以共用。</p><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>一个数组，你不能同时取两个相邻的数（但是可以跳着取），问取得的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打家劫舍-数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// dp[i] = x 表示：</span></span><br><span class="line">    <span class="comment">// 从第 i 间房子开始抢劫，最多能抢到的钱为 x</span></span><br><span class="line">    <span class="comment">// base case: dp[n] = 0</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>状态转移方程非常简单，不用过多解释</li></ul><p>如果是一个循环数组呢？即首位相邻。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打家劫舍-循环数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(robRange(nums, <span class="number">0</span>, n - <span class="number">2</span>), </span><br><span class="line">                    robRange(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只有两个可能，取第一家或者取最后一家。</li></ul><p>如果此强盗发现现在面对的房子不是一排，不是一圈，而是一棵二叉树！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打家劫舍-二叉树</span></span><br><span class="line">Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 利用备忘录消除重叠子问题</span></span><br><span class="line">    <span class="keyword">if</span> (memo.containsKey(root)) </span><br><span class="line">        <span class="keyword">return</span> memo.get(root);</span><br><span class="line">    <span class="comment">// 抢，然后去下下家</span></span><br><span class="line">    <span class="keyword">int</span> do_it = root.val</span><br><span class="line">        + (root.left == <span class="keyword">null</span> ? </span><br><span class="line">            <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">        + (root.right == <span class="keyword">null</span> ? </span><br><span class="line">            <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line">    <span class="comment">// 不抢，然后去下家</span></span><br><span class="line">    <span class="keyword">int</span> not_do = rob(root.left) + rob(root.right);</span><br><span class="line">    <span class="keyword">int</span> res = Math.max(do_it, not_do);</span><br><span class="line">    memo.put(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完全按照之前的逻辑照抄可以得到这样的代码，事实上可以更加简单。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打家劫舍-二叉树 优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = dp(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回一个大小为 2 的数组 arr</span></span><br><span class="line"><span class="comment">arr[0] 表示不抢 root 的话，得到的最大钱数</span></span><br><span class="line"><span class="comment">arr[1] 表示抢 root 的话，得到的最大钱数 */</span></span><br><span class="line"><span class="keyword">int</span>[] dp(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] left = dp(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = dp(root.right);</span><br><span class="line">    <span class="comment">// 抢，下家就不能抢了</span></span><br><span class="line">    <span class="keyword">int</span> rob = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 不抢，下家可抢可不抢，取决于收益大小</span></span><br><span class="line">    <span class="keyword">int</span> not_rob = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>])</span><br><span class="line">                + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;not_rob, rob&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(N)，空间复杂度只有递归函数堆栈所需的空间，不需要备忘录的额外空间。</li></ul><h2 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h2><p>解决一个回溯问题，实际上就是一个决策树的遍历过程。只需要考虑三个问题：</p><ol><li>路径：也就是已经做出的选择。</li><li>选择列表：也就是你当前可以做的选择。</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回溯模板</span></span><br><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。</p><p>比如用 <code>[1 2 3]</code> 进行全排列，第一位放 <code>[2]</code> ，<code>[2]</code> 就是「路径」，记录你已经做过的选择；<code>[1,3]</code>就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</p><blockquote><p>全排列就是树的遍历，到叶子节点了加入数组或链表，而<strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。</p></blockquote><p>N 皇后问题，本质上也是一个全排列，需要行、列、斜边，都没有第二个皇后，套模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// '.' 表示空，'Q' 表示皇后，初始化空棋盘。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = board[row].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">// 进入下一行决策</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 是否可以在 board[row][col] 放置皇后？ */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.size();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; </span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于求子集问题，也可以套用回溯，因为如果根据数学归纳的方式，那么时间复杂度太高了。比如对于在一个数组 <code>nums</code> 中找到全部的子集，对于数学归纳需要 <code>O(n*2^n)</code> ，但是用回溯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="comment">// 记录走过的路径</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; track)</span> </span>&#123;</span><br><span class="line">    res.push_back(track);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.push_back(nums[i]);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看见，对 res 更新的位置处在前序遍历，也就是说，res 就是树上的所有节点。像这种子集问题都是前序问题。</li><li>对于组合（输入两个数字 n, k，算法输出 [1..n] 中 k 个数字的所有组合）、排列问题，其实也是一种子集的理解，大同小异，代码不写了。</li><li>子集、组合、排列，如果理解成树形，可以发现他们都是在先序上进行的操作，同时子集和组合是不完整的多叉树，而排列则是较为完整的多叉树（越到底层分叉约少）。</li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要出现 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚，这样可以清楚地展现所有细节。</li><li>计算 mid 时需要防止溢出，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大直接相加导致溢出。这样算的是左中位数。</li><li><code>Java</code> 中可以用 <code>(left + right) &gt;&gt;&gt; 1</code> 来防止溢出，这样算的是右中位数。</li><li><code>whilie</code> 中的内容与 <code>right</code> 的初始值关系到区间的开闭，如果用 <code>left &lt; right</code> 同时 <code>right</code> 是 <code>nums.length</code> 则区间是 <code>(left, right]</code> ；如果使用 <code>left &lt;= right</code> 同时 <code>right</code> 是 <code>nums.length - 1</code> 则区间是 <code>[left, right]</code> 。 推荐用后一种。</li><li>如果当前 <code>mid</code> 不对，那么就要根据区间来改 <code>right</code> 和 <code>left</code> ，如果区间是 <code>[]</code> (推荐)，那么自然下一个就是 <code>left = mid + 1</code> 或 <code>right = mid - 1</code> ；如果区间是 <code>[)</code> ，那么下一个就是 <code>left = mid + 1</code> 或 <code>right = mid</code> 。</li></ul><hr><p>知道了这些，来看左边界二分查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左边界二分，左闭右开</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这样搜索的含义是<strong>数组 <code>nums</code> 中比 target 小的元素有 <code>left</code> 个</strong>。</p></li><li><p>之所以这样可以找到边界，是因为当找到目标时 <code>nums[mid] == target</code> ，<code>right = mid</code> ，即不断向左收缩，达到锁定左侧边界的目的。</p></li></ul><p>左边界二分查找改成闭区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左边界二分，闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于 while 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在索引越界。</li></ul><hr><p>同理，有右边边界二分查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右边界二分，左闭右开</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的下界 <code>left</code>，使得区间不断向右收缩，达到锁定右侧边界的目的。</li><li>最后的 <code>left - 1</code> 是因为我们对 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，就是说 while 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</li></ul><p>右边界二分查找改成闭区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右边界二分，闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 这里改成收缩左侧边界即可</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里改为检查 right 越界的情况，见下图</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>N 堆香蕉，每堆 p[i] 个香蕉，需要在 H 时间内吃完，求每小时吃香蕉速度 speed ，同时一小时只能吃一堆。这是非常有趣的左边界二分查找问题。这个题可以用二分是因为它属于<strong>连续的空间线性搜索，这就是二分查找可以发挥作用的标志</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求吃香蕉速度，左边界二分解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 套用搜索左侧边界的算法框架</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = getMax(piles) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (canFinish(piles, mid, H)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度 O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : piles) &#123;</span><br><span class="line">        time += timeOf(n, speed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前堆耗费时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeOf</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n / speed) + ((n % speed &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] piles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : piles)</span><br><span class="line">        max = Math.max(n, max);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先确定最小 speed 与最大 speed ，然后进行搜索。</li></ul><hr><p>二分可以完成判定子序列的任务，比如判断子串 <code>s</code> 中是否包含 <code>t</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分判断子串模板</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = t.length();</span><br><span class="line">    <span class="comment">// 对 t 进行预处理</span></span><br><span class="line">    ArrayList&lt;Integer&gt;[] index = <span class="keyword">new</span> ArrayList[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (index[c] == <span class="keyword">null</span>) </span><br><span class="line">            index[c] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        index[c].add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串 t 上的指针</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 借助 index 查找 s[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="comment">// 整个 t 压根儿没有字符 c</span></span><br><span class="line">        <span class="keyword">if</span> (index[c] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = left_bound(index[c], j);</span><br><span class="line">        <span class="comment">// 二分搜索区间中没有找到字符 c</span></span><br><span class="line">        <span class="keyword">if</span> (pos == index[c].size()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 向前移动指针 j</span></span><br><span class="line">        j = index[c].get(pos) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找左侧边界的二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(ArrayList&lt;Integer&gt; arr, <span class="keyword">int</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = arr.size();</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (tar &gt; arr.get(mid)) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重点是用一个字典 index 将每个字符出现的索引位置按顺序存储下来，然后二分搜索 index[c] 中比 j 大的那个索引，即左边界二分。</li></ul><h2 id="双指针技巧"><a href="#双指针技巧" class="headerlink" title="双指针技巧"></a>双指针技巧</h2><p>快慢指针都比较简单，比较难理解的是有环链表判断环起点。直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先找到快满指针相交点，然后任一一个从 head 开始，另一个继续向前，相遇点即环起点。</li></ul><p>此外左右指针在各种场景都要用：二分、反转数组、滑动窗口等。</p><hr><p>接雨水是双指针的一种应用，有一个数组表示柱子高度，求出这片柱子可以接住的雨水。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = height.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l_max = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> r_max = height[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        l_max = max(l_max, height[left]);</span><br><span class="line">        r_max = max(r_max, height[right]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ans += min(l_max, r_max) - height[i]</span></span><br><span class="line">        <span class="keyword">if</span> (l_max &lt; r_max) &#123;</span><br><span class="line">            ans += l_max - height[left];</span><br><span class="line">            left++; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += r_max - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于每一块柱子间，盛水应该是 <code>min(max(height[0..i]), max(height[i..end])) - height[i]</code> 。</li><li>现在的 <code>l_max</code> 和 <code>r_max</code> 不一定是当前 <code>i</code> 左右的最值，但是可以得到正确结果，因为我们已经知道 <code>l_max &lt; r_max</code> 了，至于这个 <code>r_max</code> 是不是右边最大的，不重要，重要的是 <code>height[i]</code> 能够装的水只和 <code>l_max</code> 有关。</li></ul><hr><p>快慢指针有一种应用是对有序数组、链表去重，慢指针从 0 开始，快指针从 1 开始，快指针向前如果与满指针对象不同，即满指针赋值并前进，当快指针到尾，慢指针前的全是不重复的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针去重模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] 无重复</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为索引 + 1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS-DFS"><a href="#BFS-DFS" class="headerlink" title="BFS / DFS"></a>BFS / DFS</h2><ul><li>DFS 本质上就是回溯算法。</li><li>BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多。</li><li>BFS 要解决的本质问题是在一幅「图」中找到从起点 <code>start</code> 到终点 <code>target</code> 的最近距离。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS 模板</span></span><br><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 上下左右四面的位置就是相邻节点；</li><li><code>visited</code> 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 <code>visited</code>。</li><li>DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。在找最 xxx 的点时，BFS 要优于 DFS 。相对的，DFS 空间复杂度低一些。</li><li>BFS 还可以双向，当然需要先知道 target ，但是时间复杂度还是 O(n) ，理论上是有优化的，写法类似，这里不写模板了。</li></ul><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>即一般意义上的堆，可以用数组表示一个堆，下面是大顶堆模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大顶堆模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">// 当前 Priority Queue 中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引 0 不用，所以多分配一个空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> Comparable[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入元素 e */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key e)</span> </span>&#123;</span><br><span class="line">        N++;</span><br><span class="line">        <span class="comment">// 先把新元素加到最后</span></span><br><span class="line">        pq[N] = e;</span><br><span class="line">        <span class="comment">// 然后让它上浮到正确的位置</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除并返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最大堆的堆顶就是最大元素</span></span><br><span class="line">        Key max = pq[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 把这个最大元素换到最后，删除之</span></span><br><span class="line">        exch(<span class="number">1</span>, N);</span><br><span class="line">        pq[N] = <span class="keyword">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">// 让 pq[1] 下沉到正确位置</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上浮第 k 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果浮到堆顶，就不能再上浮了</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(parent(k), k)) &#123;</span><br><span class="line">            <span class="comment">// 如果第 k 个元素比上层大</span></span><br><span class="line">            <span class="comment">// 将 k 换上去</span></span><br><span class="line">            exch(parent(k), k);</span><br><span class="line">            k = parent(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下沉第 k 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果沉到堆底，就沉不下去了</span></span><br><span class="line">        <span class="keyword">while</span> (left(k) &lt;= N) &#123;</span><br><span class="line">            <span class="comment">// 先假设左边节点较大</span></span><br><span class="line">            <span class="keyword">int</span> older = left(k);</span><br><span class="line">            <span class="comment">// 如果右边节点存在，比一下大小</span></span><br><span class="line">            <span class="keyword">if</span> (right(k) &lt;= N &amp;&amp; less(older, right(k)))</span><br><span class="line">                older = right(k);</span><br><span class="line">            <span class="comment">// 结点 k 比俩孩子都大，就不必下沉了</span></span><br><span class="line">            <span class="keyword">if</span> (less(older, k)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 否则，不符合最大堆的结构，下沉 k 结点</span></span><br><span class="line">            exch(k, older);</span><br><span class="line">            k = older;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交换数组的两个元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Key temp = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pq[i] 是否比 pq[j] 小？ */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左孩子的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右孩子的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里用到 Java 的泛型，<code>Key</code> 可以是任何一种可比较大小的数据类型，可以认为它是 int、char 等。</li><li>先要完成 <code>swim</code> 和 <code>sink</code> ，<code>insert</code> 和 <code>delMax</code> 是在此基础上的。</li><li>一个优先级队列就实现了，插入和删除元素的时间复杂度为 <code>O(logK)</code>，<code>K</code> 为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在 <code>sink</code> 或者 <code>swim</code> 上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 log 级别。</li></ul><h2 id="LRU-设计"><a href="#LRU-设计" class="headerlink" title="LRU 设计"></a>LRU 设计</h2><p>算是必考题，也要记录一下，最近访问过就移动到队伍头部，实际上就是设计 <code>get</code> 和 <code>put</code> 两个方法，限制是这两个方法的时间复杂度需要在 <code>O(1)</code> 。</p><p>哈希表查找快但是无序，链表插入快但是查找慢，因此结合一下，就是哈希链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key, val;</span><br><span class="line">        Node next, prev;</span><br><span class="line">    </span><br><span class="line">        Node(<span class="keyword">int</span> k, <span class="keyword">int</span> v) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = k;</span><br><span class="line">            <span class="keyword">this</span>.val = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node head, tail; <span class="comment">// 头尾虚节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 链表元素数</span></span><br><span class="line">    </span><br><span class="line">        DoubleList() &#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.prev = head;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在链表头部添加节点 x</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">            x.next = head.next;</span><br><span class="line">            x.prev = head;</span><br><span class="line">            head.next.prev = x;</span><br><span class="line">            head.next = x;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除链表中的 x 节点（x 一定存在）</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">            x.prev.next = x.next;</span><br><span class="line">            x.next.prev = x.prev;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除链表中最后一个节点，并返回该节点</span></span><br><span class="line">        <span class="function">Node <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (tail.prev == head)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node last = tail.prev;</span><br><span class="line">            remove(last);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回链表长度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key -&gt; Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(key).val;</span><br><span class="line">        <span class="comment">// 利用 put 方法把该数据提前</span></span><br><span class="line">        put(key, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先把新节点 x 做出来</span></span><br><span class="line">        Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 删除旧的节点，新的插到头部</span></span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            <span class="comment">// 更新 map 中对应的数据</span></span><br><span class="line">            map.put(key, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap == cache.size()) &#123;</span><br><span class="line">                <span class="comment">// LRU 的核心部分，删除链表最后一个数据</span></span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接添加到头部</span></span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            map.put(key, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本质上来说 LRU 就是一个双向链表和一个 map 来记录 key 与 val 的对应。</li></ul><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// root 需要做什么？在这做。</span></span><br><span class="line">    <span class="comment">// 其他的不用 root 操心，抛给框架</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉搜索树（Binary Search Tree，简称 BST）是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。</p><p>单纯上面的模板，写出的 BST 可能有坑，<strong>因为 root 需要做的不只是和左右子节点比较，而是要整个左子树和右子树所有节点比较</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 BST</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BST 操作模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BST 删除需要分三种情况：</span></span><br><span class="line"><span class="comment">// 无子节点、仅一个子节点、有两个子节点</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="comment">// 处理情况 3</span></span><br><span class="line">        TreeNode minNode = getMin(root.right);</span><br><span class="line">        root.val = minNode.val;</span><br><span class="line">        root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><ul><li>完全二叉树，Complete Binary Tree，每一层都是紧凑靠左排列的。</li><li>满二叉树，Perfect Binary Tree，是一种特殊的完全二叉树，每层都是是满的。</li><li>Full Binary Tree，一棵二叉树的所有节点要么没有孩子节点，要么有两个孩子节点。</li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200509130046.png" alt></p><p>计算完全二叉树的节点数，有一定的技巧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全二叉树节点数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode l = root, r = root;</span><br><span class="line">    <span class="comment">// 记录左、右子树的高度</span></span><br><span class="line">    <span class="keyword">int</span> hl = <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l = l.left;</span><br><span class="line">        hl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r = r.right;</span><br><span class="line">        hr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右子树的高度相同，则是一棵满二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (hl == hr) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, hl) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右高度不同，则按照普通二叉树的逻辑计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个算法的时间复杂度是 O(logN*logN) 。</li><li>乍一看复杂度应该是 O(N*logN) ，关键点在于 <code>return 1 + countNodes(root.left) + countNodes(root.right);</code> 这两个递归只有一个会真的递归下去，另一个一定会触发 hl == hr 而立即返回，不会递归下去。</li></ul><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>Next Greater Number 都可以用单调栈来处理。比如给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。比如：给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。</p><p>解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。</p><p>暴力就是 O(n^2) ，可以把问题抽象成排队，找到每一个元素后第一个比他高的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调栈模板</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(nums.size()); <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; <span class="comment">// 判定个子高矮</span></span><br><span class="line">            s.pop(); <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">-1</span> : s.top(); <span class="comment">// 这个元素身后的第一个高个</span></span><br><span class="line">        s.push(nums[i]); <span class="comment">// 进队，接受之后的身高判定吧！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂度只有 O(n)。</li><li>总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。</li><li>如果单调栈不只看右侧，是循环，则可以想象有两个数组组合，不用真把数组翻倍，循环体变化即可：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = nums.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n * <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">    <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n]) &#123; <span class="comment">// 判定个子高矮</span></span><br><span class="line">        s.pop(); <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans[i % n] = s.empty() ? <span class="number">-1</span> : s.top(); <span class="comment">// 这个元素身后的第一个高个</span></span><br><span class="line">    s.push(nums[i % n]); <span class="comment">// 进队，接受之后的身高判定吧！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>有些特殊的滑窗问题需要在 O(1) 的时间得到滑窗内的最大值，这个时候需要用『单调队列』来辅助了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; data; <span class="comment">// deque 是双端队列</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!data.empty() &amp;&amp; data.back() &lt; n) </span><br><span class="line">            data.pop_back();</span><br><span class="line">        data.push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data.front(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.empty() &amp;&amp; data.front() == n)</span><br><span class="line">            data.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 数组 nums 中每 k 个元素的最大值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// k 是窗口大小</span></span><br><span class="line">    MonotonicQueue window; <span class="comment">// 滑窗</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) &#123; <span class="comment">//先把窗口的前 k - 1 填满</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 窗口开始向前滑动</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">            res.push_back(window.max());</span><br><span class="line">            window.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// nums[i - k + 1] 就是窗口最后的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心点在于 <code>push</code> 的时候，把比当前小的元素都删除了，因此 <code>queue</code> 中的元素是从大到小排列的。</li><li>在 <code>pop</code> 的时候需要进行比较，是因为可能当前想要移除的元素已经被删除了，此时不用操作。</li><li>和单调栈同理，每个元素最多被 push_back 和 pop_back 一次，没有任何多余操作，所以整体的复杂度还是 O(N)。</li></ul><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表反转模板 递归</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode last = reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个模板直接理解比较困难，但是只要知道目的就可以很容易背下来，<code>reverse</code> 的作用是返回原本链表尾部的节点，因此最后返回的就是 <code>reverse</code> 的节点。</li></ul><p>如果仅仅反转前 n 个节点呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表反转前 n 个节点模板 递归</span></span><br><span class="line">ListNode successor = <span class="keyword">null</span>; <span class="comment">// 后驱节点</span></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseN</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line">    ListNode last = reverseN(head.next, n - <span class="number">1</span>);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">// 让反转之后的 head 节点和后面的节点连起来</span></span><br><span class="line">    head.next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>和完整的反转基本相同，这里不同的地方在于 <code>successor</code> 节点，它需要被 <code>head.next</code> 引用，后续的节点顺序不变。</li></ul><p>如果是反转一部分节点呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表反转部分节点模板 递归</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 相当于反转前 n 个元素</span></span><br><span class="line">        <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.next = reverseBetween(head.next, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于 <code>m = 1</code> 相当于反转前 <code>n</code> 个节点；</li><li>而当 <code>m != 1</code> 时，如果我们把 head 的索引视为 1，那么我们是想从第 m 个元素开始反转对吧；</li><li>如果把 head.next 的索引视为 1 呢？那么相对于 head.next 反转的区间应该是从第 m - 1 个元素开始的；</li><li>区别于迭代思想，这就是递归思想。</li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表反转模板 迭代</span></span><br><span class="line"><span class="comment">// 反转以 a 为头结点的链表</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode a)</span> </span>&#123;</span><br><span class="line">    ListNode pre, cur, nxt;</span><br><span class="line">    pre = <span class="keyword">null</span>; cur = a; nxt = a;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        <span class="comment">// 逐个结点反转</span></span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// 更新指针位置</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表反转区间模板 迭代</span></span><br><span class="line"><span class="comment">/** 反转区间 [a, b) 的元素，注意是左闭右开 */</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">    ListNode pre, cur, nxt;</span><br><span class="line">    pre = <span class="keyword">null</span>; cur = a; nxt = a;</span><br><span class="line">    <span class="comment">// while 终止的条件改一下就行了</span></span><br><span class="line">    <span class="keyword">while</span> (cur != b) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表反转 k 个一组模板 迭代</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 区间 [a, b) 包含 k 个待反转元素</span></span><br><span class="line">    ListNode a, b;</span><br><span class="line">    a = b = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="comment">// 不足 k 个，不需要反转，base case</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">    ListNode newHead = reverse(a, b);</span><br><span class="line">    <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">    a.next = reverseKGroup(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如何判断回文链表？一种思路是递归入栈，用后序遍历进行对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回文链表递归模板</span></span><br><span class="line"><span class="comment">// 左侧指针</span></span><br><span class="line">ListNode left;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">return</span> traverse(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">traverse</span><span class="params">(ListNode right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> res = traverse(right.next);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">    res = res &amp;&amp; (right.val == left.val);</span><br><span class="line">    left = left.next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归入栈判断回文链表的时间复杂度 <code>O(n)</code> 空间复杂度 <code>O(n)</code> 。</li></ul><p>如果用双指针可以有效降低空间复杂度，首先找到中点，然后将后半段链表进行反转，比较前半段和后半段链表即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回文链表双指针模板</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果fast指针没有指向null，说明链表长度为奇数，slow还要再前进一步</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>) slow = slow.next; </span><br><span class="line"></span><br><span class="line">    ListNode left = head;</span><br><span class="line">    ListNode right = reverse(slow);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表反转</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用位操作"><a href="#常用位操作" class="headerlink" title="常用位操作"></a>常用位操作</h2><ol><li>利用或操作 | 和空格将英文字符转换为小写（碰巧）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'a'</span> | <span class="string">' '</span>) = <span class="string">'a'</span></span><br><span class="line">(<span class="string">'A'</span> | <span class="string">' '</span>) = <span class="string">'a'</span></span><br></pre></td></tr></table></figure><ol><li>利用与操作 &amp; 和下划线将英文字符转换为大写（碰巧）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'b'</span> &amp; <span class="string">'_'</span>) = <span class="string">'B'</span></span><br><span class="line">(<span class="string">'B'</span> &amp; <span class="string">'_'</span>) = <span class="string">'B'</span></span><br></pre></td></tr></table></figure><ol><li>利用异或操作 ^ 和空格进行英文字符大小写互换（碰巧）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'d'</span> ^ <span class="string">' '</span>) = <span class="string">'D'</span></span><br><span class="line">(<span class="string">'D'</span> ^ <span class="string">' '</span>) = <span class="string">'d'</span></span><br></pre></td></tr></table></figure><ol><li>判断两个数是否异号（有用）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> f = ((x ^ y) &lt; <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> f = ((x ^ y) &lt; <span class="number">0</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol><li>交换两个数（没啥用）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line"><span class="comment">// 现在 a = 2, b = 1</span></span><br></pre></td></tr></table></figure><ol><li>加一（没啥用）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">n = -~n;</span><br><span class="line"><span class="comment">// 现在 n = 2</span></span><br></pre></td></tr></table></figure><ol><li>减一（没啥用）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">n = ~-n;</span><br><span class="line"><span class="comment">// 现在 n = 1</span></span><br></pre></td></tr></table></figure><ol><li>消除数字 n 的二进制表示中的最后一个 1（实用）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n&amp;(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><ul><li>判断一个数二进制中有多少 1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断一个数是不是 2 的指数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>; <span class="comment">// 如果是 2 进制，则最多只有 1 个 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串乘法"><a href="#字符串乘法" class="headerlink" title="字符串乘法"></a>字符串乘法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串乘法模板</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = num1.size(), n = num2.size();</span><br><span class="line">    <span class="comment">// 结果最多为 m + n 位数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(m + n, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 从个位数开始逐位相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> mul = (num1[i]-<span class="string">'0'</span>) * (num2[j]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="comment">// 乘积在 res 对应的索引位置</span></span><br><span class="line">            <span class="keyword">int</span> p1 = i + j, p2 = i + j + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 叠加到 res 上</span></span><br><span class="line">            <span class="keyword">int</span> sum = mul + res[p2];</span><br><span class="line">            res[p2] = sum % <span class="number">10</span>;</span><br><span class="line">            res[p1] += sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 结果前缀可能存的 0（未使用的位）</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; res.size() &amp;&amp; res[i] == <span class="number">0</span>)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="comment">// 将计算结果转化成字符串</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; res.size(); i++)</span><br><span class="line">        str.push_back(<span class="string">'0'</span> + res[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str.size() == <span class="number">0</span> ? <span class="string">"0"</span> : str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间调度"><a href="#区间调度" class="headerlink" title="区间调度"></a>区间调度</h2><p>区间有并集、交集、最多不相交等问题，这些都是找规律的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区间并集模板</span></span><br><span class="line"><span class="comment"># intervals 形如 [[1,3],[2,6]...]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(intervals)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> intervals: <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 按区间的 start 升序排列</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> intv: intv[<span class="number">0</span>])</span><br><span class="line">    res = []</span><br><span class="line">    res.append(intervals[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(intervals)):</span><br><span class="line">        curr = intervals[i]</span><br><span class="line">        <span class="comment"># res 中最后一个元素的引用</span></span><br><span class="line">        last = res[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> curr[<span class="number">0</span>] &lt;= last[<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 找到最大的 end</span></span><br><span class="line">            last[<span class="number">1</span>] = max(last[<span class="number">1</span>], curr[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 处理下一个待合并区间</span></span><br><span class="line">            res.append(curr)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>区间合并对于几个相交区间合并后的结果区间 x，x.start 一定是这些相交区间中 start 最小的，x.end 一定是这些相交区间中 end 最大的。</li><li>先定下 start ，如果有相交更新 end 位，如果没有相交如数组。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区间交集模板</span></span><br><span class="line"><span class="comment"># A, B 形如 [[0,2],[5,10]...]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intervalIntersection</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 双指针</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> j &lt; len(B):</span><br><span class="line">        a1, a2 = A[i][<span class="number">0</span>], A[i][<span class="number">1</span>]</span><br><span class="line">        b1, b2 = B[j][<span class="number">0</span>], B[j][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 两个区间存在交集</span></span><br><span class="line">        <span class="keyword">if</span> b2 &gt;= a1 <span class="keyword">and</span> a2 &gt;= b1:</span><br><span class="line">            <span class="comment"># 计算出交集，加入 res</span></span><br><span class="line">            res.append([max(a1, b1), min(a2, b2)])</span><br><span class="line">        <span class="comment"># 指针前进</span></span><br><span class="line">        <span class="keyword">if</span> b2 &lt; a2: j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:       i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>区间交集同样是规律问题，不存在交集是 <code>b2 &lt; a1 or a2 &lt; b1</code> 因此取反即 <code>b2 &gt;= a1 and a2 &gt;= b1</code> 。</li><li>如果交集区间是 <code>[c1,c2]</code>，那么 <code>c1=max(a1,b1)</code>，<code>c2=min(a2,b2)</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间最多不相交模板</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intvs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    Arrays.sort(intvs, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 排序后，第一个区间就是 x</span></span><br><span class="line">    <span class="keyword">int</span> x_end = intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从区间集合 <code>intvs</code> 中选择一个区间 <code>x</code>，这个 <code>x</code> 是在当前所有区间中结束最早的（<code>end</code> 最小）。</li><li>把所有与 <code>x</code> 区间相交的区间从区间集合 <code>intvs</code> 中删除。</li><li>重复步骤 1 和 2，直到 <code>intvs</code> 为空为止。之前选出的那些 x 就是最大不相交子集。</li></ul><h2 id="信封嵌套"><a href="#信封嵌套" class="headerlink" title="信封嵌套"></a>信封嵌套</h2><p>有一个数组都是二元组，二元组中每一位都比另一个二元组对应位大，才能完成嵌套。因此这不是单纯的最长递增子序列 LIS 问题，需要一定的变形。</p><p><strong>先对宽度 w 进行升序排序，如果遇到 w 相同的情况，则按照高度 h 降序排序。之后把所有的 h 作为一个数组，在这个数组上计算 LIS 的长度就是答案。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信封嵌套模板</span></span><br><span class="line"><span class="comment">// envelopes = [[w, h], [w, h]...]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = envelopes.length;</span><br><span class="line">    <span class="comment">// 按宽度升序排列，如果宽度一样，则按高度降序排列</span></span><br><span class="line">    Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? </span><br><span class="line">                b[<span class="number">1</span>] - a[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 对高度数组寻找 LIS</span></span><br><span class="line">    <span class="keyword">int</span>[] height = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        height[i] = envelopes[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lengthOfLIS(height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回 nums 中 LIS 的长度 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> piles = <span class="number">0</span>, n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 要处理的扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> poker = nums[i];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = piles;</span><br><span class="line">        <span class="comment">// 二分查找插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (top[mid] &gt;= poker)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == piles) piles++;</span><br><span class="line">        <span class="comment">// 把这张牌放到牌堆顶</span></span><br><span class="line">        top[left] = poker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 牌堆数就是 LIS 长度</span></span><br><span class="line">    <span class="keyword">return</span> piles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 四排算法四种写法</span></span><br><span class="line"><span class="comment">// 得到一个在闭区间 [min, max] 内的随机整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randInt</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length();</span><br><span class="line">    <span class="comment">/******** 区别只有这两行 ********/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 从 i 到最后随机选一个元素</span></span><br><span class="line">        <span class="keyword">int</span> rand = randInt(i, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*************************/</span></span><br><span class="line">        swap(arr[i], arr[rand]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">int</span> rand = randInt(i, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">int</span> rand = randInt(<span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种写法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">int</span> rand = randInt(<span class="number">0</span>, i);</span><br></pre></td></tr></table></figure><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>归并是分治算法的一种应用。分治算法的套路是<strong>分解 -&gt; 解决（触底）-&gt; 合并（回溯）</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不要在 merge 函数里构造新数组了，因为 merge 函数会被多次调用，影响性能</span></span><br><span class="line">    <span class="comment">// 直接一次性构造一个足够大的数组，简洁，高效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>; <span class="comment">// 对两个归并对象的起点指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">            aux[k] = a[k]; <span class="comment">// 归并前的原始顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>      (i &gt; mid)              &#123; a[k] = aux[j++]; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)               &#123; a[k] = aux[i++]; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) &#123; a[k] = aux[j++]; &#125;</span><br><span class="line">            <span class="keyword">else</span>                           &#123; a[k] = aux[i++]; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数判断"><a href="#素数判断" class="headerlink" title="素数判断"></a>素数判断</h2><p>返回区间 [2, n) 中有几个素数，一个高效的筛法主要需要关注循环体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 素数判断模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    Arrays.fill(isPrim, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) </span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) </span><br><span class="line">                isPrim[j] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因子是对称的，4x2 和 2x4 是一回事，因此外层循环用 <code>int i = 2; i * i &lt; n; i++</code> 。</li><li>4×2=8，4×3=12 等等数字已经被 i=2 和 i=3 的 2×4 和 3×4 标记了，因此内层循环应该从 ixi 开始遍历，即 <code>int j = i * i; j &lt; n; j += i</code> 。这里 <code>j += i</code> 是在找 <code>i</code> 的倍数。</li></ul><h2 id="高效模幂"><a href="#高效模幂" class="headerlink" title="高效模幂"></a>高效模幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span>;</span><br></pre></td></tr></table></figure><p>要求你的算法返回幂运算 a^b 的计算结果与 1337 取模（mod，也就是余数）后的结果。</p><p>这个问题分成三个小问题：数组转数字，如何进行模运算，如何高效模运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    a %= base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// k 是奇数</span></span><br><span class="line">        <span class="keyword">return</span> (a * mypow(a, k - <span class="number">1</span>)) % base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// k 是偶数</span></span><br><span class="line">        <span class="keyword">int</span> sub = mypow(a, k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (sub * sub) % base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = b.back();</span><br><span class="line">    b.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> part1 = mypow(a, last);</span><br><span class="line">    <span class="keyword">int</span> part2 = mypow(superPow(a, b), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 每次乘法都要求模</span></span><br><span class="line">    <span class="keyword">return</span> (part1 * part2) % base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于数组转数字， <code>a^1564 = a^4 * (a^156)^10</code> ，这就可以写成递归了。</li><li>对于模运算， <code>(a * b) % k = (a % k)(b % k) % k</code> ，将每一步都进行取模，就不会数值越界了。</li><li>对于快速幂， <code>a^b = a x a^(b-1) (b 为奇数) || (a^(b/2))^2 (b 为偶数)</code> ，也可以进行递归了。</li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>一种跳跃游戏是判断是否可以达到数组尾部，另一种跳跃游戏是得出到达数组尾部的最小步数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否达到尾部贪心</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> farthest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 不断计算能跳到的最远距离</span></span><br><span class="line">        farthest = max(farthest, i + nums[i]);</span><br><span class="line">        <span class="comment">// 可能碰到了 0，卡住跳不动了</span></span><br><span class="line">        <span class="keyword">if</span> (farthest &lt;= i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> farthest &gt;= n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种非常简单，用一个 <code>farthest</code> 变量就能说明问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 达到尾部最小步数贪心</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>, farthest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        farthest = max(nums[i] + i, farthest);</span><br><span class="line">        <span class="keyword">if</span> (end == i) &#123;</span><br><span class="line">            jumps++;</span><br><span class="line">            end = farthest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个需要一定的思考，时间复杂度 <code>O(N)</code> ，空间复杂度 <code>O(1)</code> ，很强。</li><li>i 和 end 标记了可以选择的跳跃步数，farthest 标记了所有选择 [i..end] 中能够跳到的最远距离，jumps 记录了跳跃次数。</li></ul><h2 id="随机抽数"><a href="#随机抽数" class="headerlink" title="随机抽数"></a>随机抽数</h2><p>洗牌是随机一个数组的顺序，随机抽数是遍历一遍链表，随机抽出一个数字，要求符合随机的要求，即抽出概率是 1/i ，1-1/i 的概率还是原来的选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机抽出 1 个数模板</span></span><br><span class="line"><span class="comment">/* 返回链表中一个随机节点的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="comment">// while 循环遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成一个 [0, i) 之间的整数</span></span><br><span class="line">        <span class="comment">// 这个整数等于 0 的概率就是 1/i</span></span><br><span class="line">        <span class="keyword">if</span> (r.nextInt(++i) == <span class="number">0</span>) &#123;</span><br><span class="line">            res = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机抽出 k 个数模板</span></span><br><span class="line"><span class="comment">/* 返回链表中 k 个随机节点的值 */</span></span><br><span class="line"><span class="keyword">int</span>[] getRandom(ListNode head, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    ListNode p = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前 k 个元素先默认选上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; p != <span class="keyword">null</span>; j++) &#123;</span><br><span class="line">        res[j] = p.val;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="comment">// while 循环遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成一个 [0, i) 之间的整数</span></span><br><span class="line">        <span class="keyword">int</span> j = r.nextInt(++i);</span><br><span class="line">        <span class="comment">// 这个整数小于 k 的概率就是 k/i</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            res[j] = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的两种做法是链表遍历一次，随机抽取数字，时间复杂度为 O(n) 。</li><li>如果不是链表场景，也可以对数组洗牌，取出前 k 个数。</li></ul><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的父节点是 parent[x] ，存储若干棵树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一开始互不连通</span></span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将 p 和 q 连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">        <span class="keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 两个分量合二为一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 判断 p 和 q 是否互相连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 返回某个节点 x 的根节点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            <span class="comment">// 进行路径压缩</span></span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 返回当前的连通分量个数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了合并 <code>union()</code> 时，树不出现头重脚轻，需要一个数组表示树的重量 <code>size</code> ，目的是让 union 后树依然拥有平衡性，而不会退化成链表，影响操作效率。</li><li><code>find()</code> 可能是一个线性的操作，因此需要进行路径压缩， <code>parent[x] = parent[parent[x]];</code> 很简单也很强大。可以这样理解，将 <code>parent[x]</code> 降级，降到和 <code>x</code> 一个水平，他们都指向 <code>parent[parent[x]]</code> ，路径压缩保证任意树的高度保持在常数，使得 <code>union()</code> 和 <code>connected()</code> API 时间复杂度为 O(1)。</li><li>用 <code>parent</code> 数组记录每个节点的父节点，相当于指向父节点的指针，所以 <code>parent</code> 数组内实际存储着一个森林（若干棵多叉树）。</li></ul><hr><p>UF 的应用有很多，比如判定合法等式，给你一个数组 equations，装着若干字符串表示的算式。每个算式 equations[i] 长度都是 4，而且只有这两种情况：a==b 或者 a!=b，其中 a,b 可以是任意小写字母。你写一个算法，如果 equations 中所有算式都不会互相冲突，返回 true，否则返回 false。</p><ul><li>比如说，输入 <code>[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</code>，算法返回 false，因为这三个算式不可能同时正确。</li><li>再比如，输入 <code>[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</code>，算法返回 true，因为这三个算式并不会造成逻辑冲突。</li></ul><p>用 UF 的思想就是：<strong>将 equations 中的算式根据 == 和 != 分成两部分，先处理 == 算式，使得他们通过相等关系各自勾结成门派；然后处理 != 算式，检查不等关系是否破坏了相等关系的连通性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UF 应用模板，判断合法等式</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 26 个英文字母</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(<span class="number">26</span>);</span><br><span class="line">    <span class="comment">// 先让相等的字母形成连通分量</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">'='</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">            uf.union(x - <span class="string">'a'</span>, y - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查不等关系是否打破相等关系的连通性</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">'!'</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 如果相等关系成立，就是逻辑冲突</span></span><br><span class="line">            <span class="keyword">if</span> (uf.connected(x - <span class="string">'a'</span>, y - <span class="string">'a'</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP-字符串匹配"><a href="#KMP-字符串匹配" class="headerlink" title="KMP 字符串匹配"></a>KMP 字符串匹配</h2><p>KMP 算法是在 <code>txt</code> 中查找子串 <code>pat</code>，如果存在，返回这个子串的起始索引，否则返回 -1。<code>pat</code> 表示模式串，长度为 <code>M</code>，<code>txt</code> 表示文本串，长度为 <code>N</code>。</p><p>KMP 算法永不回退 <code>txt</code> 的指针 <code>i</code>，不走回头路（不会重复扫描 <code>txt</code>），而是借助 <code>dp</code> 数组中储存的信息把 <code>pat</code> 移到正确的位置继续匹配。</p><p>KMP 算法的难点在于，如何计算 <code>dp</code> 数组中的信息？计算这个 <code>dp</code> 数组，只和 <code>pat</code> 串有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP 模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        <span class="comment">// 通过 pat 构建 dp 数组</span></span><br><span class="line">        <span class="comment">// 需要 O(M) 时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 借助 dp 数组去匹配 txt</span></span><br><span class="line">        <span class="comment">// 需要 O(N) 时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样做的目的，是为了做到这样的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KMP kmp = <span class="keyword">new</span> KMP(<span class="string">"aaab"</span>);</span><br><span class="line"><span class="keyword">int</span> pos1 = kmp.search(<span class="string">"aaacaaab"</span>); <span class="comment">//4</span></span><br><span class="line"><span class="keyword">int</span> pos2 = kmp.search(<span class="string">"aaaaaaab"</span>); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>这里的 <code>dp</code> 是状态的变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dp[j][c] = next</span><br><span class="line"><span class="comment">// 0 &lt;= j &lt; M，代表当前的状态</span></span><br><span class="line"><span class="comment">// 0 &lt;= c &lt; 256，代表遇到的字符（ASCII 码）</span></span><br><span class="line"><span class="comment">// 0 &lt;= next &lt;= M，代表下一个状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[4]['A'] = 3 表示：</span></span><br><span class="line"><span class="comment">// 当前是状态 4，如果遇到字符 A，</span></span><br><span class="line"><span class="comment">// pat 应该转移到状态 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[1]['B'] = 2 表示：</span></span><br><span class="line"><span class="comment">// 当前是状态 1，如果遇到字符 B，</span></span><br><span class="line"><span class="comment">// pat 应该转移到状态 2</span></span><br></pre></td></tr></table></figure><p>由此 <code>search()</code> 方法出来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length();</span><br><span class="line">    <span class="keyword">int</span> N = txt.length();</span><br><span class="line">    <span class="comment">// pat 的初始态为 0</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前是状态 j，遇到字符 txt[i]，</span></span><br><span class="line">        <span class="comment">// pat 应该转移到哪个状态？</span></span><br><span class="line">        j = dp[j][txt.charAt(i)];</span><br><span class="line">        <span class="comment">// 如果达到终止态，返回匹配开头的索引</span></span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没到达终止态，匹配失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dp</code> 初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pat = pat;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length();</span><br><span class="line">    <span class="comment">// dp[状态][字符] = 下个状态</span></span><br><span class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">256</span>];</span><br><span class="line">    <span class="comment">// base case 只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1</span></span><br><span class="line">    <span class="comment">// 遇到其它字符的话还是停留在状态 0</span></span><br><span class="line">    dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 影子状态 X 初始为 0</span></span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前状态 j 从 1 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">256</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat.charAt(j) == c) </span><br><span class="line">                dp[j][c] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="comment">// 交给最近的影子状态进行处理</span></span><br><span class="line">                dp[j][c] = dp[X][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新影子状态</span></span><br><span class="line">        X = dp[X][pat.charAt(j)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更新 X 其实和 search 函数中更新状态 j 的过程是非常相似。</li><li><code>j</code> 是在 <code>txt</code> 中匹配 <code>pat</code>，<code>X</code> 是在 <code>pat</code> 中匹配 <code>pat[1..end]</code>，状态 <code>X</code> 总是落后状态 <code>j</code> 一个状态，与 <code>j</code> 具有最长的相同前缀。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 笔记</title>
      <link href="/technology/2019-08-12-leetcode/"/>
      <url>/technology/2019-08-12-leetcode/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是我早就想干的一件事，leetcode 刷了很多，但是没有系统记录，就记录在这里吧。</p><ul><li>按顺序记录；</li><li>隐去如 Node 之类的内部类信息；</li></ul></blockquote><h2 id="2-Add-Two-Sum"><a href="#2-Add-Two-Sum" class="headerlink" title="2. Add Two Sum"></a>2. Add Two Sum</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode sentinel = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode d = sentinel;</span><br><span class="line">    ListNode c1 = l1;</span><br><span class="line">    ListNode c2 = l2;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c1 != <span class="keyword">null</span> || c2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (c1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += c1.val;</span><br><span class="line">            c1 = c1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += c2.val;</span><br><span class="line">            c2 = c2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        d.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        d = d.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum / <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        d.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sentinel.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Linked List</code></p><p>Thinking:</p><blockquote><p>这道题好在已经给出了链表的逆序，按位相加即可，把 sum 的个位保留，十位进位，注意最后如果十位还有数字，最多仅为 1 。</p></blockquote><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3. </span><br><span class="line"></span><br><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br><span class="line"></span><br><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 移入字符</span></span><br><span class="line">        Character c = s.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 更新滑窗</span></span><br><span class="line">        window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window.get(c).compareTo(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Character d = s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 更新滑窗</span></span><br><span class="line">            window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Two Pointers</code> <code>Sliding Window</code> <code>Hash Table</code> <code>String</code></p><p>Thinking:</p><blockquote><p>无重复最长子串问题，用滑窗比较好理解点。</p></blockquote><h2 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h2><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.length &gt; B.length) <span class="keyword">return</span> findMedianSortedArrays(B, A);</span><br><span class="line">    <span class="keyword">int</span> x = A.length;</span><br><span class="line">    <span class="keyword">int</span> y = B.length;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = x;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> partitionX = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> partitionY = (x + y + <span class="number">1</span>) / <span class="number">2</span> - partitionX;</span><br><span class="line">        <span class="keyword">int</span> maxLeftX = (partitionX == <span class="number">0</span>) ? Integer.MIN_VALUE : A[partitionX - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> minRightX = (partitionX == x) ? Integer.MAX_VALUE : A[partitionX];</span><br><span class="line">        <span class="keyword">int</span> maxLeftY = (partitionY == <span class="number">0</span>) ? Integer.MIN_VALUE : B[partitionY - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> minRightY = (partitionY == y) ? Integer.MAX_VALUE : B[partitionY];</span><br><span class="line">        <span class="keyword">if</span> (maxLeftX &lt;= minRightY &amp;&amp; maxLeftY &lt;= minRightX) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x + y) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">double</span>)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.max(maxLeftX, maxLeftY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxLeftX &gt; minRightY) &#123;</span><br><span class="line">            high = partitionX - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = partitionX + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Binary Search</code> <code>Divide and Conquer</code> <code>Array</code></p><p>Thinking:</p><blockquote><p>求两个数组的中位数。这里 i 是 partitionX，j 是 partitionY ，我们要做的就是找到 B[j-1] &lt;= A[i] &amp;&amp; A[i-1] &lt;= B[j] ，保证左边最大值小于右边最小值即可。</p><p>这里保证 A 长度小于 B 长度，是为了保证 j 不为负数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      left_part          |        right_part</span><br><span class="line">A[<span class="number">0</span>], A[<span class="number">1</span>], ..., A[i<span class="number">-1</span>]  |  A[i], A[i+<span class="number">1</span>], ..., A[m<span class="number">-1</span>]</span><br><span class="line">B[<span class="number">0</span>], B[<span class="number">1</span>], ..., B[j<span class="number">-1</span>]  |  B[j], B[j+<span class="number">1</span>], ..., B[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br><span class="line"></span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> begin, maxLen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        extendPalindrome(s, i, i);</span><br><span class="line">        extendPalindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendPalindrome</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxLen &lt; j - i - <span class="number">1</span>) &#123;</span><br><span class="line">        begin = i + <span class="number">1</span>;</span><br><span class="line">        maxLen = j - i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>String</code></p><p>Thinking:</p><blockquote><p>想法有点粗暴，<code>extendPalindrome</code> 方法的作用是找中心以 i j 为中心向两边扩展，而 i+1 是为了保证在数组长度为偶数时的适配性。</p></blockquote><h2 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h2><p>Implement <code>atoi</code> which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><ul><li>Only the space character <code>&#39; &#39;</code> is considered as whitespace character.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line"></span><br><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br><span class="line"></span><br><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br><span class="line"></span><br><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br><span class="line"></span><br><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chars.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>, base = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; chars.length &amp;&amp; chars[i] == <span class="string">' '</span>) i++;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; chars.length &amp;&amp; (chars[i] == <span class="string">'-'</span> || chars[i] == <span class="string">'+'</span>)) &#123;</span><br><span class="line">        sign = <span class="number">1</span> - (chars[i++] == <span class="string">'-'</span> ? <span class="number">1</span> : <span class="number">0</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; chars.length &amp;&amp; chars[i] &gt;= <span class="string">'0'</span> &amp;&amp; chars[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (base &gt; Integer.MAX_VALUE / <span class="number">10</span> || (base == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; chars[i] - <span class="string">'0'</span> &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sign &gt; <span class="number">0</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        base = base * <span class="number">10</span> + (chars[i++] - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign * base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Math</code> <code>String</code></p><p>Thinking:</p><blockquote><p>小模拟，把字符串变成数字，可以用最简单的 if 嵌套来做，我们知道 32 位的 int 是 2147483647 ，随意其实就是一个字符转数字的问题。注意数组越界即可。</p></blockquote><h2 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h2><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches zero or more of the preceding element.</span><br></pre></td></tr></table></figure><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><ul><li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li><li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;*&apos; means zero or more of the preceding element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j - <span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j] || dp[i][j + <span class="number">1</span>] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>String</code> <code>Dynamic Programming</code></p><p>Thinking:</p><blockquote><p>正则表达式的处理，用一个二维数组处理一下，leetcode 上的解答非常好，直接抄了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];</span><br><span class="line">2, If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];</span><br><span class="line">3, If p.charAt(j) == &apos;*&apos;: </span><br><span class="line">   here are two sub conditions:</span><br><span class="line">               1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty</span><br><span class="line">               2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;:</span><br><span class="line">                              dp[i][j] = dp[i-1][j]   //in this case, a* counts as multiple a </span><br><span class="line">                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a</span><br><span class="line">                           or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty</span><br></pre></td></tr></table></figure><h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h2><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line"></span><br><span class="line">The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left));</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) left++;</span><br><span class="line">        <span class="keyword">else</span> right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Two Pointer</code></p><p>Thinking:</p><blockquote><p>从题意知数组内容为每一条线的长度，所以设置两个指针左右逼近，逼近的一方为短的一方，贪心即可。</p></blockquote><h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h2><p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>PS: The solution set must not contain duplicate triplets.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">2</span> &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>, k = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] + nums[k] == target) &#123;</span><br><span class="line">                result.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line">                j++;</span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) j++;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[j] + nums[k] &gt; target) &#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Two Pointer</code></p><p>Thinking:</p><blockquote><p>求三数和的数组，且结果不重复。首先排序，可以先枚举第一个元素，然后剩下两个元素双指针枚举数组。</p></blockquote><h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h2><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p>PS: Given <em>n</em> will always be valid.</p><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode first = dummy;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Linked List</code> <code>Two Pointers</code></p><p>Thinking:</p><blockquote><p>删除链表中倒数第n个节点，两个指针一起跑，O(n)即可完成。</p></blockquote><h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h2><p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given <em>n</em> = 3, a solution set is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backTrack(result, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(List&lt;String&gt; list, String str, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">        list.add(str);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">        backTrack(list, str + <span class="string">"("</span>, open + <span class="number">1</span>, close, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (open &gt; close) &#123;</span><br><span class="line">        backTrack(list, str + <span class="string">")"</span>, open, close + <span class="number">1</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>String</code> <code>Backtracking</code></p><p>Thinking:</p><blockquote><p>既然是枚举就肯定躲不开回溯，有左括号的同时补上右括号。我们知道如果输入长度 n ，那么实际输出应该是 2n ，记得条件约束，加左括号是 ( &lt; n 时，加右括号是 ( &gt; ) 时。</p></blockquote><h2 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h2><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> partition(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">partition</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span> lists[start];</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        ListNode l1 = partition(lists, start, mid);</span><br><span class="line">        ListNode l2 = partition(lists, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = merge(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = merge(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Linked Lisk</code> <code>Divide and Conquer</code> <code>Heap</code></p><p>Thinking:</p><blockquote><p>要求是把多个链表合并成一个，可以容易想到归并，时间复杂度是 nlogk ，其中 k 是链表数，n 是节点数。</p></blockquote><h2 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a>29. Divide Two Integers</h2><p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p><p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p><p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>truncate(8.345) = 8</code> and <code>truncate(-2.7335) = -2</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 10/3 = truncate(3.33333..) = 3.</span><br><span class="line"></span><br><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br><span class="line">Explanation: 7/-3 = truncate(-2.33333..) = -2.</span><br></pre></td></tr></table></figure><ul><li>Both dividend and divisor will be 32-bit signed integers.</li><li>The divisor will never be 0.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function <strong>returns 231 − 1 when the division result overflows</strong>.</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide2</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">long</span> dvd = Math.abs((<span class="keyword">long</span>) dividend), dvs = Math.abs((<span class="keyword">long</span>) divisor);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = dividend &gt; <span class="number">0</span> ^ divisor &gt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (dvd &gt;= dvs) &#123;</span><br><span class="line">        <span class="keyword">long</span> temp = dvs, m = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp &lt;&lt; <span class="number">1</span> &lt;= dvd) &#123;</span><br><span class="line">            temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dvd -= temp;</span><br><span class="line">        ans += m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign == <span class="number">1</span> ? ans : -ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Math</code>  <code>Binary Search</code></p><p>Thinking:</p><blockquote><p>手动实现一个除法，我们知道<strong>任何一个正整数都可以用 2 的幂次方表示</strong>，可以以此进行递归。</p><p>比如被除数是 15 ，除数是 3 ，那么首先是 15 - 3 ，接着是 15 - 6 ，然后 15 - 12 ，到这里都符合 3 <em> n^k ，这里 n^k = 4 ，m 累计为 4 ，接着被除数变成 15 - 3 </em> 4 = 3 ，m 累计到 5 ，被除数为 0 &lt; 3 退出。</p></blockquote><h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> num = nums[mid];</span><br><span class="line">        <span class="keyword">if</span> ((nums[mid] &lt; nums[<span class="number">0</span>]) != (target &lt; nums[<span class="number">0</span>])) &#123;</span><br><span class="line">            num = target &lt; nums[<span class="number">0</span>] ? Integer.MIN_VALUE : Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; target) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; target) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Binary Search</code></p><p>Thinking:</p><blockquote><p>旋转数组获得指定元素下标，老二分了。</p><p>我们可以想象一下，假设有这样一个数组 <code>[12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</code></p><p>我们想要找 14 ，那么这个数组可以这样设置 <code>[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]</code></p><p>我们想要找 7 ，那么这个数组就这样设置 <code>[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</code></p><p>现在它就符合二分了，关键在于判断 nums[mid] 与 target 是否在同一侧，如果在同一侧，我们的 nums[mid] 自然就是有效的；如果不在同一侧，判断 target 的位置，target 在数组后半部分 nums[mid] 用 -inf ，反之用 inf 代替。</p></blockquote><h2 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a>34. Find First and Last Position of Element in Sorted Array</h2><p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p>If the target is not found in the array, return <code>[-1, -1]</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br><span class="line"></span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> start = firstGreaterEqual(nums, target);</span><br><span class="line">    <span class="keyword">if</span> (start == nums.length || nums[start] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, firstGreaterEqual(nums, target + <span class="number">1</span>) - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">firstGreaterEqual</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Binary Search</code></p><p>Thinking:</p><blockquote><p>不是单独找一个数字下标，而是找数字下标的区间，可以用二分做，两次二分，第一次找目标位置，第二次找下一个数字的前一位。</p></blockquote><h2 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36. Valid Sudoku"></a>36. Valid Sudoku</h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following rules</strong>:</p><ol><li>Each row must contain the digits <code>1-9</code> without repetition.</li><li>Each column must contain the digits <code>1-9</code> without repetition.</li><li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being </span><br><span class="line">    modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure><p>PS: </p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li><li>The given board contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li><li>The given board size is always <code>9x9</code>.</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    Set seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                String b = <span class="string">"("</span> + board[i][j] + <span class="string">")"</span>;</span><br><span class="line">                <span class="keyword">if</span> (!seen.add(i + b) </span><br><span class="line">                        || !seen.add(b + j) </span><br><span class="line">                        || !seen.add(i / <span class="number">3</span> + b + j / <span class="number">3</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Hash Table</code></p><p>Thinking:</p><blockquote><p>数独是否成立的判断，根据文意，每一个用例都是 9x9 ，行、列、块均不重复，简单用 O(n^3) 模拟一下。这里用 <code>(x)</code> 作为某一个数，前面放行数 n ，后面放列数 m ，即 <code>n(x)m</code> ，保证不重复即满足。</p></blockquote><h2 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a>41. First Missing Positive</h2><p>Given an unsorted integer array, find the smallest missing positive integer.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,0]</span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Input: [3,4,-1,1]</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本情况</span></span><br><span class="line">    <span class="keyword">int</span> contains = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        contains++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contains == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums = [1]</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 1 替换负数，0，</span></span><br><span class="line">    <span class="comment">// 和大于 n 的数</span></span><br><span class="line">    <span class="comment">// 在转换以后，nums 只会包含</span></span><br><span class="line">    <span class="comment">// 正数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      <span class="keyword">if</span> ((nums[i] &lt;= <span class="number">0</span>) || (nums[i] &gt; n))</span><br><span class="line">        nums[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用索引和数字符号作为检查器</span></span><br><span class="line">    <span class="comment">// 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`</span></span><br><span class="line">    <span class="comment">// 如果 nums[2] 是正数 表示数字 2 没有出现</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a = Math.abs(nums[i]);</span><br><span class="line">      <span class="comment">// 如果发现了一个数字 a - 改变第 a 个元素的符号</span></span><br><span class="line">      <span class="comment">// 注意重复元素只需操作一次</span></span><br><span class="line">      <span class="keyword">if</span> (a == n)</span><br><span class="line">        nums[<span class="number">0</span>] = - Math.abs(nums[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        nums[a] = - Math.abs(nums[a]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在第一个正数的下标</span></span><br><span class="line">    <span class="comment">// 就是第一个缺失的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code></p><p>Thinking:</p><blockquote><p>找到数组中第一个缺失的正数。把负数和大于范围的数字都赋值1，nums[0] 表示的是第 n 个数，遍历第一个正数即缺失的数。</p></blockquote><h2 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h2><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &lt;= b) &#123;</span><br><span class="line">        leftMax = Math.max(leftMax, height[a]);</span><br><span class="line">        rightMax = Math.max(rightMax, height[b]);</span><br><span class="line">        <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">            max += (leftMax - height[a]);</span><br><span class="line">            a++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max += (rightMax - height[b]);</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Two Pointers</code> <code>Stack</code></p><p>Thinking:</p><blockquote><p>给一个数组，每一个值表示坐标上的高度，算出当前数组最多的储水总量。保持左右两个指针，同时记录左右的最高高度，两边低的部分向中心移动，同时计算漏出水的体积（底为 1 ），直到两个指针相遇，即填充了整个容器。</p></blockquote><h2 id="44-Wildcard-Matching"><a href="#44-Wildcard-Matching" class="headerlink" title="44. Wildcard Matching"></a>44. Wildcard Matching</h2><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;?&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;*&apos; matches any sequence.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;cb&quot;</span><br><span class="line">p = &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &apos;?&apos; matches &apos;c&apos;, but the second letter is &apos;a&apos;, which does not match &apos;b&apos;.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;adceb&quot;</span><br><span class="line">p = &quot;*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The first &apos;*&apos; matches the empty sequence, while the second &apos;*&apos; matches the substring &quot;dce&quot;.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;acdcb&quot;</span><br><span class="line">p = &quot;a*c?b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, p = <span class="number">0</span>, match = <span class="number">0</span>, starIdx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s &lt; str.length())&#123;</span><br><span class="line">      <span class="comment">// advancing both pointers</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; pattern.length()  &amp;&amp; (pattern.charAt(p) == <span class="string">'?'</span> || str.charAt(s) == pattern.charAt(p)))&#123;</span><br><span class="line">            s++;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// * found, only advancing pattern pointer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            starIdx = p;</span><br><span class="line">            match = s;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// last pattern pointer was *, advancing string pointer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (starIdx != -<span class="number">1</span>)&#123;</span><br><span class="line">            p = starIdx + <span class="number">1</span>;</span><br><span class="line">            match++;</span><br><span class="line">            s = match;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//current pattern pointer is not star, last patter pointer was not *</span></span><br><span class="line">        <span class="comment">//characters do not match</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//check for remaining characters in pattern</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)</span><br><span class="line">      p++;</span><br><span class="line">    <span class="keyword">return</span> p == pattern.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>String</code> <code>Dynamic Programming</code> <code>Backtracking</code> <code>Greedy</code></p><p>Thinking:</p><blockquote><p>将 p 与 s 将两个串扫一遍，如果 * 则 p 动，此时如果 s 和 p 后面的值不同则 s 动，将两个串移到最后，如果 p 走完说明匹配上了。</p></blockquote><h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">        backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tempList.size() == nums.length) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tempList.contains(nums[i])) &#123;</span><br><span class="line">                    <span class="comment">// element already exists, skip</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tempList.add(nums[i]);</span><br><span class="line">                backtrack(list, tempList, nums);</span><br><span class="line">                tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Backtracking</code></p><p>Thinking:</p><blockquote><p>算一个数组的全排列，这个是递归的套路题，递归函数需要：return 内容、当前排列、排列元素。然后去重、增加当前排列、递归、回溯。</p></blockquote><h2 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. Rotate Image</h2><p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix = </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// reverse matrix</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = matrix[begin];</span><br><span class="line">        matrix[begin] = matrix[end];</span><br><span class="line">        matrix[end] = temp;</span><br><span class="line">        begin++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// swap i j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code></p><p>Thinking:</p><blockquote><p>将一个 n*n 的矩阵顺时针旋转 90° ，有一种通用的解法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1 2 3     7 8 9     7 4 1</span><br><span class="line">&gt; 4 5 6  =&gt; 4 5 6  =&gt; 8 5 2</span><br><span class="line">&gt; 7 8 9     1 2 3     9 6 3</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>首先把每一行的顺序逆序排列，再将每一个元素的 i j 交换即可。</p></blockquote><h2 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h2><p>Given an array of strings, group anagrams together.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>All inputs will be in lowercase.</li><li>The order of your output does not matter.</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            chars[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        String keyStr = Arrays.toString(chars);</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(keyStr)) &#123;</span><br><span class="line">            map.put(keyStr, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(keyStr).add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Hash Table</code> <code>String</code></p><p>Thinking:</p><blockquote><p>把数组中排列的字符串分类输出。将每一个字符串用 <code>char[26]</code> 保存每一组的 key ，用 map 保存每一组，最后用 <code>map.values</code> 输出所有组。</p></blockquote><h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h2><p>Implement pow(x, n), which calculates x raised to the power n (x^n).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br><span class="line"></span><br><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br><span class="line"></span><br><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><ul><li>-100.0 &lt; x &lt; 100.0</li><li>n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1]</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        N = -N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> currentProduct = x;</span><br><span class="line">    <span class="comment">// 快速幂</span></span><br><span class="line">    <span class="comment">// /2 = 向右平移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = N; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans *= currentProduct;</span><br><span class="line">        &#125;</span><br><span class="line">        currentProduct *= currentProduct;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Math</code> <code>Binary Search</code></p><p>Thinking:</p><blockquote><p>题面很简单，计算 x 的 n 次幂。<br>如果 n &lt; 0 ，则将 x 变为 1/x ，同时 n 变为 -n ，简化问题。<br>快速幂，把每一个数字想象成 2 进制，只有 1 的位置需要计算。</p></blockquote><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Divide and Conquer</code> <code>Dynamic Programming</code></p><p>Thinking:</p><blockquote><p>求最大子序和，用 dp 反而简单点，用一个 ans 和一个 temp sum 两个值判断，如果 temp sum &gt; 0 就累加当前值，否则 temp sum 重新从当前位置开始取值，同时 ans 一直取 temp sum 与 ans 中的较大值。</p></blockquote><h2 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a>54. Spiral Matrix</h2><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> R = matrix.length, C = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">    <span class="comment">// 右、下、左、上 顺时针</span></span><br><span class="line">    <span class="keyword">int</span>[] dr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dc = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, di = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R * C; ++i) &#123;</span><br><span class="line">        ans.add(matrix[r][c]);</span><br><span class="line">        seen[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> cr = r + dr[di];</span><br><span class="line">        <span class="keyword">int</span> cc = c + dc[di];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc]) &#123;</span><br><span class="line">            r = cr;</span><br><span class="line">            c = cc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            di = (di + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            r += dr[di];</span><br><span class="line">            c += dc[di];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code></p><p>Thinking:</p><blockquote><p>输出螺旋矩阵，模拟过程即可。假设有 R 行 C 列，当前位置为 (r, c) ，前进方向是 di ，下一个位置是 (cr, cc) ，如果该没位置没有被访问过则进入，否则前进防线顺时针旋转 90 度。</p></blockquote><h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><ul><li>1 &lt;= nums.length &lt;= 3 * 10^4</li><li>0 &lt;= nums[i][j] &lt;= 10^5</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        k = Math.max(k, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Greedy</code></p><p>Thinking:</p><blockquote><p>从数组的第一个位置起跳，每个数字代表可以跳跃最远的距离，判断是否可以到达数组的最后。<br>如果某一个位置是 3 ，那么后面 3 个位置都能作为起跳点，可以尝试从每一个起跳点，保存可以跳到最远的地方。能唱过当前下标即成功。</p></blockquote><h2 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h2><p>Given a collection of intervals, merge all overlapping intervals.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br><span class="line"></span><br><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">// 起始位置排序</span></span><br><span class="line">    Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="number">0</span>] - v2[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 遍历区间</span></span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">        <span class="comment">// 如果结果数组是空的，或者当前区间的起始位置 &gt; 结果数组中最后区间的终止位置，</span></span><br><span class="line">        <span class="comment">// 则不合并，直接将当前区间加入结果数组。</span></span><br><span class="line">        <span class="keyword">if</span> (idx == -<span class="number">1</span> || res[idx][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">            res[++idx] = interval;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[idx][<span class="number">1</span>] = Math.max(res[idx][<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消除多余的长度</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(res, idx + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Sort</code></p><p>Thinking:</p><blockquote><p>合并数组的重合部分，重合只有三种情况，第一种互不相交，第二种部分相交，第三种完全包含。第一种情况时只需要把这一部分的 interval 加入，另外两种情况处理方法完全相同。</p></blockquote><h2 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down</span><br><span class="line">2. Right -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Right</span><br><span class="line"></span><br><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><ul><li>1 &lt;= m, n &lt;= 100</li><li>It’s guaranteed that the answer will be less than or equal to 2 * 10 ^ 9.</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">// 第一行第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Dynamic Programming</code></p><p>Thinking:</p><blockquote><p>在 m*n 的网格里，从左上角到右下角所有的路径。有两种解法，因为固定左上到右下所以向右和向下的次数是固定的，因此可以得到公式，并不通用；通过动态规划可以知道，为了达到位置 (i,j) 方式有从 (i-1,j) 和 (i,j-1) 两种，即 dp(i,j)=dp(i-1,j)+dp(i,j-1) 。</p></blockquote><h2 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a>66. Plus One</h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p><p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p><p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line"></span><br><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        digits[i]++;</span><br><span class="line">        digits[i] %= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">    digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code></p><p>Thinking:</p><blockquote><p>字面意思的数组数字加一，唯一需要注意的就是可能数组长度要变。</p></blockquote><h2 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a>69. Sqrt(x)</h2><p>Implement int sqrt(int x).</p><p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p><p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> right = x / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">long</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> square = mid * mid;</span><br><span class="line">        <span class="keyword">if</span> (square &gt; x) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Math</code> <code>Binary Search</code></p><p>Thinking:</p><blockquote><p>给 x 开根号，取最近值的下限，用二分即可，这里的二分是 jdk 的二分可以背下来， &gt;&gt;&gt; 不用担心 left + right 数值越界。</p></blockquote><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given n will be a positive integer.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Dynamic Programming</code></p><p>Thinking:</p><blockquote><p>爬楼梯，一次爬 1 节或 2 节，问爬完的方式有多少种。可以爆破， (i,n)=(i+1,n)+(i+2,n) ， i 表示当前阶数， n 表示目标阶数。用 dp 表示即 dp[i] = dp[i-1]+dp[i-2] 。</p></blockquote><h2 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73. Set Matrix Zeroes"></a>73. Set Matrix Zeroes</h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>A straight forward solution using O(mn) space is probably a bad idea.</li><li>A simple improvement uses O(m + n) space, but still not the best solution.</li><li>Could you devise a constant space solution?</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> firstCol = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            firstCol = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[i].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[i].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 补第一行</span></span><br><span class="line">    <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 补第一列</span></span><br><span class="line">    <span class="keyword">if</span> (firstCol) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code></p><p>Thinking:</p><blockquote><p>矩阵中如果某一个 (i,j) 为 0 ，另 i 行与 j 列都为 0 。如果分别记录 i 和 j ，那么空间复杂度肯定不是 O(1) ；而如果是找到 (i,j) 为 0 ，立即修改矩阵，那么空间复杂度又不仅仅是 O(m*n) ；因此，最好的办法是只标记一个位置，比如第一行第一列，然后统一处理。</p><p>特殊的地方在于第一行和第一列，第一行的 [0,0] 是第一行的标记，这里要单独判断，此外第一列没有额外的位置来说明第一列是否全 0 ，需要用一个标志位来判断。</p></blockquote><h2 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a>75. Sort Colors</h2><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p>Note: You are not suppose to use the library’s sort function for this problem.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><ul><li>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</li><li>Could you come up with a one-pass algorithm using only constant space?</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p0 = <span class="number">0</span>, p2 = nums.length - <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= p2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] == <span class="number">0</span>) &#123;</span><br><span class="line">            temp = nums[p0];</span><br><span class="line">            nums[p0] = nums[cur];</span><br><span class="line">            nums[cur] = temp;</span><br><span class="line">            p0++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[cur] == <span class="number">2</span>) &#123;</span><br><span class="line">            temp = nums[p2];</span><br><span class="line">            nums[p2] = nums[cur];</span><br><span class="line">            nums[cur] = temp;</span><br><span class="line">            p2--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Array</code> <code>Sort</code> <code>Two Pointers</code></p><p>Thinking:</p><blockquote><p>荷兰国旗问题，原地排序，顺序是 0 1 2 。我们用三个指针（p0, p2 和curr）来分别追踪 0 的最右边界，2 的最左边界和当前考虑的元素。</p><p>本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。</p><p>值得注意的是如果和 p2 交换， cur 是不需要移动的。</p></blockquote><h2 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br></pre></td></tr></table></figure><ul><li>If there is no such window in S that covers all characters in T, return the empty string “”.</li><li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;(), window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录匹配串</span></span><br><span class="line">    <span class="keyword">for</span> (Character c : t.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 移入字符</span></span><br><span class="line">        Character c = s.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 更新滑窗</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="comment">// 输出时的位置记录</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            Character d = s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 更新滑窗</span></span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(start, start + len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p>Thinking:</p><blockquote><p>找到 S 中全覆盖 T 的最小子串。</p><p>滑动窗口，[left,right) 被称为一个窗口。初始化 left = right = 0 。</p><p>第一步：先不断移动 right ，包含住所有的 T ；</p><p>第二步：接着不断移动 left 缩小窗口，直到窗口不再包含完整 T ；</p><p>重复第一步和第二步，不断找到解并优化解。</p><p>下面是滑窗问题的通用模板。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>模板中的 window 和 need 两个哈希表，记录窗口中的字符和需要凑齐的字符；</p><p>然后，使用 left 和 right 变量初始化窗口的两端，不要忘了，区间 [left, right) 是左闭右开的，所以初始情况下窗口没有包含任何元素；</p><p>其中 valid 变量表示窗口中满足 need 条件的字符个数，如果 valid 和 need.size 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 T 。</p></blockquote><h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h2><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>Note: A leaf is a node with no children.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">return its minimum depth = 2.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minStep = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">            TreeNode node = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                minStep = Math.min(minStep, step);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minStep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Tree</code> <code>Depth-first Search</code> <code>Breadth-first Search</code></p><p>Thinking:</p><blockquote><p>找二叉树最短路径，BFS 带走。</p></blockquote><h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>1 &lt;= k &lt;= nums.length</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3</span><br><span class="line">Output: [3,3,5,5,6,7] </span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    TempQueue() &#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!data.isEmpty() &amp;&amp; data.getLast() &lt; n) &#123;</span><br><span class="line">            data.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        data.addLast(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty() &amp;&amp; data.getFirst() == n) &#123;</span><br><span class="line">            data.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"TempQueue&#123;"</span>);</span><br><span class="line">        sb.append(<span class="string">"data="</span>).append(data);</span><br><span class="line">        sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    TempQueue window = <span class="keyword">new</span> TempQueue();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">            res[index++] = window.max();</span><br><span class="line">            window.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Heap</code> <code>Sliding Window</code></p><p>Thinking:</p><blockquote><p>滑窗问题，要求操作时间为 O(1) ，用单调队列即可。</p></blockquote><h2 id="438-Find-All-Anagrams-in-a-String"><a href="#438-Find-All-Anagrams-in-a-String" class="headerlink" title="438. Find All Anagrams in a String"></a>438. Find All Anagrams in a String</h2><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.</p><p>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</p><p>The order of output does not matter.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;(), need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character c : p.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 填充</span></span><br><span class="line">        Character c = s.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 处理滑窗</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (need.get(c).equals(window.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size() &amp;&amp; right - left &gt;= p.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left == p.length()) &#123;</span><br><span class="line">                res.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理滑窗</span></span><br><span class="line">            Character d = s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (need.get(d).equals(window.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Hash Table</code></p><p>Thinking:</p><blockquote><p>在 s 中找到所有 p 的异位词起始下标。比如 cba 是 abc 的异位词。看到两个串匹配就是滑窗可以解决的问题。</p></blockquote><h2 id="567-Permutation-in-String"><a href="#567-Permutation-in-String" class="headerlink" title="567. Permutation in String"></a>567. Permutation in String</h2><p>Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br><span class="line"></span><br><span class="line">Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><ul><li>The input strings only contain lower case letters.</li><li>The length of both given strings is in range [1, 10,000].</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;(), window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character c : s1.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s2.length()) &#123;</span><br><span class="line">        <span class="comment">// 填充</span></span><br><span class="line">        Character c = s2.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 更新滑窗</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (need.get(c).equals(window.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left == s1.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Character d = s2.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 更新滑窗</span></span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (need.get(d).equals(window.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Two Pointer</code> <code>Sliding Window</code></p><p>Thinking:</p><blockquote><p>判断 s2 中是否包含 s1 的排列，又是一道滑窗。</p></blockquote><h2 id="752-Open-the-Lock"><a href="#752-Open-the-Lock" class="headerlink" title="752. Open the Lock"></a>752. Open the Lock</h2><p>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’. The wheels can rotate freely and wrap around: for example we can turn ‘9’ to be ‘0’, or ‘0’ to be ‘9’. Each move consists of turning one wheel one slot.</p><p>The lock initially starts at ‘0000’, a string representing the state of the 4 wheels.</p><p>You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.</p><p>Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.</span><br><span class="line">Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,</span><br><span class="line">because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.</span><br><span class="line"></span><br><span class="line">Input: deadends = [&quot;8888&quot;], target = &quot;0009&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.</span><br><span class="line"></span><br><span class="line">Input: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">We can&apos;t reach the target without getting stuck.</span><br><span class="line"></span><br><span class="line">Input: deadends = [&quot;0000&quot;], target = &quot;8888&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><ul><li>The length of deadends will be in the range [1, 500].</li><li>target will not be in the list deadends.</li><li>Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities ‘0000’ to ‘9999’.</li></ul><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(deadends));</span><br><span class="line">    q.offer(<span class="string">"0000"</span>);</span><br><span class="line">    visited.add(<span class="string">"0000"</span>);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (deads.contains(cur)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(target)) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(up)) &#123;</span><br><span class="line">                    q.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(down)) &#123;</span><br><span class="line">                    q.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">plusOne</span><span class="params">(String str, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (ch[j] == <span class="string">'9'</span>) &#123;</span><br><span class="line">        ch[j] = <span class="string">'0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ch[j] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">minusOne</span><span class="params">(String str, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (ch[j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        ch[j] = <span class="string">'9'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ch[j] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag:</p><p><code>Breadth-first Search</code></p><p>Thinking:</p><blockquote><p>BFS 套一下，简单题，注意加一减一的时候 9 和 0 的变化。</p></blockquote><h2 id="Name"><a href="#Name" class="headerlink" title="#. Name"></a>#. Name</h2><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Tag:</p><p>Thinking:</p><blockquote></blockquote><h2 id="Name-1"><a href="#Name-1" class="headerlink" title="#. Name"></a>#. Name</h2><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Tag:</p><p>Thinking:</p><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件小记</title>
      <link href="/technology/2019-07-11-java-distributed-sysmte-chapter6/"/>
      <url>/technology/2019-07-11-java-distributed-sysmte-chapter6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-消息中间件的价值"><a href="#1-消息中间件的价值" class="headerlink" title="1. 消息中间件的价值"></a>1. 消息中间件的价值</h2><p>传统意义上来说，消息中间件为我们带来了异步的特性，同时解耦了系统。</p><p>假设我们做一个登录系统，那么可能需要有短信服务、安全系统…等等，这让系统变得越来越复杂，我们从新考虑可以发现，登录系统只要判断用户名和密码，而其他能力与原系统应该是可解耦的部分，因此通过消息中间件来解耦，我们不用关心有多少系统知道登录这件事，我们现在需要保证仅仅是一个消息发送到消息中间件，当然我们可以这样做：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200412230852.png" alt></p><p>通过数据库的记录，我们可以保证一条登录消息一定被消费，登录系统负责写，用到这个状态的系统自己来查，杜宇感知状态的应用还需要对数据库轮询，这是一种解决但是比较简单，同时问题也比较多：增加业务数据库负担、依赖复杂且不安全、扩展性不好。</p><h2 id="2-互联网时代的消息中间件"><a href="#2-互联网时代的消息中间件" class="headerlink" title="2. 互联网时代的消息中间件"></a>2. 互联网时代的消息中间件</h2><h3 id="2-1-发送一致性"><a href="#2-1-发送一致性" class="headerlink" title="2.1 发送一致性"></a>2.1 发送一致性</h3><p>所谓发送一致性是说<strong>产生消息的业务动作与消息发送的一致</strong>。如果业务操作成功，那么这个操作产生的消息一定发送，否则消息丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 业务操作</span></span><br><span class="line">  <span class="comment">// DB 、调用服务等</span></span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fool2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="comment">// 业务操作</span></span><br><span class="line">  <span class="comment">// DB 、调用服务等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可能会有这两种的操作，但是都是不可靠的，这两种方式都不能选择。</p><p>在 JMS 中我们一般是这样发送消息的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory -&gt; Connection -&gt; Session -&gt; Message</span><br><span class="line">Destination + Session -&gt; MessageProducer</span><br><span class="line">Destination + Session -&gt; MessageConsumer</span><br></pre></td></tr></table></figure><p>同时在 JMS 中的<strong>发送消息与业务操作之间事务保证</strong>是用 XA 系列接口保证的，这增加了复杂性，同时要求业务操作的资源必须支持 XA 协议。</p><p>我们需要一种方案对正常流程影响尽可能小：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200413162419.png" alt></p><ol><li>业务应用首先把消息发送给消息中间件，标记状态为<strong>待处理</strong>；</li><li>消息中间件存储消息，并不投递该消息；</li><li>消息中间件返回该消息已经入库，结果成功或失败；</li><li>业务应用收到结果处理：<ol><li>如果失败，则放弃业务处理，结束；</li><li>如果成功，则进行业务处理。</li></ol></li><li>业务处理完成，把处理结果发送给消息中间件；</li><li>消息中间件收到业务处理结果，根据结果处理：<ol><li>如果业务失败，则删除消息存储的的信息，结束；</li><li>如果消息成功，把消息存储的状态改为<strong>可发送</strong>，调度进行消息投递。</li></ol></li></ol><p>开始考虑上述 6 步，最后 2 步是可能出现『不一致』的，如果第 5 步出现问题，那么消息中间件不知道怎样处理该消息；如果第 6 步没有更新状态，也没有了下一步操作。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200413163513.png" alt></p><p>梳理异常情况可以找到以下 3 种状态：</p><ul><li>业务操作未进行，消息未存储；</li><li>业务操作未进行，消息已存储，状态为待处理；</li><li>业务操作已进行，消息已存储，状态为待处理。</li></ul><p>这三种状态中第一种不需要额外处理，另外两种需要根据业务操作的结果来处理。</p><p>这里有补偿流程：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200415155124.png" alt></p><ol><li>由消息中间件主动询问业务应用获取待处理消息对应的业务操作的结果；</li><li>业务应用对业务操作进行结果查询；</li><li>业务应用将业务结果发送到消息中间件（失败、成功、等待）；</li><li>消息中间件根据业务应用返回结果更新消息状态。</li></ol><p>这里的 4 步操作是为了确认业务处理操作的结果，前面 3 步失败便失败，最后一步如果失败进行重试即可。</p><p>将正向和反向流程结合就是解决业务操作与发送消息一致性的方案了。</p><p>正向角度来看我们仅仅是增加了一次网络操作与一次更新 DB 的操作，开销并不大，而且还能优化。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200415155707.png" alt></p><p>一致性方案下的业务代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">postMessage</span><span class="params">(Message, PostMessageCallback)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 发送消息到消息中间件</span></span><br><span class="line">  <span class="comment">// 获取返回结果</span></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> FAIL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进行业务操作</span></span><br><span class="line">  <span class="comment">// 获取业务操作结果</span></span><br><span class="line">  <span class="comment">// 发送业务操作结果到消息中间件</span></span><br><span class="line">  <span class="comment">// 返回处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发中处理提供发送一致性的消息外，还应该提供一个传统的发送消息的接口，为了适应其他场景，也会提供独立的接口把流程的控制权交给业务应用自身。</p><h3 id="2-2-消息中间件与使用者的强依赖"><a href="#2-2-消息中间件与使用者的强依赖" class="headerlink" title="2.2 消息中间件与使用者的强依赖"></a>2.2 消息中间件与使用者的强依赖</h3><p>在一致性的要求下，可能消息中间件会成为业务系统的强依赖，为了解决这个问题有三种思路：</p><ol><li>提供消息中间件系统的可靠性，但是不是 100% 可靠；</li><li>对于消息中间件系统中影响业务操作的部分，使其可靠性与业务自身的可靠性相同；</li><li>提供弱依赖支持。</li></ol><p>第一种方案中既然不能 100% 保证，自然不能入选；第二种方案中『相同的可靠性』就是保证业务能成功就需要消息能够入库；结合第二点和第三点可以得出如下架构：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200415160604.png" alt></p><p>现在消息表、业务表在一块，写入消息作为一个本地事务来完成，然后通知消息中间件有消息可以发送了，这就处理了一致性问题。</p><blockquote><p>虚线表示这是一个不必要的操作、依赖。消息中间件轮询业务数据库，找到需要发送的消息，取出消息发送即可。</p></blockquote><p>这样做有以下三点问题：</p><ol><li>业务数据库承载消息数据；</li><li>消息中间件访问业务数据库；</li><li>业务操作的数据库能支持消息中间件的需求。</li></ol><p>我们进行一定的变通，可以让消息中间件的轮询操作也由业务应用完成，让消息中间件不与业务应用直接打交道。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200415161031.png" alt></p><p>绝大部分问题解决了，但是这样架构需要业务操作是支持事务的数据库操作，具有一定的局限性。</p><p>更改思路是：可以将本地磁盘作为存储消息的地方，等待消息回复后再把消息发送给消息中间件，所有投递、重试等管理仍然在消息中间件中进行，本地磁盘作为业务应用上发送消息一定成功的一个保证。</p><p><img src="/Users/ronnie/Library/Application Support/typora-user-images/image-20200415161417881.png" alt="image-20200415161417881"></p><p>风险是：如果消息中间件不可用，并且本地磁盘坏了，那么消息就彻底丢失了。从业务数据上进行消息补发是最彻底的容灾手段。</p><p>将本地磁盘作为消息存储的方式有两种做法：</p><ol><li>作为一致性发送消息的解决方案的容灾手段，平时不用，只有出问题了才切换到这种方式；</li><li>直接使用该方式，可以控制业务操作本身调用发送消息的接口的处理时间，此外也有机会在业务应用与消息中间件之间做一些批处理的工作。</li></ol><h3 id="2-3-消息模型对消息接收的影响"><a href="#2-3-消息模型对消息接收的影响" class="headerlink" title="2.3 消息模型对消息接收的影响"></a>2.3 消息模型对消息接收的影响</h3><p>JMS 中有 Queue 点对点和 Topic 发布订阅两种模式。</p><p>Queue 模式下发送端不确定消息被哪个应用消费，被称为 Peer To Peer PTP 方式。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200415233335.png" alt></p><p>Topic 模式中，接收消息的应用都能收到所有 Topic 的消息，也被称为 Pub/Sub 方式。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200415234449.png" alt></p><p>在使用 JMS 时，每个 Connection 都有一个唯一的 ClientId ，用于标记连接的唯一性，我们是默认一个接收应用只用了一个连接，可以看一下多连接的情况：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200416233309.png" alt></p><p>在 Queue 下应用 3 与 应用 4 是两个不同的应用，应用 3 与 JMS 建立了两个连接，而应用 4 与 JMS 建立了一个连接，每个连接收到的消息条数以及收到消息的顺序则不是固定的。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200416234721.png" alt></p><p>在 Topic 下，应用 3 与应用 4 会受到所有发送到 Topic 的消息。</p><p>现在思考我们需要的消息模型应该是什么样的？它需要满足以下需求：</p><ul><li>消息发送方和接收方都是集群；</li><li>同一个消息的接收方可能有多个集群进行消息的处理；</li><li>不同集群对于同一条消息的处理不能相互干扰。</li></ul><p>假设现在有两个集群和八条消息，每个集群两台机器，每个集群的机器应该分别处理所有的消息，不能遗漏或重复。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200427144032.png" alt></p><p>如果使用 JMS Queue 模型，那么集群 A 和集群 B 收到的消息都不完整。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200427144129.png" alt></p><p>如果使用 JMS Topic 的情况，每一台机器都可以收到所有消息，这种方式负担太大。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428011536.png" alt></p><p>正确的做法应该是：</p><ul><li>集群之间使用 Topic 模型；</li><li>集群内部使用 Queue 模型；</li><li>用 ClusterId 标识不同集群。</li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428011722.png" alt></p><p>如果单纯使用 JMS 的话，需要用上图思路将 Topic 与 Queue 进行级联。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428012012.png" alt></p><p>用 JMS 的方式级联工作相对繁重，需要实现中转者，推荐抛弃 JMS 的束缚自己实现。</p><h3 id="2-4-消息的订阅方式"><a href="#2-4-消息的订阅方式" class="headerlink" title="2.4 消息的订阅方式"></a>2.4 消息的订阅方式</h3><p>消息的订阅分为持久与非持久两种方式，非持久是说如果接收消息者关闭则接收不到消息。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428021824.png" alt></p><p>持久消息是即使接收者关闭了，还是会接收到消息（下一次启动时投递），只能选择显示关闭。</p><p><img src="/Users/ronnie/Library/Application Support/typora-user-images/image-20200428021935265.png" alt="image-20200428021935265"></p><p>因此我们的目标就是实现持久订阅。</p><h3 id="2-5-消息可靠性"><a href="#2-5-消息可靠性" class="headerlink" title="2.5 消息可靠性"></a>2.5 消息可靠性</h3><p>消息从发送端到接收端，中间有三个阶段需要保证可靠性：</p><ul><li>消息发送者发送消息到中间件；</li><li>中间件把消息存储；</li><li>中间件发送消息到消息接收者。</li></ul><p>第一步只需要确定消息发送者与消息中间件之间的返回结果。</p><h4 id="2-5-1-存储可靠性"><a href="#2-5-1-存储可靠性" class="headerlink" title="2.5.1 存储可靠性"></a>2.5.1 存储可靠性</h4><ol><li>基于文件的消息存储</li><li>采用数据库进行消息存储</li><li>双机内存的消息存储</li></ol><p>在实际开发中应该根据实际业务场景进行选择。比如如果当前的使用场景是：</p><p><em>很高的消息吞吐量，写入速度很快，灵活检索，同时消息本身不大（1.5K），对消息的顺序不敏感。</em></p><p>那么可以选择关系型数据库来进行消息存储（比如参考 ActiveMQ 中的 Kaha Persistence 实现）。因为分布式文件系统的稳定性和性能还有待改善，同时也不支持灵活的检索；NoSQL的迁移、扩容在当前场景不重要。可以自己实现一个单机存储，难点有四个：</p><ul><li>完全重写一个单机的存储引擎；</li><li>各个场景的测试没有遇到问题不代表没有问题，可靠性挑战大；</li><li>由于关注吞吐量而不是消息顺序，会导致原本连续的消息有些不需要了，有些则必须保留，会造成文件的缺失；<ul><li>可以通过保留的信息顺序写入来弥补缺失，空缺的部分不再理会；</li></ul></li><li>检索处理会考虑索引对内存的消耗，必须考虑索引不能完全加载到内存的情况，涉及内存与磁盘的交换；</li></ul><p>可以发现完全自主实现一个单机存储引擎很麻烦，可以采用现有数据库。使用现有数据库后下一步操作就是数据库的设计。对于消息中间件而言，也要考虑到数据冗余、级联查询的问题，当然希望一个消息只用一个单行的数据来解决，对于一个消息而言，可以分成三个部分：</p><ul><li>消息的 Header 信息；<ul><li>如消息 Id 、创建时间、投递次数、优先级、自定义键值对等；</li></ul></li><li>消息的 Body；<ul><li>消息的具体内容；</li></ul></li><li>消息的投递目标；<ul><li>指单条消息要投递到的目标集群的 ClusterId ；</li></ul></li></ul><p>消息表示、投递表示可以放到一张表中。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428112735.png" alt></p><p>同时需要注意两个问题：</p><ul><li>投递列表字段有长度限制，一个变通是将投递列表转换成多个字段；</li><li>无法按照单独的接收者来进行消息的调度，整合以后根据 ClusterId 进行调度无法直接做到，无法直接给 ClusterId 建立索引。</li></ul><blockquote><p>合并投递表和消息表后，如果订阅集群挂了，我们再去统一发送消息是比较低效的，此时可以在消息调度外增加一个针对特定集群的调度支持，也就是为需要尽快调度的集群建一个调度表，看上去不太优雅，但是比较好用。</p></blockquote><p>此外还需要考虑到安全问题，单机不考虑；多机数据复制有延迟，如果需要低延迟且异地容灾可以用异步复制；也可以用应用实现双写，但是会让应用变得复杂。这些需要针对具体业务权衡。</p><p>在使用文件系统、数据库存储的时候因为磁盘 IO 的原因性能会受到限制。一个改进是采用混合方式进行存储的管理，可以用双机的内存来保证数据的可靠，如图所示正常情况下消息持久化是不工作的，而是基于内存存储信息来提供高吞吐，一旦机器故障，则停止另一台数据的写操作，并把当前数据落库。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428154420.png" alt></p><p>正常机器把数据落库保证安全，只要不遇到两台机器都故障消息是安全的。</p><h4 id="2-5-2-消息系统扩容"><a href="#2-5-2-消息系统扩容" class="headerlink" title="2.5.2 消息系统扩容"></a>2.5.2 消息系统扩容</h4><p>如图为消息中间件与消息存储之间的关系，不同的消息中间件可能会共用存储，而同一个消息中间件机器可能使用不同的存储。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428154736.png" alt></p><ul><li>消息中间件自身扩容<ul><li>软负载动态感知新加入的中间件机器到集群；</li><li>同一个存储区分消息的中间件来源，可以给每条数据增加一个 server 标识，新的消息中间件加入会有新的 server 标识；</li><li>需要注意如果有消息中间件长期不可用，需要把这些标识的消息给其他机器处理。</li></ul></li><li>消息存储的扩容<ul><li>不保证消息顺序，push 方式，这两点令存储变得相对简单；</li><li>消息发送到中间件，中间件将消息入库，这时中间件知道消息在哪儿，不会出现主动搜索的场景（比如通过消息的 Id 查询），消息的索引信息都会在内存中；</li><li>通过 push 绕过了主动查询的动作，使得存储扩容变得容易（不用担心分库分表找某一条会复杂）。</li></ul></li></ul><h4 id="2-5-3-消息投递可靠性"><a href="#2-5-3-消息投递可靠性" class="headerlink" title="2.5.3 消息投递可靠性"></a>2.5.3 消息投递可靠性</h4><p>这里有两个优化点：</p><p>首先是消息投递一定要采用多线程方式，如果某一个消息订阅者集群有一个很慢的订阅者会有堵塞，也可以把消息返回的处理工作放到另一个线程池中，保证投递的环节不会堵死。</p><p>其次在如图场景中，一个应用中可能有多个订阅者订阅了相同的消息，消息中间件会向机器发送多次同样的消息。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428161955.png" alt></p><ul><li>单机多订阅者共享连接；</li><li>消息只发送一次，然后单机的多订阅者生成多个实例。</li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428162104.png" alt></p><h3 id="2-6-订阅者视角消息的重复产生"><a href="#2-6-订阅者视角消息的重复产生" class="headerlink" title="2.6 订阅者视角消息的重复产生"></a>2.6 订阅者视角消息的重复产生</h3><p>有两大类原因会导致产生重复消息。</p><ul><li>消息发送端应用的消息重复发送；<ul><li>消息中间件收到消息并成功存储，但是消息中间件出现问题（应用异常）；</li><li>中间件收到消息，但是存储异常（超时），导致发送端重试，此时网络恢复，导致消息重复；</li><li>总结：消息到达存储因各种原因没收到成功的返回，并且又有重试机制导致消息重复；</li><li>处理：重试使用相同的消息 Id 。</li></ul></li><li>消息到达消息存储，由消息中间件进行向外投递时产生重复；<ul><li>消息成功到达接收者，接收者处理完成出问题（网络异常、处理超时、应用异常），消息中间件不知道处理结果再次投递；</li><li>接收者处理完，中间件收到结果，但是此时消息存储异常，导致消息中间件再次向接收者投递；</li><li>总结：消息接收者处理完成，消息中间件不能及时更新投递状态；</li><li>处理：分布式事务，但是成本高，或者让接收者来处理重复，进行幂等操作。</li></ul></li></ul><h3 id="2-7-消息投递的其他属性支持"><a href="#2-7-消息投递的其他属性支持" class="headerlink" title="2.7 消息投递的其他属性支持"></a>2.7 消息投递的其他属性支持</h3><ul><li>消息优先级；</li><li>订阅者消息处理顺序与分级订阅；<ul><li>如果希望消息在消费者中的处理有顺序的，可以用字段定义优先级，也可以分级订阅；</li><li>将消息接收者分成一般接收者与优先接收者，做到先后顺序；</li><li><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428023443.png" alt></li></ul></li><li>自定义属性；</li><li>局部顺序；<ul><li>众多消息中与某件事相关的消息是有序的，而多件事之间是无序的；</li><li><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428023640.png" alt></li></ul></li></ul><h3 id="2-8-保证顺序的消息队列"><a href="#2-8-保证顺序的消息队列" class="headerlink" title="2.8 保证顺序的消息队列"></a>2.8 保证顺序的消息队列</h3><p>在中间件内部，有多个物理上的队列，每一个队列严格按照顺序被接收，而消息中间件内部的队列之间是互不影响的。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428163706.png" alt></p><p>具体实现中，每一个接收者在队列上有一个当前消费消息的位置，这个位置是已经完成消费的消息。同一个队列中，不同接收着维护各自的指针，该方式下，就能完成接收端的自主控制。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428164121.png" alt></p><h3 id="2-9-Push-与-Pull-方式"><a href="#2-9-Push-与-Pull-方式" class="headerlink" title="2.9 Push 与 Pull 方式"></a>2.9 Push 与 Pull 方式</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200428022804.png" alt></p><p>push 动作来自服务端，pull 动作来自消费端。因此实时性强的操作应该用 push ，实时性不强的可以选用 pull 方式。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 大型网站系统与 Java 中间件开发实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据层访问层的设计与实现</title>
      <link href="/technology/2019-06-11-java-distributed-system-chapter5/"/>
      <url>/technology/2019-06-11-java-distributed-system-chapter5/</url>
      
        <content type="html"><![CDATA[<p>上一节引出了分布式数据访问层的各种问题，这里讲讲数据访问层的设计与实现。</p><h2 id="1-对外提供数据访问层的方式"><a href="#1-对外提供数据访问层的方式" class="headerlink" title="1. 对外提供数据访问层的方式"></a>1. 对外提供数据访问层的方式</h2><p>数据访问层有多种提供能力的方式：</p><ol><li>专用 API ，不推荐，通用性差；</li><li>通用方式，使用 JDBC 的方式，数据层作为一个 JDBC 的实现，暴露 JDBC 接口给应用，成本低；</li><li>ORM 类别的接口，介入上两种之间，一般都会使用类 ORM 框架，如 iBatis、hibernate、Spring JDBC 等，推荐。</li></ol><p>上面三种分别画图即如下图所示。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/数据访问接口.jpg" alt></p><p>可以发现使用 JDBC 的兼容性和扩展性是最好的，但是实现成本高，封装一个 ORM 框架后会具备通用性。</p><p>JDBC 的方式有时候会优于 ORM 的方案，比如分页排序的时候，ORM 需要在内存里进行操作，JDBC 就不会需要那么多内存，在访问的数据的时候能规避不需要的数据查询；此外，ORM 动态修改 SQL 会比较困难，JDBC 的方式则没有那么困难。</p><h2 id="2-数据层流程"><a href="#2-数据层流程" class="headerlink" title="2. 数据层流程"></a>2. 数据层流程</h2><p>我们知道一般来说访问数据库有以下几个操作：</p><ol><li>SQL 解析；</li><li>规则处理；</li><li>SQL 改写；</li><li>数据源选择；</li><li>SQL 执行；</li><li>结果集返回并处理。</li></ol><h3 id="2-1-SQL-解析阶段"><a href="#2-1-SQL-解析阶段" class="headerlink" title="2.1 SQL 解析阶段"></a>2.1 SQL 解析阶段</h3><p>此时主要考虑两个问题：一个是对 SQL 支持的程度，另外一个则是支持多少 SQL 的方言。</p><p>对于解析的缓存可以提升解析速度，当然需要注意缓存的容量限制，一般系统中执行的 SQL 数量相对是可控的，不过为了安全，解析的缓存需要加上数量上限。</p><p>解析可以得到 SQL 的关键信息，比如表名、字段等等，下一步则是规则处理。</p><h3 id="2-2-规则处理阶段"><a href="#2-2-规则处理阶段" class="headerlink" title="2.2 规则处理阶段"></a>2.2 规则处理阶段</h3><h4 id="2-2-1-固定哈希"><a href="#2-2-1-固定哈希" class="headerlink" title="2.2.1 固定哈希"></a>2.2.1 固定哈希</h4><p>首当其冲的就是「固定哈希」方式，比如对某个字段进行取模，然后分散到不同的数据库和表中，除了根据 id 取模，还有根据时间，如天、星期、月、年来进行存储数据，这一般用于数据产生后相关日期不进行修改的情况。</p><p>我们可以想象通过取模到不同的库，那么如果分库后还需要分表呢？如下图所示。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200324135201.png" alt></p><p>首先我们对2取模到两个库，然后对4取模到不同库的不同表中。当然也可以直接对4取模，然后判断是否大于2进行分库，分表是相同的。</p><h4 id="2-2-2-一致性哈希"><a href="#2-2-2-一致性哈希" class="headerlink" title="2.2.2 一致性哈希"></a>2.2.2 一致性哈希</h4><p>Consistent Hashing ，是1997年提出的，最大变化是把节点对应的哈希值变为了一个范围，而不再是离散的，如果有新节点加入，则接管一部分范围的哈希；如果有节点退出，原来管理的哈希被下一个节点管理。这很好想象，即一个环形结构。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200324135801.png" alt></p><p>新增和删除一个节点都只会对一个节点造成影响。</p><h4 id="2-2-3-虚拟节点对一致性哈希的改进"><a href="#2-2-3-虚拟节点对一致性哈希的改进" class="headerlink" title="2.2.3 虚拟节点对一致性哈希的改进"></a>2.2.3 虚拟节点对一致性哈希的改进</h4><p>为了解决数据不均衡的问题，引入了虚拟节点的概念，即原先的四个物理节点可以变为很多的虚拟节点，每个节点支持一段哈希，相应有很多虚拟节点，均衡对应到整个哈希环上，如果一个物理节点失效，对应就是很多虚拟节点失效。</p><h4 id="2-2-4-映射表与规则自定义计算方式"><a href="#2-2-4-映射表与规则自定义计算方式" class="headerlink" title="2.2.4 映射表与规则自定义计算方式"></a>2.2.4 映射表与规则自定义计算方式</h4><p>映射表是分库分表字段的值的查表方法来确定数据源的方法。一般用于热点数据的特殊处理，或者在一些场景下对不完全符合规律的规则进行的补充。</p><p>而规则自定义计算方式是最灵活的一种方式。它已经不算是以配置的方式来做规则，而是通过比较复杂的计算来解决数据访问的问题。</p><blockquote><p>比如 id 对4取模进行分库，我们对一些热点 id 需要独立到另外的库，则很简答的，有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (id in hotset) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id % <span class="number">4</span>;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-3-改写-SQL-阶段"><a href="#2-3-改写-SQL-阶段" class="headerlink" title="2.3 改写 SQL 阶段"></a>2.3 改写 SQL 阶段</h3><p>一般标准是分库后尽量避免跨库查询。</p><p>比如现在有一个商品表，里面有商家 id 和商品 id ，我们可以选择对这两种 id 作为依据进行分库，这里就要进行考量，通过哪个指标进行分库。</p><p>进行改写 SQL 的一个原因是，如果分库后，有多个同名表，就需要进行后缀的区分；另外相对的索引名也可能需要区分；除了名字以外，对于取平均这样的操作，就需要先 Count 再 Avg ，就必须要修改 SQL 来达到了。</p><h3 id="2-4-数据源选择阶段"><a href="#2-4-数据源选择阶段" class="headerlink" title="2.4 数据源选择阶段"></a>2.4 数据源选择阶段</h3><p>现在我们不再是一张表，可能是分库分表的结果，直观看就是一个矩阵的表，我们不仅要选择库，还要选择表，需要根据当前执行 SQL 的特点，计算得到这次 SQL 请求要访问的数据库。</p><h3 id="2-5-执行与结果处理阶段"><a href="#2-5-执行与结果处理阶段" class="headerlink" title="2.5 执行与结果处理阶段"></a>2.5 执行与结果处理阶段</h3><p>没啥好说的，重点在于异常的处理与判断。</p><p>这里是三层数据源整体视图：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200324141741.png" alt></p><h2 id="3-独立部署的数据访问层实现方式"><a href="#3-独立部署的数据访问层实现方式" class="headerlink" title="3. 独立部署的数据访问层实现方式"></a>3. 独立部署的数据访问层实现方式</h2><p>从数据层的物理不说来说可以分为 jar 部署与 Proxy 的方式。</p><p>如果是 Proxy 的方式，客户端和 Proxy 之间的协议有两种选择：数据库协议与私有协议。</p><ul><li>数据库协议，则应用把 Proxy 当做一个数据库，使用 JDBC 的实现来连接 Proxy ，可以减少一次从数据库协议到对象然后再从对象到数据库协议的转换，而 Proxy 需要完全实现一套相关数据库的协议，成本比较高，应用到 Proxy 没法做连接复用；</li><li>私有协议，应用需要一个独立的数据层客户端，Proxy 的实现相对简单，而且应用到 Proxy 的连接可复用。</li></ul><p>下图可以清晰看到应用接入有 MySQL 与自身协议两种方式，连接数据库时，可以使用具体的适配器访问，也可以使用 JDBC 驱动访问，更加灵活，直接在协议层来控制数据，能够实现少一次转换就完成调用的工作。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200324145752.png" alt></p><h2 id="4-读写分离的挑战与应对"><a href="#4-读写分离的挑战与应对" class="headerlink" title="4. 读写分离的挑战与应对"></a>4. 读写分离的挑战与应对</h2><p>读写分离可以分担主库的读压力。</p><h3 id="4-1-主库从库非对称场景"><a href="#4-1-主库从库非对称场景" class="headerlink" title="4.1 主库从库非对称场景"></a>4.1 主库从库非对称场景</h3><h4 id="4-1-1-数据结构相同，一主多从"><a href="#4-1-1-数据结构相同，一主多从" class="headerlink" title="4.1.1 数据结构相同，一主多从"></a>4.1.1 数据结构相同，一主多从</h4><p>在 MySQL 中可以使用 Replication 解决复制的问题，而且延迟相对较小。</p><p>一主多从，主来写，从和主一起提供读，此时，我们可以如下方式进行数据复制。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200324150233.png" alt></p><p>数据同步服务器和 DB 主库的交互根据被修改、增加的数据主键来获取内容，采用行复制。</p><p>而通过行复制的方式是一个不优雅但能解决问题的方式，比较优雅的是基于数据库的日志来进行数据复制。</p><h4 id="4-1-2-主备分库方式不同的数据复制"><a href="#4-1-2-主备分库方式不同的数据复制" class="headerlink" title="4.1.2 主备分库方式不同的数据复制"></a>4.1.2 主备分库方式不同的数据复制</h4><p>章节名中的「非对称」指的是源数据与目标数据不是镜像关系，也就是说数据库与目标数据库实现方式不同。</p><p>比如现在分库条件不同，我们需要进行数据库的复制怎么办？比如订单系统，主库是买家 id 进行分库，备库则可以进行卖家 id 进行分库，这就需要进行非对称的复制。</p><h4 id="4-1-3-引入数据变更平台"><a href="#4-1-3-引入数据变更平台" class="headerlink" title="4.1.3 引入数据变更平台"></a>4.1.3 引入数据变更平台</h4><p>我们除了数据变更到其他数据库这一种场景，还有搜索引擎的索引构建、缓存的失效等。我们可以构建一个通用的平台来管理和控制数据的变更。</p><p>我们引入 Extractor 和 Applier ，其中 Extractor 负责把数据源变更的信息加入到数据分发平台中，而 Applier 的作用是把这些变更应用到相应的目标上，中间的数据分发平台则是由多个管道组成的。不同的数据来源需要不同的 Extractor 来进行解析和变更，不同的目标需要用不同的 Applier 把数据落库到目标数据库上。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200324151451.png" alt></p><h3 id="4-2-数据平滑迁移"><a href="#4-2-数据平滑迁移" class="headerlink" title="4.2 数据平滑迁移"></a>4.2 数据平滑迁移</h3><p>数据迁移最大的挑战是在迁移过程中，如果有数据变化怎么办？我们可以在迁移时进行增量日志，迁移结束把变化进行处理。</p><p>而复制，记录增量日志，这两步是一个逐渐收敛的过程，因此需要进行数据比对，如果新库数据与源库数据不同，则记录下来，然后停止迁移的写，进行增量日志处理，使得新库数据是新的。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 大型网站系统与 Java 中间件开发实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy &amp; pandas 笔记</title>
      <link href="/machine-learning/2019-06-10-numpy-learning/"/>
      <url>/machine-learning/2019-06-10-numpy-learning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下 python 的数据处理工具，教材来自<a href="https://morvanzhou.github.io/" target="_blank" rel="noopener">莫烦PYTHON</a> 。</p></blockquote><h2 id="1-numpy-相关"><a href="#1-numpy-相关" class="headerlink" title="1. numpy 相关"></a>1. numpy 相关</h2><h3 id="1-1-numpy-属性"><a href="#1-1-numpy-属性" class="headerlink" title="1.1 numpy 属性"></a>1.1 numpy 属性</h3><ul><li>ndim 维度</li><li>shape 行列</li><li>size 个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="comment"># 维度</span></span><br><span class="line">array.ndim</span><br><span class="line"><span class="comment"># 行列</span></span><br><span class="line">array.shape</span><br><span class="line"><span class="comment"># 个数</span></span><br><span class="line">array.size</span><br></pre></td></tr></table></figure><h3 id="1-2-array-创建"><a href="#1-2-array-创建" class="headerlink" title="1.2 array 创建"></a>1.2 array 创建</h3><ul><li>array 创建数组</li><li>dtype 指定数据类型</li><li>zeros 全 0 数组</li><li>ones 全 1 数组</li><li>empty 接近 0 数组</li><li>arrange 按指定范围创建数据</li><li>linespace 创建线段</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全零数组</span></span><br><span class="line">a = np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 0.]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 指定类型</span></span><br><span class="line">a = np.ones((<span class="number">3</span>,<span class="number">4</span>),dtype=np.int)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 1, 1, 1],</span></span><br><span class="line"><span class="string">       [1, 1, 1, 1],</span></span><br><span class="line"><span class="string">       [1, 1, 1, 1]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 接近 0</span></span><br><span class="line">a = np.empty((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 1.49166815e-154, -2.32036217e+077,  2.96439388e-323,</span></span><br><span class="line"><span class="string">         0.00000000e+000],</span></span><br><span class="line"><span class="string">       [ 0.00000000e+000,  6.82116729e-043,  7.78937022e-091,</span></span><br><span class="line"><span class="string">         3.93892987e-062],</span></span><br><span class="line"><span class="string">       [ 3.61353389e+174,  4.01062531e+174,  3.99910963e+252,</span></span><br><span class="line"><span class="string">         8.34404819e-309]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 范围 步长 2 从 10 到 20</span></span><br><span class="line">a = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([10, 12, 14, 16, 18])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 改变形状</span></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 线段，指定起点和终点和间隔即可，结果是一维的</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([ 1.        ,  1.47368421,  1.94736842,  2.42105263,  2.89473684,</span></span><br><span class="line"><span class="string">        3.36842105,  3.84210526,  4.31578947,  4.78947368,  5.26315789,</span></span><br><span class="line"><span class="string">        5.73684211,  6.21052632,  6.68421053,  7.15789474,  7.63157895,</span></span><br><span class="line"><span class="string">        8.10526316,  8.57894737,  9.05263158,  9.52631579, 10.        ])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 线段 + 改变形状</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>).reshape((<span class="number">5</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 1.        ,  1.47368421,  1.94736842,  2.42105263],</span></span><br><span class="line"><span class="string">       [ 2.89473684,  3.36842105,  3.84210526,  4.31578947],</span></span><br><span class="line"><span class="string">       [ 4.78947368,  5.26315789,  5.73684211,  6.21052632],</span></span><br><span class="line"><span class="string">       [ 6.68421053,  7.15789474,  7.63157895,  8.10526316],</span></span><br><span class="line"><span class="string">       [ 8.57894737,  9.05263158,  9.52631579, 10.        ]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="1-3-numpy-基础运算"><a href="#1-3-numpy-基础运算" class="headerlink" title="1.3 numpy 基础运算"></a>1.3 numpy 基础运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先上两个矩阵 a 和 b</span></span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([10, 20, 30, 40])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([0, 1, 2, 3])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 对于每个元素当然可以使用 +-*/ 以及 ** 这样的操作</span></span><br><span class="line"><span class="comment"># 值得注意的是，点乘使用的是 np.dot</span></span><br><span class="line">c = a*b</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([  0,  20,  60, 120])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">d = np.dot(a,b) <span class="comment"># a.dot(b)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># np.sum/min/max 就不试了</span></span><br><span class="line"><span class="comment"># 值得注意的是参数 axis 0 输出整行，1 输出整列</span></span><br><span class="line">a = np.arange(<span class="number">2</span>,<span class="number">14</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 2,  3,  4,  5],</span></span><br><span class="line"><span class="string">       [ 6,  7,  8,  9],</span></span><br><span class="line"><span class="string">       [10, 11, 12, 13]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 最小值索引</span></span><br><span class="line">np.argmin(a)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 最大值索引</span></span><br><span class="line">np.argmax(a)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">11</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># np.mean(a) / np.average(a) / a.mean() 求平均</span></span><br><span class="line"><span class="comment"># np.median(a) / a.median() 求中位数</span></span><br><span class="line"><span class="comment"># 累加</span></span><br><span class="line">np.cumsum(a)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([ 2,  5,  9, 14, 20, 27, 35, 44, 54, 65, 77, 90])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 累差 计算的是一行中后一项和前一项的差，故 3*4 累差得到 3*3 的矩阵</span></span><br><span class="line">np.diff(a)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 1, 1],</span></span><br><span class="line"><span class="string">       [1, 1, 1],</span></span><br><span class="line"><span class="string">       [1, 1, 1]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 非零元素坐标 第一个 array 是行，第二个 array 是列，输出的是坐标</span></span><br><span class="line">np.nonzero(a)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">(array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]),</span></span><br><span class="line"><span class="string"> array([0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]))</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="1-4-numpy-索引"><a href="#1-4-numpy-索引" class="headerlink" title="1.4 numpy 索引"></a>1.4 numpy 索引</h3><p>可以像 python 数组一样使用 numpy 的 array ，也能切片，遍历的时候注意一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按行遍历</span></span><br><span class="line">a = np.arange(<span class="number">3</span>,<span class="number">15</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a:</span><br><span class="line">  ...</span><br><span class="line"><span class="comment"># 按列遍历 转置</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> a.T:</span><br><span class="line">  ...</span><br><span class="line"><span class="comment"># 扁平化 降一维</span></span><br><span class="line">a.flatten()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[ 3  4  5  6  7  8  9 10 11 12 13 14]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="1-5-array-合并"><a href="#1-5-array-合并" class="headerlink" title="1.5 array 合并"></a>1.5 array 合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 垂直合并</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">b = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">np.vstack((a,b))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 1, 1],</span></span><br><span class="line"><span class="string">       [2, 2, 2]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 水平合并</span></span><br><span class="line">np.hstack((a,b))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([1, 1, 1, 2, 2, 2])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 通用转置</span></span><br><span class="line"><span class="comment"># 简单使用 T 只对矩阵有效，这里的 a 就无法转置，即使使用也依然是 (3,) 的类型</span></span><br><span class="line"><span class="comment"># 3 个元素的数组转换成 1*3 的矩阵</span></span><br><span class="line">a[np.newaxis,:]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 1, 1]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">a[np.newaxis,:].shape</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">(1, 3)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 3 个元素的数组转换成 3*1 的矩阵</span></span><br><span class="line">a[:,np.newaxis]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">a[:,np.newaxis].shape</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">(3, 1)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 把 newaxis 和 h/vstack 实操一下</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])[:,np.newaxis]</span><br><span class="line">b = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])[:,np.newaxis]</span><br><span class="line">np.vstack((a,b))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">np.hstack((a,b))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 2],</span></span><br><span class="line"><span class="string">       [1, 2],</span></span><br><span class="line"><span class="string">       [1, 2]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 不得不说 h/vstack 的职责过于单一，有通用方式 concatenate</span></span><br><span class="line">np.concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">np.concatenate((a,b),axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 2],</span></span><br><span class="line"><span class="string">       [1, 2],</span></span><br><span class="line"><span class="string">       [1, 2]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="1-6-array-分割"><a href="#1-6-array-分割" class="headerlink" title="1.6 array 分割"></a>1.6 array 分割</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 纵向分割</span></span><br><span class="line">np.split(a,<span class="number">2</span>,axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">        [4, 5],</span></span><br><span class="line"><span class="string">        [8, 9]]), array([[ 2,  3],</span></span><br><span class="line"><span class="string">        [ 6,  7],</span></span><br><span class="line"><span class="string">        [10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 横向分割 这里分割 2 个会报错，因为 3 不能被 2 整除</span></span><br><span class="line">np.split(a,<span class="number">3</span>,axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 不等量分割</span></span><br><span class="line">np.array_split(a,<span class="number">2</span>,axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1, 2, 3],</span></span><br><span class="line"><span class="string">        [4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 也有不通用的方式，和上文 h/vstack 类似</span></span><br><span class="line"><span class="comment"># 垂直切分 等价于 np.split(a, 3, axis=0)</span></span><br><span class="line">np.vsplit(a,<span class="number">3</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 水平切分 等价于 np.split(a, 4, axis=1)</span></span><br><span class="line">np.hsplit(a,<span class="number">4</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0],</span></span><br><span class="line"><span class="string">        [4],</span></span><br><span class="line"><span class="string">        [8]]), array([[1],</span></span><br><span class="line"><span class="string">        [5],</span></span><br><span class="line"><span class="string">        [9]]), array([[ 2],</span></span><br><span class="line"><span class="string">        [ 6],</span></span><br><span class="line"><span class="string">        [10]]), array([[ 3],</span></span><br><span class="line"><span class="string">        [ 7],</span></span><br><span class="line"><span class="string">        [11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="1-7-numpy-copy-amp-deep-copy"><a href="#1-7-numpy-copy-amp-deep-copy" class="headerlink" title="1.7 numpy copy &amp; deep copy"></a>1.7 numpy copy &amp; deep copy</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line">b = a</span><br><span class="line">c = a</span><br><span class="line">d = b</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([0, 1, 2, 3])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 在 a b c d 中更改任意一个值，这 4 个值都会更改，这是 python 的引用方式</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">11</span></span><br><span class="line">d</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([11,  1,  2,  3])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 如果使用 copy 就是深拷贝，不是引用的方式</span></span><br><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line">b = a.copy()</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">11</span></span><br><span class="line">b</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([0, 1, 2, 3])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="2-pandas-相关"><a href="#2-pandas-相关" class="headerlink" title="2. pandas 相关"></a>2. pandas 相关</h2><blockquote><p>如果 numpy 是列表，那么 pandas 就是字典。</p></blockquote><h3 id="2-1-pandas-基本介绍"><a href="#2-1-pandas-基本介绍" class="headerlink" title="2.1 pandas 基本介绍"></a>2.1 pandas 基本介绍</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># Series 的字符串表现形式为：索引在左边，值在右边。</span></span><br><span class="line">a = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,np.nan,<span class="number">44</span>,<span class="number">1</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0     1.0</span></span><br><span class="line"><span class="string">1     3.0</span></span><br><span class="line"><span class="string">2     6.0</span></span><br><span class="line"><span class="string">3     NaN</span></span><br><span class="line"><span class="string">4    44.0</span></span><br><span class="line"><span class="string">5     1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># DataFrame 是一个有行列索引的表格，它包含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。</span></span><br><span class="line">dates = pd.date_range(<span class="string">'20200101'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>),index=dates,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">2020-01-011.364291-1.316093-1.5340130.167940</span></span><br><span class="line"><span class="string">2020-01-020.406588-0.485523-0.033501-0.689241</span></span><br><span class="line"><span class="string">2020-01-031.2221310.029937-0.8626022.134857</span></span><br><span class="line"><span class="string">2020-01-041.514998-1.980169-0.274395-0.349385</span></span><br><span class="line"><span class="string">2020-01-05-0.2798090.0237220.3134030.027728</span></span><br><span class="line"><span class="string">2020-01-060.263307-0.100027-0.462106-1.664943</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 可以用列索引找到指定列</span></span><br><span class="line">df[<span class="string">'b'</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2020-01-01   -2.525535</span></span><br><span class="line"><span class="string">2020-01-02   -1.020658</span></span><br><span class="line"><span class="string">2020-01-03    0.445319</span></span><br><span class="line"><span class="string">2020-01-04    2.011729</span></span><br><span class="line"><span class="string">2020-01-05    1.403210</span></span><br><span class="line"><span class="string">2020-01-06   -0.528488</span></span><br><span class="line"><span class="string">Freq: D, Name: b, dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 创建没有索引的表格</span></span><br><span class="line">pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0123</span></span><br><span class="line"><span class="string">00123</span></span><br><span class="line"><span class="string">14567</span></span><br><span class="line"><span class="string">2891011</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 也可以一列列来创建</span></span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span> : <span class="number">1.</span>,</span><br><span class="line">              <span class="string">'B'</span> : pd.Timestamp(<span class="string">'20130102'</span>),</span><br><span class="line">              <span class="string">'C'</span> : pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float32'</span>),</span><br><span class="line">              <span class="string">'D'</span> : np.array([<span class="number">3</span>]*<span class="number">4</span>,dtype=<span class="string">'int32'</span>),</span><br><span class="line">              <span class="string">'E'</span> : pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"test"</span>,<span class="string">"train"</span>]),</span><br><span class="line">              <span class="string">'F'</span> : <span class="string">'foo'</span>&#125;)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCDEF</span></span><br><span class="line"><span class="string">01.02013-01-021.03testfoo</span></span><br><span class="line"><span class="string">11.02013-01-021.03trainfoo</span></span><br><span class="line"><span class="string">21.02013-01-021.03testfoo</span></span><br><span class="line"><span class="string">31.02013-01-021.03trainfoo</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 所以每一列的类型可以都不一样</span></span><br><span class="line">df2.dtypes</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A           float64</span></span><br><span class="line"><span class="string">B    datetime64[ns]</span></span><br><span class="line"><span class="string">C           float32</span></span><br><span class="line"><span class="string">D             int32</span></span><br><span class="line"><span class="string">E          category</span></span><br><span class="line"><span class="string">F            object</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 查看索引</span></span><br><span class="line">df2.index</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Int64Index([0, 1, 2, 3], dtype='int64')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 查看列名</span></span><br><span class="line">df2.columns</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 单纯看值</span></span><br><span class="line">df2.values</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']],</span></span><br><span class="line"><span class="string">      dtype=object)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 查看总结</span></span><br><span class="line">df2.describe()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  ACD</span></span><br><span class="line"><span class="string">count4.04.04.0</span></span><br><span class="line"><span class="string">mean1.01.03.0</span></span><br><span class="line"><span class="string">std0.00.00.0</span></span><br><span class="line"><span class="string">min1.01.03.0</span></span><br><span class="line"><span class="string">25%1.01.03.0</span></span><br><span class="line"><span class="string">50%1.01.03.0</span></span><br><span class="line"><span class="string">75%1.01.03.0</span></span><br><span class="line"><span class="string">max1.01.03.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 当然也能转置</span></span><br><span class="line">df2.T</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0123</span></span><br><span class="line"><span class="string">A1111</span></span><br><span class="line"><span class="string">B2013-01-02 00:00:002013-01-02 00:00:002013-01-02 00:00:002013-01-02 00:00:00</span></span><br><span class="line"><span class="string">C1111</span></span><br><span class="line"><span class="string">D3333</span></span><br><span class="line"><span class="string">Etesttraintesttrain</span></span><br><span class="line"><span class="string">Ffoofoofoofoo</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 注意一下，列和行的开头都叫做索引，下面是索引排序</span></span><br><span class="line">df2.sort_index(axis=<span class="number">0</span>,ascending=<span class="keyword">False</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  ABCDEF</span></span><br><span class="line"><span class="string">31.02013-01-021.03trainfoo</span></span><br><span class="line"><span class="string">21.02013-01-021.03testfoo</span></span><br><span class="line"><span class="string">11.02013-01-021.03trainfoo</span></span><br><span class="line"><span class="string">01.02013-01-021.03testfoo</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 上面是索引排序，下面是值排序</span></span><br><span class="line">df2.sort_values(by=<span class="string">'B'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  ABCDEF</span></span><br><span class="line"><span class="string">01.02013-01-021.03testfoo</span></span><br><span class="line"><span class="string">11.02013-01-021.03trainfoo</span></span><br><span class="line"><span class="string">21.02013-01-021.03testfoo</span></span><br><span class="line"><span class="string">31.02013-01-021.03trainfoo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="2-2-pandas-选择数据"><a href="#2-2-pandas-选择数据" class="headerlink" title="2.2 pandas 选择数据"></a>2.2 pandas 选择数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20200101'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)), index=dates, columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  ABCD</span></span><br><span class="line"><span class="string">2020-01-010123</span></span><br><span class="line"><span class="string">2020-01-024567</span></span><br><span class="line"><span class="string">2020-01-03891011</span></span><br><span class="line"><span class="string">2020-01-0412131415</span></span><br><span class="line"><span class="string">2020-01-0516171819</span></span><br><span class="line"><span class="string">2020-01-0620212223</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 简单筛选</span></span><br><span class="line"><span class="comment"># 列</span></span><br><span class="line">df.[<span class="string">'A'</span>]</span><br><span class="line">df.A</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2013-01-01     0</span></span><br><span class="line"><span class="string">2013-01-02     4</span></span><br><span class="line"><span class="string">2013-01-03     8</span></span><br><span class="line"><span class="string">2013-01-04    12</span></span><br><span class="line"><span class="string">2013-01-05    16</span></span><br><span class="line"><span class="string">2013-01-06    20</span></span><br><span class="line"><span class="string">Freq: D, Name: A, dtype: int64</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 行</span></span><br><span class="line">df[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">df[<span class="string">'20200101'</span>:<span class="string">'20200103'</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">2020-01-010123</span></span><br><span class="line"><span class="string">2020-01-024567</span></span><br><span class="line"><span class="string">2020-01-03891011</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 根据标签进行数据 loc</span></span><br><span class="line"><span class="comment"># 某行</span></span><br><span class="line">df.loc[<span class="string">'20200101'</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A    0</span></span><br><span class="line"><span class="string">B    1</span></span><br><span class="line"><span class="string">C    2</span></span><br><span class="line"><span class="string">D    3</span></span><br><span class="line"><span class="string">Name: 2020-01-01 00:00:00, dtype: int64</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 跨行</span></span><br><span class="line">df.loc[:,[<span class="string">'A'</span>,<span class="string">'B'</span>]]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">AB</span></span><br><span class="line"><span class="string">2020-01-0101</span></span><br><span class="line"><span class="string">2020-01-0245</span></span><br><span class="line"><span class="string">2020-01-0389</span></span><br><span class="line"><span class="string">2020-01-041213</span></span><br><span class="line"><span class="string">2020-01-051617</span></span><br><span class="line"><span class="string">2020-01-062021</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 指定行多列</span></span><br><span class="line">df.loc[<span class="string">'20200101'</span>,[<span class="string">'A'</span>,<span class="string">'B'</span>]]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A    0</span></span><br><span class="line"><span class="string">B    1</span></span><br><span class="line"><span class="string">Name: 2020-01-01 00:00:00, dtype: int64</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 根据坐标 iloc</span></span><br><span class="line">df.iloc[<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">13</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">df.iloc[<span class="number">3</span>:<span class="number">5</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">BC</span></span><br><span class="line"><span class="string">2020-01-041314</span></span><br><span class="line"><span class="string">2020-01-051718</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">df.iloc[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">BC</span></span><br><span class="line"><span class="string">2020-01-0256</span></span><br><span class="line"><span class="string">2020-01-041314</span></span><br><span class="line"><span class="string">2020-01-062122</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 判断筛选</span></span><br><span class="line">df[df.A&gt;<span class="number">8</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">2020-01-0412131415</span></span><br><span class="line"><span class="string">2020-01-0516171819</span></span><br><span class="line"><span class="string">2020-01-0620212223</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="2-3-pandas-设置值"><a href="#2-3-pandas-设置值" class="headerlink" title="2.3 pandas 设置值"></a>2.3 pandas 设置值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据 iloc 和 loc 设置值</span></span><br><span class="line">df.iloc[<span class="number">2</span>,<span class="number">2</span>]=<span class="number">1111</span></span><br><span class="line">df.loc[<span class="string">'20200101'</span>,<span class="string">'B'</span>]=<span class="number">2222</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">2020-01-010222223</span></span><br><span class="line"><span class="string">2020-01-024567</span></span><br><span class="line"><span class="string">2020-01-0389111111</span></span><br><span class="line"><span class="string">2020-01-0412131415</span></span><br><span class="line"><span class="string">2020-01-0516171819</span></span><br><span class="line"><span class="string">2020-01-0620212223</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 根据条件设置值</span></span><br><span class="line">df.B[df.A&gt;<span class="number">4</span>]=<span class="number">0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">2020-01-010222223</span></span><br><span class="line"><span class="string">2020-01-024567</span></span><br><span class="line"><span class="string">2020-01-0380111111</span></span><br><span class="line"><span class="string">2020-01-041201415</span></span><br><span class="line"><span class="string">2020-01-051601819</span></span><br><span class="line"><span class="string">2020-01-062002223</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 根据行列设置值</span></span><br><span class="line">df[<span class="string">'F'</span>]=np.nan</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCDF</span></span><br><span class="line"><span class="string">2020-01-010222223NaN</span></span><br><span class="line"><span class="string">2020-01-024567NaN</span></span><br><span class="line"><span class="string">2020-01-0380111111NaN</span></span><br><span class="line"><span class="string">2020-01-041201415NaN</span></span><br><span class="line"><span class="string">2020-01-051601819NaN</span></span><br><span class="line"><span class="string">2020-01-062002223NaN</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line">df[<span class="string">'E'</span>]=pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],index=pd.date_range(<span class="string">'20200101'</span>,periods=<span class="number">6</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCDFE</span></span><br><span class="line"><span class="string">2020-01-010222223NaN1</span></span><br><span class="line"><span class="string">2020-01-024567NaN2</span></span><br><span class="line"><span class="string">2020-01-0380111111NaN3</span></span><br><span class="line"><span class="string">2020-01-041201415NaN4</span></span><br><span class="line"><span class="string">2020-01-051601819NaN5</span></span><br><span class="line"><span class="string">2020-01-062002223NaN6</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="2-4-pandas-处理丢失数据"><a href="#2-4-pandas-处理丢失数据" class="headerlink" title="2.4 pandas 处理丢失数据"></a>2.4 pandas 处理丢失数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 含 nan 矩阵</span></span><br><span class="line">dates = pd.date_range(<span class="string">'20130101'</span>, periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates, columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">df.iloc[<span class="number">0</span>,<span class="number">1</span>]=np.nan</span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">2</span>]=np.nan</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">2013-01-010NaN2.03</span></span><br><span class="line"><span class="string">2013-01-0245.0NaN7</span></span><br><span class="line"><span class="string">2013-01-0389.010.011</span></span><br><span class="line"><span class="string">2013-01-041213.014.015</span></span><br><span class="line"><span class="string">2013-01-051617.018.019</span></span><br><span class="line"><span class="string">2013-01-062021.022.023</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 删除为 nan 的行或列，axis=0 为行，axis=1 为列，how='any' 为一个即删除，how='all' 为全部才删除</span></span><br><span class="line">df.dropna(axis=<span class="number">0</span>,how=<span class="string">'any'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  ABCD</span></span><br><span class="line"><span class="string">2013-01-0100.02.03</span></span><br><span class="line"><span class="string">2013-01-0245.00.07</span></span><br><span class="line"><span class="string">2013-01-0389.010.011</span></span><br><span class="line"><span class="string">2013-01-041213.014.015</span></span><br><span class="line"><span class="string">2013-01-051617.018.019</span></span><br><span class="line"><span class="string">2013-01-062021.022.023</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">df.fillna(value=<span class="number">0</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">2013-01-0389.010.011</span></span><br><span class="line"><span class="string">2013-01-041213.014.015</span></span><br><span class="line"><span class="string">2013-01-051617.018.019</span></span><br><span class="line"><span class="string">2013-01-062021.022.023</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 判断数据缺失</span></span><br><span class="line">df.isnull()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">2013-01-01FalseTrueFalseFalse</span></span><br><span class="line"><span class="string">2013-01-02FalseFalseTrueFalse</span></span><br><span class="line"><span class="string">2013-01-03FalseFalseFalseFalse</span></span><br><span class="line"><span class="string">2013-01-04FalseFalseFalseFalse</span></span><br><span class="line"><span class="string">2013-01-05FalseFalseFalseFalse</span></span><br><span class="line"><span class="string">2013-01-06FalseFalseFalseFalse</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 判断存在数据</span></span><br><span class="line">np.any(df.isnull())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="2-5-pandas-导入导出"><a href="#2-5-pandas-导入导出" class="headerlink" title="2.5 pandas 导入导出"></a>2.5 pandas 导入导出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取 csv</span></span><br><span class="line">data=pd.read_csv(<span class="string">'student.csv'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  Student IDnameagegender</span></span><br><span class="line"><span class="string">01100Kelly22Female</span></span><br><span class="line"><span class="string">11101Clo21Female</span></span><br><span class="line"><span class="string">21102Tilly22Female</span></span><br><span class="line"><span class="string">31103Tony24Male</span></span><br><span class="line"><span class="string">41104David20Male</span></span><br><span class="line"><span class="string">51105Catty22Female</span></span><br><span class="line"><span class="string">61106M3Female</span></span><br><span class="line"><span class="string">71107N43Male</span></span><br><span class="line"><span class="string">81108A13Male</span></span><br><span class="line"><span class="string">91109S12Male</span></span><br><span class="line"><span class="string">101110David33Male</span></span><br><span class="line"><span class="string">111111Dw3Female</span></span><br><span class="line"><span class="string">121112Q23Male</span></span><br><span class="line"><span class="string">131113W21Female</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 将数据存储为 pickle 类型</span></span><br><span class="line">data.to_pickle(<span class="string">'student.pickle'</span>)</span><br></pre></td></tr></table></figure><h3 id="2-6-pandas-合并-concat"><a href="#2-6-pandas-合并-concat" class="headerlink" title="2.6 pandas 合并 concat"></a>2.6 pandas 合并 concat</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 定义资料</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">2</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"><span class="comment"># concat 纵向合并</span></span><br><span class="line">res = pd.concat([df1,df2,df3])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">00.00.00.00.0</span></span><br><span class="line"><span class="string">10.00.00.00.0</span></span><br><span class="line"><span class="string">20.00.00.00.0</span></span><br><span class="line"><span class="string">01.01.01.01.0</span></span><br><span class="line"><span class="string">11.01.01.01.0</span></span><br><span class="line"><span class="string">21.01.01.01.0</span></span><br><span class="line"><span class="string">02.02.02.02.0</span></span><br><span class="line"><span class="string">12.02.02.02.0</span></span><br><span class="line"><span class="string">22.02.02.02.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 重置 index</span></span><br><span class="line">res = pd.concat([df1,df2,df3],axis=<span class="number">0</span>,ignore_index=<span class="keyword">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">00.00.00.00.0</span></span><br><span class="line"><span class="string">10.00.00.00.0</span></span><br><span class="line"><span class="string">20.00.00.00.0</span></span><br><span class="line"><span class="string">31.01.01.01.0</span></span><br><span class="line"><span class="string">41.01.01.01.0</span></span><br><span class="line"><span class="string">51.01.01.01.0</span></span><br><span class="line"><span class="string">62.02.02.02.0</span></span><br><span class="line"><span class="string">72.02.02.02.0</span></span><br><span class="line"><span class="string">82.02.02.02.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 纵向内合并 df1 与 df2</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">0</span>, join=<span class="string">'inner'</span>, ignore_index=<span class="keyword">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">bcd</span></span><br><span class="line"><span class="string">00.00.00.0</span></span><br><span class="line"><span class="string">10.00.00.0</span></span><br><span class="line"><span class="string">20.00.00.0</span></span><br><span class="line"><span class="string">31.01.01.0</span></span><br><span class="line"><span class="string">41.01.01.0</span></span><br><span class="line"><span class="string">51.01.01.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 合并两个 dataframe</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>], index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">abcdbcde</span></span><br><span class="line"><span class="string">10.00.00.00.0NaNNaNNaNNaN</span></span><br><span class="line"><span class="string">20.00.00.00.01.01.01.01.0</span></span><br><span class="line"><span class="string">30.00.00.00.01.01.01.01.0</span></span><br><span class="line"><span class="string">4NaNNaNNaNNaN1.01.01.01.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># append 可以增加行，但不可以增加列</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">s1 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">res = df1.append(df2, ignore_index=<span class="keyword">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">00.00.00.00.0</span></span><br><span class="line"><span class="string">10.00.00.00.0</span></span><br><span class="line"><span class="string">20.00.00.00.0</span></span><br><span class="line"><span class="string">31.01.01.01.0</span></span><br><span class="line"><span class="string">41.01.01.01.0</span></span><br><span class="line"><span class="string">51.01.01.01.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">res = df1.append([df2, df3], ignore_index=<span class="keyword">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  abcd</span></span><br><span class="line"><span class="string">00.00.00.00.0</span></span><br><span class="line"><span class="string">10.00.00.00.0</span></span><br><span class="line"><span class="string">20.00.00.00.0</span></span><br><span class="line"><span class="string">31.01.01.01.0</span></span><br><span class="line"><span class="string">41.01.01.01.0</span></span><br><span class="line"><span class="string">51.01.01.01.0</span></span><br><span class="line"><span class="string">61.01.01.01.0</span></span><br><span class="line"><span class="string">71.01.01.01.0</span></span><br><span class="line"><span class="string">81.01.01.01.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">res = df1.append(s1, ignore_index=<span class="keyword">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">00.00.00.00.0</span></span><br><span class="line"><span class="string">10.00.00.00.0</span></span><br><span class="line"><span class="string">20.00.00.00.0</span></span><br><span class="line"><span class="string">31.02.03.04.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="2-7-pandas-合并-merge"><a href="#2-7-pandas-合并-merge" class="headerlink" title="2.7 pandas 合并 merge"></a>2.7 pandas 合并 merge</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据一组 key 合并</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                     <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                      <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                      <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line">res = pd.merge(left,right,on=<span class="string">'key'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">keyABCD</span></span><br><span class="line"><span class="string">0K0A0B0C0D0</span></span><br><span class="line"><span class="string">1K1A1B1C1D1</span></span><br><span class="line"><span class="string">2K2A2B2C2D2</span></span><br><span class="line"><span class="string">3K3A3B3C3D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 根据两组 key 合并</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>],</span><br><span class="line">                     <span class="string">'key2'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K0'</span>, <span class="string">'K1'</span>],</span><br><span class="line">                     <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>],</span><br><span class="line">                      <span class="string">'key2'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K0'</span>],</span><br><span class="line">                      <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                      <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line">res = pd.merge(left,right,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'inner'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">key1key2ABCD</span></span><br><span class="line"><span class="string">0K0K0A0B0C0D0</span></span><br><span class="line"><span class="string">1K1K0A2B2C1D1</span></span><br><span class="line"><span class="string">2K1K0A2B2C2D2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">res = pd.merge(left,right,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'outer'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">key1key2ABCD</span></span><br><span class="line"><span class="string">0K0K0A0B0C0D0</span></span><br><span class="line"><span class="string">1K0K1A1B1NaNNaN</span></span><br><span class="line"><span class="string">2K1K0A2B2C1D1</span></span><br><span class="line"><span class="string">3K1K0A2B2C2D2</span></span><br><span class="line"><span class="string">4K2K1A3B3NaNNaN</span></span><br><span class="line"><span class="string">5K2K0NaNNaNC3D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'left'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">key1key2ABCD</span></span><br><span class="line"><span class="string">0K0K0A0B0C0D0</span></span><br><span class="line"><span class="string">1K0K1A1B1NaNNaN</span></span><br><span class="line"><span class="string">2K1K0A2B2C1D1</span></span><br><span class="line"><span class="string">3K1K0A2B2C2D2</span></span><br><span class="line"><span class="string">4K2K1A3B3NaNNaN</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'right'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">key1key2ABCD</span></span><br><span class="line"><span class="string">0K0K0A0B0C0D0</span></span><br><span class="line"><span class="string">1K1K0A2B2C1D1</span></span><br><span class="line"><span class="string">2K1K0A2B2C2D2</span></span><br><span class="line"><span class="string">3K2K0NaNNaNC3D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">0</span>,<span class="number">1</span>], <span class="string">'col_left'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],<span class="string">'col_right'</span>:[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]&#125;)</span><br><span class="line">res = pd.merge(df1, df2, on=<span class="string">'col1'</span>, how=<span class="string">'outer'</span>, indicator=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># Indicator</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">0</span>,<span class="number">1</span>], <span class="string">'col_left'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],<span class="string">'col_right'</span>:[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]&#125;)</span><br><span class="line">res = pd.merge(df1, df2, on=<span class="string">'col1'</span>, how=<span class="string">'outer'</span>, indicator=<span class="keyword">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">col1col_leftcol_right_merge</span></span><br><span class="line"><span class="string">00aNaNleft_only</span></span><br><span class="line"><span class="string">11b2.0both</span></span><br><span class="line"><span class="string">22NaN2.0right_only</span></span><br><span class="line"><span class="string">32NaN2.0right_only</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">res = pd.merge(df1, df2, on=<span class="string">'col1'</span>, how=<span class="string">'outer'</span>, indicator=<span class="string">'indicator_column'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">col1col_leftcol_rightindicator_column</span></span><br><span class="line"><span class="string">00aNaNleft_only</span></span><br><span class="line"><span class="string">11b2.0both</span></span><br><span class="line"><span class="string">22NaN2.0right_only</span></span><br><span class="line"><span class="string">32NaN2.0right_only</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 依据 index 合并</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>]&#125;,</span><br><span class="line">                     index=[<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>])</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                      <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;,</span><br><span class="line">                     index=[<span class="string">'K0'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>])</span><br><span class="line">res = pd.merge(left, right, left_index=<span class="keyword">True</span>, right_index=<span class="keyword">True</span>, how=<span class="string">'outer'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">K0A0B0C0D0</span></span><br><span class="line"><span class="string">K1A1B1NaNNaN</span></span><br><span class="line"><span class="string">K2A2B2C2D2</span></span><br><span class="line"><span class="string">K3NaNNaNC3D3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">res = pd.merge(left, right, left_index=<span class="keyword">True</span>, right_index=<span class="keyword">True</span>, how=<span class="string">'inner'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">K0A0B0C0D0</span></span><br><span class="line"><span class="string">K2A2B2C2D2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 使用 suffixes 解决 overlapping 的问题</span></span><br><span class="line">boys = pd.DataFrame(&#123;<span class="string">'k'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>], <span class="string">'age'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">girls = pd.DataFrame(&#123;<span class="string">'k'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K3'</span>], <span class="string">'age'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line">res = pd.merge(boys, girls, on=<span class="string">'k'</span>, suffixes=[<span class="string">'_boy'</span>, <span class="string">'_girl'</span>], how=<span class="string">'inner'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">kage_boyage_girl</span></span><br><span class="line"><span class="string">0K014</span></span><br><span class="line"><span class="string">1K015</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据层的挑战与应对</title>
      <link href="/technology/2019-05-11-java-distributed-system-chapter4/"/>
      <url>/technology/2019-05-11-java-distributed-system-chapter4/</url>
      
        <content type="html"><![CDATA[<p>这一节主要讲数据库的设计，首先要说的就是单机设计方式，一个 JVM 连上一个 DB 完成。</p><h2 id="1-垂直-水平拆分的苦难"><a href="#1-垂直-水平拆分的苦难" class="headerlink" title="1. 垂直/水平拆分的苦难"></a>1. 垂直/水平拆分的苦难</h2><p>除了上升硬件能力以外，我们有什么办法给数据库减压，这里提了三个方法：</p><ol><li>优化应用，减少不必要的数据库压力；</li><li>引入缓存、加入搜索引擎支持；</li><li>分摊 DB 压力，分库分表。</li></ol><p>这一节当然从分库分表开始，<strong>垂直拆分是把同一个数据库里不同业务的数据分到不同的数据库里</strong>；<strong>水平拆分则是根据规则把同一业务的数据拆分到不同数据库里</strong>。</p><p>垂直拆分影响：</p><ol><li>单机 ACID 保障打破，原来的事务处理收到影响，引入分布式事务；</li><li>Join 可能变得复杂，因为数据被分到了不同的库里，需要使用应用或其他方式解决；</li><li>外键约束场景也会相应收到影响。</li></ol><p>水平拆分影响：</p><ol><li>ACID 打破；</li><li>Join 影响；</li><li>外键影响；</li><li>生成 ID 策略收到影响；</li><li>现在单表查询跨库。</li></ol><h2 id="2-事务处理"><a href="#2-事务处理" class="headerlink" title="2. 事务处理"></a>2. 事务处理</h2><p>现在我们就来细聊多库以后事务的支持问题。</p><h3 id="2-1-分布式事务模型与规范"><a href="#2-1-分布式事务模型与规范" class="headerlink" title="2.1 分布式事务模型与规范"></a>2.1 分布式事务模型与规范</h3><p>X/Open 组织提出的分布式事务规范——XA。我们先把 XA 当黑盒，先来看看 DTP (X/Open Distributed Transaction Processing Reference Model)模型。其中包含三个组件：Application Program、Resource Manager 和 Transaction Manager 。</p><ol><li>AP 即应用程序，它定义了事务的边界；</li><li>RM 资源管理器，即一个 DBMS 系统，或者一个消息服务器管理系统，AP 通过 RM 对资源进行管理，资源实现 XA 实现的接口；</li><li>TM 事务管理器，负责协调和管理事务，给事务指定标识，监控他们的进程，其标识即事务分支标识 XID ，由 TM 指定。</li></ol><p>如图可以看到三者的通信关系。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200322215851.png" alt></p><p>AP 与 RM 是一定要存在的，而 TM 则是人为加入的，因为我们需要给多台机器<strong>达到一致的状态</strong>，因此需要这个单点来进行调节。</p><p>此外，DTP 中还有几个概念：</p><ol><li>事务：一个完整工作的单元；</li><li>全局事务：一次操作多个 RM 的事务叫做全局事务；</li><li>分支事务：全局事务中，每一个 RM 所对应任务的集合就是分支事务；</li><li>控制线程：事务上下文环境，用来关联 AP RM TM 三者。</li></ol><p>下图是完整的 DTP 模型。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20200323000432.png" alt></p><p>上图重点在于 AP RM TM 三者之间的关系。</p><ol><li>AP 与 RM 之间：使用 RM 自身提供的 native API ，当开始分布式事务的时候，AP 需要得到 RM 的连接，此连接由 TM 管理，然后使用 XA specific native API 交互；</li><li>AP 与 TM 之间：图中为 TX 接口，也是 X/Open 规范的。主要用于控制事务，比如启动、提交、回滚；</li><li>TM 与 RM 之间：通过 XA 接口进行交互，TM 管理了 RM 的连接。</li></ol><h3 id="2-2-二阶段提交"><a href="#2-2-二阶段提交" class="headerlink" title="2.2 二阶段提交"></a>2.2 二阶段提交</h3><p>2PC ，Two Phase Commitment Protocol ，二阶段是对于单库事务提交来说的。单库中我们 DB 完成后「提交」或「回滚」，而这里我们增加了一步——「准备」，因此称作二阶段。</p><p>顾名思义，二阶段就有两个阶段，我们这里假设存在两个「资源」需要进行同步的操作，可以看到如下两个阶段。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/二阶段流程.jpg" alt></p><p>可以发现主要的参与者仅有 TM 与两个资源对象，值得注意的是，如果在「准备」阶段有一个资源准备失败了，那么二阶段的处理就是回滚所有的资源。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/二阶段失败.jpg" alt></p><p>网络上交互的增加以及引入 TM 的开销，是使用 2PC 事务开销大的两个重要方面。</p><h3 id="2-3-CAP-BASE"><a href="#2-3-CAP-BASE" class="headerlink" title="2.3 CAP/BASE"></a>2.3 CAP/BASE</h3><p>CAP 理论相当经典：</p><ul><li>Consistency: all nodes see the same data at the same time. 所有节点同时看到相同的数据；</li><li>Availability: a guarantee that every request receives a response about whether it was successful or failed. 保证成功还是失败，只能二选一；</li><li>Partition-Tolerance: the system continues to operate despite arbitrary message loss or failure of part of the system. 即使系统有部分问题或消息丢失，但是系统依然可以运行，即分区容忍。</li></ul><p>我们只能同时选择三者的其中两者。</p><ul><li>CA，放弃分区容忍，加强了一致性和可用性。这是传统单机的做法；</li><li>AP，放弃一致性，追求分区容忍和可用性。这是很多分布式系统的选择，例如很多 NoSQL 就是如此；</li><li>CP，放弃可用性，追求一致性和分区容忍性。这种选择可用性比较低，主要问题在于网络导致系统不可用。</li></ul><p>主流方案是 AP ，并不是不关心 C ，而是在 AP 满足的基础上再考虑 C 。</p><p>再来看看 BASE 模型：</p><ul><li>Basically Available：基本可用，允许分区失败；</li><li>Soft state：软状态，接收一段时间的状态不可用；</li><li>Eventually consistent：最终一直，保证最终数据状态一致。</li></ul><p>可以发现选择了 AP 以后和 BASE 模型是相通的。</p><h3 id="2-4-Paxos-协议"><a href="#2-4-Paxos-协议" class="headerlink" title="2.4 Paxos 协议"></a>2.4 Paxos 协议</h3><p>它把二阶段要轻量一些，节点之间的交互有两种方式：</p><ol><li>共享内存共用一份数据；</li><li>消息传递信息。</li></ol><p>消息在传递过程中容易出现失败，而 Paxos 就是帮助解决「一致性问题」的一个方案。</p><p>Paxos 的前提是不存在「拜占庭将军问题」。也就是说需要保证当前是一个可信的通信环境，消息都是准确的。</p><p>我们假设有三种角色的节点，Proposers Acceptors Learners :</p><ul><li>Proposers，提议者，提出议案的角色；</li><li>Acceptors，接收者，收到议案后进行判断的角色，可以选择「接收」，若议案被大部分接收者「接收」，则议案会被「批准」即 Chosen ；</li><li>Learners，学习者，只能学习被「批准」的议案的角色。</li></ul><blockquote><p>每个角色可以身兼数职。</p></blockquote><p>这里有两个重要的名词：</p><ul><li>Proposal，议案，由 Proposers 提出，被 Acceptors 「批准」或「否决」；</li><li>Value，决议，每个决议都有是一由二元组 <code>{编号，决议}</code> 组成。</li></ul><p>Paxos 在解决的问题用上面这些名词来描述的话，就是：</p><ul><li>Value 只有被 Proposers 提出后才能被 Chosen（未 Chosen 的决议叫做 Proposal ）；</li><li>在 Paxos 的执行过程中，一次只能 Chosen 一个 Value；</li><li>Learners 只能获得被 Chosen 的 Value 。</li></ul><p>每个角色都会进行记录，记录中 Proposal 不会被改变，而有些信息可以改变：</p><ul><li>LastTried[p]，由角色 p 试图发起的最后一个 Proposal 的编号，初始值为 -∞ ；</li><li>PreviousVote[p]，角色 p 投票的所有 Proposal 中，编号最大的 Proposal 对应的投票，初始值为 -∞ ；</li><li>NextBallot[p]，角色 p 发出所有 LastVote(b,v) 消息中，Proposal 编号 b 的最大值。</li></ul><p>那么 Paxos 的流程就可以这样理解：</p><ol><li>角色 p 选择一个比 LastTried[p] 大的 Proposal 编号 b ，设置 LastTried[p] 为 b ，然后将 NextBallot(b) 发送给其他角色；</li><li>在 p 收到一个 b &gt; NextBallot[q] 的 NextBallot(b) 消息后，角色 q 将 NextBallot[q] 设置成 b ，然后发出一条 LastVote(b,v)，其中 v = PreviousVote[q] ；</li></ol><blockquote><p>这里比较绕的点是 p 收到 q 的消息，且这条消息的 NextBallot 要比 b 小，如果说 NextBallot[q] &lt;= b ，则忽略。</p></blockquote><ol><li>然后奇妙的事情发生了，当一个集合 Q 的所有人都收到一个 LastVote(b,v) 后，角色 p 就会发起一个「编号为 b ，人数为 Q ，Proposal 为 d 」的表决，然后 p 给这个 Q 里每一个人都发送一个 BeginBallot(b,d) 的消息；</li><li>在收到一个 b = NextBallot[q] 的 BeginBallot(b,d) 的消息后，人员 q 在编号为 b 的 Proposal 中投票，设置 PreviousVote[q] 为这一票，然后向 p 发送了 Voted(b,q) 消息；</li><li>p 收到了 Q 中每一个 q 的 Voted(b,q) 后（此时 LastTried[p]==b），将 Proposal d 的记录记下，发送 Success(d) 给每一个 q ；</li><li>每一个人收到 Success(d) 后，将 Proposal d 记下。</li></ol><p>如果一个系统中同时有人提案，可能会出现碰撞失败，然后双方都需要增加议案的编号再进行提交；如果此时提交仍然可能出现冲突，因此双方需要继续增加编号。这就产生了「活锁」，且永远没有尽头。</p><p>解决方法是整个集群里只有一个 Leader ，所有的 Proposal 都由他提出，而 Leader 出现了问题就需要重新选举。</p><h3 id="2-5-集群内数据一致性"><a href="#2-5-集群内数据一致性" class="headerlink" title="2.5 集群内数据一致性"></a>2.5 集群内数据一致性</h3><p>这里讲的是亚马逊 Dynamo 的论文中 Quorum 和 Vector Clock 算法的比较详情。</p><p>首先是关于 Quorum 算法，它用来权衡分布式系统中数据一致性与可用性，其中有是三个变量：</p><ol><li>N：数据复制节点数</li><li>R：成功读操作的最小节点数</li><li>W：成功写操作的最小节点数</li></ol><p>如果 W+R&gt;N ，是可以保证强一致性的，而如果 W+R≤N ，则是可以保证最终一致性的。</p><p>根据 CAP 理论，举个例子，如果使 N=W ，而 R=1 ，则可用性会大大降低，但是一致性是最好的。</p><hr><p>而 Vector Clock 的思路是对同一份数据的每一次修改都加上 <code>&lt;修改者，版本号&gt;</code> 的二元组，在现实生活中我们往往不能在一群中达到一个一致结果，在计算机这样的虚拟世界里这样的问题尤为重要，而「时间」是 Vector Clock 算法的核心，所有结果都带上时间。</p><p>假设现在有四个人：Alice Ben Catby Dave 。Alice 说周三聚餐，Dave 和 Catby 商量改周四，Dave 又和 Ben 商量改周二，最后 Alice 汇总大家的结果。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/Vector Clock.jpg" alt></p><p>现在 Alice 收到来自 Ben 的消息是周四，收到来自 Catby 的消息同样是周四（这里有一个选择，Dave 第二次的决定是周二还是周四，这里假设是 Dave 第二次依然决定是周四，没有同意改成周二），答案就有解了。</p><h2 id="3-多机-Sequence-问题"><a href="#3-多机-Sequence-问题" class="headerlink" title="3. 多机 Sequence 问题"></a>3. 多机 Sequence 问题</h2><p>水平分库以后，单表放在多机上，自然自增 id 不能用了，连续 id 有两个特性：</p><ul><li>唯一性</li><li>连续性</li></ul><p>从唯一性可以想到简单的 UUID ，或者根据 IP MAC 时间 机器等生成一个唯一的 id ，但是连续性并不好。</p><p>有一种较为主流的实现方式是把所有 id 在一个地方进行管理，这里有几个关键问题。</p><ol><li>性能问题：每次远程获取 id 都有资源消耗，一种方式是一次取一批 id ，然后缓存在本地，但是如果此时宕机，那么这些 id 就浪费了；</li><li>稳定性问题：id 生成器其稳定性要靠整个集群来保证；</li><li>存储问题：底层存储的选择空间很大，根据不同的类型进行容灾方案。</li></ol><p>下面有两种存储方案，一种是在底层使用一个独立的存储来记录每个 id 序列当前的最大值，并控制并发更新：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/独立id生成器.jpg" alt></p><p>另一种则是直接把整个 id 生成器舍弃，把相关逻辑放到需要生成 id 的应用本身：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/内嵌生成器.jpg" alt></p><p>但是因为没有中心节点，我们还是希望生成器之间有通信，管理上也需要额外的功能。</p><h2 id="4-多机查询"><a href="#4-多机查询" class="headerlink" title="4. 多机查询"></a>4. 多机查询</h2><p>分库以后，存在问题解决了，读的问题仍然存在，我们还是要把数据从不同机器 join 到一个库里，解决记录有如下几种。</p><ol><li>在应用层把原来的数据库的 join 操作分成多次的数据库操作，说白了就是原来的 join 不用了，用逻辑来连接；</li><li>数据冗余，把一些常用数据冗余，去除 join 操作；</li><li>借助外部系统比如搜索引擎来解决跨库问题。</li></ol><p>假设用户信息根据地域进行划分，一个数据库分成多个库，而库中有多个表，如图。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/分库分表.jpg" alt></p><p>我们在查询的时候可能会遇到跨库、跨表的问题，结果处理还是相对简单，但是有写场景需要特殊处理：</p><ol><li>排序：如果各自有序应该用多路归并，如果各自无序则全排；</li><li>函数处理：使用 Max Min Sum Count 等对多个数据来源的值进行相应函数处理；</li><li>求平均值：这没啥好说的其实，多个数据源的 Sum 求和计算平均即可；</li><li>非排序分页：看属于「同等步长的分页」还是「同等比例的分页」，前者是说同页中来自不同数据源的记录数相同；后者是说同页中来自不同数据源的数据占数据总数的比例是一样的；</li><li>排序后分页：这个最复杂，需要把排序和分页放在一起的情况，我们需要每个数据源结果都排好序，然后在取下一页的时候每个数据源都给出足量的数据进行排序，约到后面负担越大，比如第100页，需要每个数据源把前100页都取出进行归并，才能得到正确的结果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 大型网站系统与 Java 中间件开发实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从服务框架开始</title>
      <link href="/technology/2019-04-24-java-distributed-system-chapter3/"/>
      <url>/technology/2019-04-24-java-distributed-system-chapter3/</url>
      
        <content type="html"><![CDATA[<p>服务拆分在项目中是有帮助的，但是有帮助的「度」也存在，因为还有诸如「不同系统中存在代码冗余」等问题。等好的方式应该是<strong>服务化</strong>，就是将系统分层。</p><blockquote><p>服务化就是之前提到的概念，存在多层，比如：<strong>顶层 Web 系统，中间服务中心，底层数据库</strong>。</p></blockquote><h2 id="1-远程调用"><a href="#1-远程调用" class="headerlink" title="1. 远程调用"></a>1. 远程调用</h2><p>服务化带来了各种各样的问题，内部系统依赖变得错综复杂，我们需要解决它所带来的问题。</p><p>没有服务化之前，我们通过「本地调用」的方式使用其他组件，服务化以后我们需要使用的是「远程调用」，这里我们需要关注<strong>提高易用性</strong>与<strong>降低性能损失</strong>两个问题。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190506131333.png" alt></p><p><strong>因此一个通用的服务框架，要先完成 RPC 功能，为服务使用者提供相应的客户端</strong>。多机之间，我们需要对请求进行编码，传到远程节点，解码后进行真正的调用。</p><blockquote><ul><li>寻址路由：「调用方」确定哪个实例被调用。</li><li>实例地位：「被调用方」找到对应的实例进行调用。</li></ul></blockquote><h2 id="2-服务框架原型"><a href="#2-服务框架原型" class="headerlink" title="2. 服务框架原型"></a>2. 服务框架原型</h2><p>上面的图只是一个从一端到另外一端的请求，服务框架是一个<strong>既包含调用端逻辑又包含服务端逻辑的一个是实现</strong>。</p><p>在远程调用中，一般有如下的「请求流程」：</p><ol><li>获取可用服务地址列表；</li><li>确定调用的目标机器； // 这两步完成「寻址路由」，方式很多，规则服务器、名称服务等等。</li><li>建立连接；</li><li>请求序列化；</li><li>发送请求；</li><li>接收结果；</li><li>解析结果。</li></ol><p>而对于「服务端」而言，也要加入请求的处理：接收比特流，「实例定位」，返回结果。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190506132735.png" alt></p><h2 id="3-消费者设计"><a href="#3-消费者设计" class="headerlink" title="3. 消费者设计"></a>3. 消费者设计</h2><p>假设用 Spring 作为一个服务的框架，在 Bean 的定义中，需要指定这些 Bean 属性：「interfaceName」、「version」、「group」。</p><p>在本地通过「动态代理」的方式实现方法的调用。</p><ol><li>首先需要「interfaceName」确认被调用接口是哪一个，显然使用的是全限定名；</li><li>接着「version」主要用以升级的场景，让版本存在隔离；</li><li>最后「group」，假设同一个服务有很多机器，我们可以把这些服务的机器归组，选择不同的组来调用。</li></ol><p>「服务框架」可以作为：Web 应用的扩展（jar 包）、Web 容器的一部分（Web 应用）、本身作为容器。这些都可行，在开发中应该根据不同的场景来进行选择。</p><h3 id="3-1-通信问题"><a href="#3-1-通信问题" class="headerlink" title="3.1 通信问题"></a>3.1 通信问题</h3><p>我们的假想中调用的服务是一台的，但实际中一定是多台的集群：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190506135606.png" alt></p><p>处理方式多种，可以采用「透明代理」或者「直连」的方式，主流采用「直连」的方式：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190506135756.png" alt></p><p>引入一个「注册中心」来支持查找，让客户端拿到服务提供者列表，然后就是「路由」的问题了。</p><h3 id="3-2-路由问题"><a href="#3-2-路由问题" class="headerlink" title="3.2 路由问题"></a>3.2 路由问题</h3><p>「基于接口、方法、参数的路由」也是我们要解决的问题。下面两个调用者可能都调用同一个服务：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190506192126.png" alt></p><p>假设现在接口 A 的方法 1 是比较慢的方法，可能会陷入不断的等待：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190506221252.png" alt></p><p>我们会发现执行过程中很容易陷入 IA.m1 方法的等待队列，简单处理可以「增加资源保证系统能力」，另一种一种可行的方式「隔离资源」。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190506221815.png" alt></p><p>现在只有接口 A 的方法 2 会收到接口 A 方法 1 的影响了，那么我们可以对路由更加细致一点，可以基于「具体方法进行路由」，而不是「基于接口进行路由」，沿着这个思路，还有「基于参数进行路由」的选择。</p><h3 id="3-3-多机房场景"><a href="#3-3-多机房场景" class="headerlink" title="3.3 多机房场景"></a>3.3 多机房场景</h3><p>如果在「服务注册中心」和「调用者」、「提供者」之间加上「机房」的概念。我们可以在「路由」中下文章：</p><p>给不同机房的调用者相同的服务提供者列表，然后根据「虚拟机房」等策略完成路由，一般是基于接口的路由（服务框架进行集中配置管理）。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508201105.png" alt></p><p>另外流控是为了保证系统的稳定性，序列化是为了传输对象，网络一般采用 NIO ，这些都是老生常谈了。</p><h3 id="3-4-多种异步调用"><a href="#3-4-多种异步调用" class="headerlink" title="3.4 多种异步调用"></a>3.4 多种异步调用</h3><ul><li>Oneway<ul><li>只管发送不关心结果的方式。只需要把发送的数据放入数据队列，然后继续处理后续任务；而 IO 线程也只需要从数据队列中读到数据，然后通过 Socket 连接发送出去即可。它是<strong>不保证可靠传达</strong>的通知。</li></ul></li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508203823.png" alt></p><ul><li>Callback<ul><li>请求发送方发送请求后会继续执行自己的操作，等对方有响应时进行一个回调。</li></ul></li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508203944.png" alt></p><ul><li>Future<ul><li>先把 Future 放入队列，然后把数据放入队列，接着就在线程中进行处理，等到请求线程在其他工作处理结束后，就通过 Future 来获取通信结果并直接控制超时。</li></ul></li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508204130.png" alt></p><ul><li>可靠异步<ul><li>一般通过消息中间件完成。</li></ul></li></ul><h2 id="4-提供者设计"><a href="#4-提供者设计" class="headerlink" title="4. 提供者设计"></a>4. 提供者设计</h2><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508204404.png" alt></p><p>在服务端我们也要像调用端一样设置特殊字段，以此暴露出远程服务的具体接口。</p><p>具体的请求流程从「网络通信层」一直延续到调用「具体服务」：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508204802.png" alt></p><h3 id="4-2-不同服务的线程隔离"><a href="#4-2-不同服务的线程隔离" class="headerlink" title="4.2 不同服务的线程隔离"></a>4.2 不同服务的线程隔离</h3><p>值得注意的是，服务端线程池不是一个，定位服务以后，根据名称、方法、参数等信息来决定具体执行服务调用的线程池是哪一个，不会出现争抢线程资源的情况：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508205011.png" alt></p><h3 id="4-3-分布式环境合并请求"><a href="#4-3-分布式环境合并请求" class="headerlink" title="4.3 分布式环境合并请求"></a>4.3 分布式环境合并请求</h3><p>我们知道，合并请求的线程流程如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508205210.png" alt></p><p>但是在分布式环境中，会有新的问题，需要使用「分布式锁」或者「路由」：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508205249.png" alt></p><p>具体场景需要具体分析。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>服务框架为我们从集中式系统转向分布式系统提供了基础支持：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190508205514.png" alt></p><p>完成服务框架，还需要针对自身环境完成工作，以助于开发中定位和发现问题。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 大型网站系统与 Java 中间件开发实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站架构演进过程</title>
      <link href="/technology/2019-04-23-java-distributed-system-chapter2/"/>
      <url>/technology/2019-04-23-java-distributed-system-chapter2/</url>
      
        <content type="html"><![CDATA[<p><strong>中间件系统也是在大型网站的架构变化中出现并发展的</strong>。</p><p>访问量大的网站不一定是大型网站，<strong>大型网站</strong>应该有大量的数据，或者说是海量的数据，<strong>访问量和数据量缺一不可</strong>。</p><h2 id="1-1-数据库与应用分离"><a href="#1-1-数据库与应用分离" class="headerlink" title="1.1 数据库与应用分离"></a>1.1 数据库与应用分离</h2><p>我们关注的重点是随着<strong>数据量</strong>、<strong>访问量</strong>，网站也将因此产生结构上的变化，而不关注具体的业务功能点。</p><p>随着数据访问量不断增大，服务器的负载持续升高，此时我们可以通过将数据库和应用从一台机器分到两台机器上来进行优化，即<strong>数据库与应用分离</strong>。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190427222026.png" alt></p><h2 id="1-2-走向集群"><a href="#1-2-走向集群" class="headerlink" title="1.2 走向集群"></a>1.2 走向集群</h2><p>在增加一台服务器以后，<strong>可以通过 DNS 解决，也可以通过在服务器集群前增加负载均衡设备来解决</strong>。同时我们还需要处理 Session 问题。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190427224601.png" alt></p><p>这是加入负载均衡器以后的样子：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190427224807.png" alt></p><h3 id="1-2-1-Session-Sticky"><a href="#1-2-1-Session-Sticky" class="headerlink" title="1.2.1 Session Sticky"></a>1.2.1 Session Sticky</h3><p>对于 Session 问题，我们有多种解决方式。<strong>Web 服务器有多台以后，如果保证同一个会话的请求都在同一个 Web 服务器上处理，那么对于这个会话而言，它还是单机</strong>。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190427225014.png" alt></p><p>我们只需要在「负载均衡器」上动手脚，就可以办到。但是有许多问题：</p><ul><li>如果一台 Web 服务器宕机，那么这台机器上的数据就会丢失；</li><li>会话标识是应用层的信息，「负载均衡器」要将「一个会话」的请求都保存在一个 Web 服务器上，就需要进行应用层的解析，这个开销比第4层的交换要大；</li><li>负载均衡器变为一个有状态的节点，要将会话保存到具体的 Web 服务器的映射，和无状态的节点相比，消耗内存更大，容灾更麻烦。</li></ul><h3 id="1-2-2-Session-Replication"><a href="#1-2-2-Session-Replication" class="headerlink" title="1.2.2 Session Replication"></a>1.2.2 Session Replication</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502175612.png" alt></p><p><strong>现在，不再要求负载均衡器来保证同一个会话的多次请求必须到同一个 Web 服务器上</strong>，而我们的 Web 服务器之间增加了会话的同步，通过同步就保证了不同 Web 服务器之间的 Session 数据一致。它的问题：</p><ul><li>同步 Session 数据造成了网络带宽的开销，<strong>只要 Session 数据有变化，就需要将数据同步到所有的机器上</strong>，机器数越多，同步带来的网络带宽开销就越大；</li><li>每台 Web 服务器都要保存所有的 Session 数据，如果整个集群的 Session 数据很多的话，<strong>每台机器用于保存 Session 数据的内容占用会很严重</strong>。</li></ul><blockquote><p>如果只有几台机器，这个方案是可行的。</p></blockquote><h3 id="1-2-3-Session-数据集中存储"><a href="#1-2-3-Session-数据集中存储" class="headerlink" title="1.2.3 Session 数据集中存储"></a>1.2.3 Session 数据集中存储</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502180715.png" alt></p><p>我们把 Session 数据集中存储起来，然后不同 Web 服务器从同样的地方来获取 Session ，<strong>会话请求经过负载均衡器后，不会固定在同样的 Web 服务器上，且 Web 服务器上不再需要 Session 数据复制了</strong>，它的问题：</p><ul><li>读写 Session 引入了网络操作，这相对于本机的数据读取来说，问题在于存在时延和不稳定性，不过通信都发生在内网中，问题不是很大；</li><li>如果集中存储 Session 的机器或者集群出现问题，会影响我们的应用。</li></ul><h3 id="1-2-4-Cookie-Based"><a href="#1-2-4-Cookie-Based" class="headerlink" title="1.2.4 Cookie Based"></a>1.2.4 Cookie Based</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502181811.png" alt></p><p>所谓「Cookie Based」对于同一个会话的不同请求也是不限制具体处理机器的，<strong>它通过 Cookie 来传递 Session 数据</strong>。它的问题：</p><ul><li>Cookie 是有长度限制的，这也限制了 Session 数据的长度；</li><li>安全性，Session 数据本来是服务端的，这个方案可以对 Session 数据进行加密，但是从物理上禁止接触才是安全的；</li><li>带宽消耗，我们需要传输的内容增加了；</li><li>性能影响，每次 HTTP 请求和响应都带有 Session 数据，Web 服务器在同样的处理下，响应的结果输出越少，支持的并发请求就会越多。</li></ul><blockquote><p>具体情况具体分析，没有绝对的好与不好。</p></blockquote><h2 id="1-3-读写分离"><a href="#1-3-读写分离" class="headerlink" title="1.3 读写分离"></a>1.3 读写分离</h2><h3 id="1-3-1-采用数据库作为读库"><a href="#1-3-1-采用数据库作为读库" class="headerlink" title="1.3.1 采用数据库作为读库"></a>1.3.1 采用数据库作为读库</h3><p>随着业务的发展，我们的数据量和访问量都在提升，对于大型网站来说，<strong>不少业务都是读多写少的</strong>，这个状况也会直接反应到数据库上，那么对于这样的情况，我们可以考虑使用<strong>读写分离</strong>的方式。</p><p>我们给系统加上一个读库：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502185114.png" alt></p><p>这个架构有两个问题：</p><ul><li>数据复制问题；</li><li>应用对于数据源的选择问题。</li></ul><p>数据复制延迟带来的就是短期的数据不一致，比如 MySQL 支持 Master + Slave 的结构，提供了数据复制的机制，在 MySQL 5.5 之前的版本支持的都是异步的数据分支，会有延迟，并且是完全镜像方式的复制，保证了备库和主库的数据一致性，<strong>而在 MySQL 5.5 中加入了 semi-sync 办同步的支持</strong>，它比异步复制要好。主库写入 binlog 之后，会强制此时立即将数据同步到从库，从库将日志写入本地的 relay log 之后，会返回一个 ack 到主库，主库接到至少一个从库的 ack 才认为这条 binlog 写成功。<strong>所谓半同步，是说从库将数据拉到 relay log 就算同步成功了</strong>。</p><p>写操作走主库，读走从库，<strong>而事务中的读走主库</strong>，所以，不同业务下的选择是有差异的。</p><h3 id="1-3-2-搜索引擎其实是一个读库"><a href="#1-3-2-搜索引擎其实是一个读库" class="headerlink" title="1.3.2 搜索引擎其实是一个读库"></a>1.3.2 搜索引擎其实是一个读库</h3><p>在搜索的时候，我们可以想到使用数据库的 like 功能，这种实现的代价很大，我们还可以使用<strong>搜索引擎的倒排表方式</strong>，它大大提升了检索速度，如何对记录进行排序是很重要的。</p><p>搜索引擎的功能，首先就是需要根据被搜索的数据来构建索引。随着被搜索的数据的变化，索引也要变化，什么样的数据走搜索，什么样的数据走数据库，其实<strong>构建搜索的过程就是一个数据复制的过程</strong>。</p><p>加入搜索引擎以后系统的结构：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502192538.png" alt></p><p>可以看到集群 Search Cluster 的使用方式和读库的使用是一样的，只是「构建索引的过程」基本都是我们自己来实现的，我们从两个维度对搜索系统构建索引的方式进行划分：</p><ul><li>全量/增量划分；</li><li>实时/非实时划分。</li></ul><p>全量用于第一次建立索引，而增量用于在全量基础上持续更新索引；实时体现在索引更新的时间上，非实时主要考虑对数据源头的保护。</p><h3 id="1-3-3-缓存"><a href="#1-3-3-缓存" class="headerlink" title="1.3.3 缓存"></a>1.3.3 缓存</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502194611.png" alt></p><p>大体上我们将缓存分为：</p><ul><li>数据缓存：一般在缓存中的数据是 key-value 这样的键值对，而在其中我们放的是<strong>热数据</strong>；</li><li>页面缓存：一般「数据缓存」用来加快请求时的数据读取，但最终我们返回给用户的还是页面，有些动态生成的页面或者一部分特别热，我们可以对这些内容进行缓存。<ul><li>以前的方式是使用 Apache 的 ESI 模块，但是这个过程需要对响应结果进行分析，对于不存在内容，会通过 Web 服务器去渲染，再放入缓存中，返回给浏览器；</li><li>改进后，可以使用比如 JBoss 的 ESI 功能，它在 Web 浏览器中完成渲染和缓存相关的功能，这样更高效，但是没有前一种分工明确。</li></ul></li></ul><h2 id="1-4-分布式存储系统"><a href="#1-4-分布式存储系统" class="headerlink" title="1.4 分布式存储系统"></a>1.4 分布式存储系统</h2><p>前面，我们把目光集中在数据库，没有错误，因为数据库就是我们性能上遇到的一重大山，<strong>但是很多场景下，数据库并不是很合适</strong>，也就是分布式存储系统。</p><p>分布式存储系统提供一个高容量、高并发、数据冗余容灾的支持，具体有三个常见类：</p><ul><li>通过分布式文件系统解决小文件和大文件的存储问题；</li><li>通过分布式 Key-Value 系统提供高性能的半结构化支持；</li><li>通过分布式数据库提供一个支持大数据、高并发的数据库系统。</li></ul><p>现在我们的系统大概长这样：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502195810.png" alt></p><h2 id="1-5-读写分离后数据库拆分"><a href="#1-5-读写分离后数据库拆分" class="headerlink" title="1.5 读写分离后数据库拆分"></a>1.5 读写分离后数据库拆分</h2><p>随着业务的增加，我们的主库也会遇到瓶颈，现在我们有数据库垂直和水平拆分两种选择。</p><h3 id="1-5-1-垂直拆分"><a href="#1-5-1-垂直拆分" class="headerlink" title="1.5.1 垂直拆分"></a>1.5.1 垂直拆分</h3><p><strong>换句话说，比如可以把不同业务数据拆分到不同的数据库中，当然，拆法不唯一</strong>。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502200143.png" alt></p><p>这样做的影响是，我们多了很多数据源是肯定的，每个数据库连接池的隔离，还有<strong>跨业务事务处理</strong>，两种主流处理方式：</p><ul><li>分布式事务；</li><li>去掉事务或者不去追求强事务支持。</li></ul><blockquote><p>垂直拆分解决业务数据都放到一个数据库中的压力问题。</p></blockquote><h3 id="1-5-2-水平拆分"><a href="#1-5-2-水平拆分" class="headerlink" title="1.5.2 水平拆分"></a>1.5.2 水平拆分</h3><p><strong>水平拆分就是把一个表的数据拆到两个数据库中</strong>，这是因为数据量或者更新量太大。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502200908.png" alt></p><p>之后要解决这些问题：</p><ul><li>数据库的路由，现在有两个库了，数据库操作应该了解操作的数据在哪儿。</li><li>主键处理，原来依赖单个数据库的一些机制需要变化，原来使用的自增字段，现在不能用自增来保证主键不重复了。</li><li>一些操作需要同时两个表，比如分页操作等。</li></ul><blockquote><p>好处在于一旦完成，我们可以很好应对写入增长的情况。</p></blockquote><h2 id="1-6-数据库问题外的挑战"><a href="#1-6-数据库问题外的挑战" class="headerlink" title="1.6 数据库问题外的挑战"></a>1.6 数据库问题外的挑战</h2><h3 id="1-6-1-拆分应用"><a href="#1-6-1-拆分应用" class="headerlink" title="1.6.1 拆分应用"></a>1.6.1 拆分应用</h3><p>前面我们都在解决数据层面的问题，现在我们要考虑的<strong>是不让应用持续变大</strong>，需要将应用拆分，从一个应用编程两个或者多个应用。</p><p>一个简单的方式是根据应用特性把应用拆分，这样可以把一个大应用变小。并且这些业务应用之间不存在直接调用，它们都依赖底层的数据库、缓存、文件系统、搜索等。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502201556.png" alt></p><h3 id="1-6-2-走向服务化"><a href="#1-6-2-走向服务化" class="headerlink" title="1.6.2 走向服务化"></a>1.6.2 走向服务化</h3><p>这是一个服务化系统结构的简图：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502201706.png" alt></p><p>顶层 Web 系统，中间服务中心，底层数据库。</p><p>各个服务中心可能不在一个机器上，当然其他 Web 系统或者数据库可能也不在一个机器上，所以主要通过远程调用的形式交互，连接数据库的事情交给了数据库，更好控制系统本身的发展。</p><h2 id="1-7-消息中间件"><a href="#1-7-消息中间件" class="headerlink" title="1.7 消息中间件"></a>1.7 消息中间件</h2><p>Message-oriented middleware MOM 消息中间件，<strong>它是在分布式系统中完成消息的发送和接收的基础软件</strong>。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190502202115.png" alt></p><p>它最大的两个好处：异步、解耦。应用 A 和应用 B 都和消息中间件打交道，而这两个应用并不会直接联系。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 大型网站系统与 Java 中间件开发实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探分布式系统</title>
      <link href="/technology/2019-04-22-java-distributed-system-chapter1/"/>
      <url>/technology/2019-04-22-java-distributed-system-chapter1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>A distributed system is one in which components located at networked computers communicate and coordinate their actions only by passing messages.</p></blockquote><p>重点在于：<strong>分布在网络计算机上</strong>，以及<strong>仅仅通过消息传递来通信并协调行动</strong>。</p><p><em>为什么我们尝试使用分布式系统？</em></p><ul><li>升级单机处理能力的性价比越来越低。</li><li>单机处理能力存在瓶颈。</li><li>处于稳定性和可用性的考虑。</li></ul><blockquote><p>摩尔定律：当价格不变时，每隔18个月，继承电路上可容纳的晶体管数量就会增加一倍，性能也将提升一倍。</p></blockquote><p><em>对于上面问题有对应的三个解答：</em></p><ul><li>在同一时间点，通过更换硬件做<strong>垂直扩展</strong>的方式来提升性能会<strong>越来越不划算</strong>。</li><li>某个固定时间点，单颗处理器有自己的<strong>性能瓶颈</strong>，也就是说即使你花费更多的钱去买计算力也买不到。</li><li><strong>分布式系统将带来稳定性、可用性的提升</strong>。</li></ul><p>通过阿姆达尔定律可以看到，程序中串行部分对于增加 CPU 核心来提升处理速度存在限制，它是这样描述的：</p><script type="math/tex; mode=display">S ( N ) = \frac { 1 } { ( 1 - P ) + \frac { P } { N } }</script><blockquote><p>其中，P 指的是程序中可并行部分的程序在单核上执行时间的占比，N 表示处理器的个数(总核心数)。S(M) 是指程序在 N 个处理器(总核心数)相对在单个处理器(单核)中的速度提升。</p></blockquote><h2 id="1-1-多线程交互模式"><a href="#1-1-多线程交互模式" class="headerlink" title="1.1 多线程交互模式"></a>1.1 多线程交互模式</h2><h3 id="1-1-1-互不通信的多线程模式"><a href="#1-1-1-互不通信的多线程模式" class="headerlink" title="1.1.1 互不通信的多线程模式"></a>1.1.1 互不通信的多线程模式</h3><p>多个线程独立完成自己的任务：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190422125909.png" alt></p><h3 id="1-1-2-基于共享容器协同的多线程模式"><a href="#1-1-2-基于共享容器协同的多线程模式" class="headerlink" title="1.1.2 基于共享容器协同的多线程模式"></a>1.1.2 基于共享容器协同的多线程模式</h3><p>通过共享的数据进行处理，比如生产者和消费者模式，我们可以使用<strong>队列</strong>用于生产和消费，多个线程会并发访问这个队列：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190422130045.png" alt></p><p>此时，我们需要保护和控制以保证访问的正确性，对于线程不安全的容器或对象，一般可以通过加锁或者通过 Copy On Write 的方式来控制并发访问。</p><p>值得注意的是，我们在使用一些线程安全的容器，如『ConcurrentHashMap』的时候，它是线程安全的，但我们的一些操作可能是线程不安全的，比如，一个整形自增，取是一个操作，增是一个操作，它不是一个原子操作，所以做 <code>i++</code> 的时候，结果不一定正确，我们可以采用原子类等方式完成这个功能。</p><h3 id="1-1-3-通过事件协同的多线程模式"><a href="#1-1-3-通过事件协同的多线程模式" class="headerlink" title="1.1.3 通过事件协同的多线程模式"></a>1.1.3 通过事件协同的多线程模式</h3><p>例如 A B 两个线程，B 线程需要等到某个状态或事件发生才能继续自己的工作，而这个状态改变或者事件产生与 A 相关，这个场景下，就需要线程间的协调。</p><p>下面的过程中，线程 B 将会等待线程 A 的执行，<strong>原子性获得需要的锁或者注意调整多个锁的获取顺序，可以有效避免死锁</strong>：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190422133802.png" alt></p><h2 id="1-2-多进程模式"><a href="#1-2-多进程模式" class="headerlink" title="1.2 多进程模式"></a>1.2 多进程模式</h2><p>多进程和多线程有比较多相似的地方，而造成不同最大的原因是因为：线程属于进程，<strong>多个线程共享了进程的内存空间</strong>；<strong>多个进程之间的内存空间是独立的</strong>，因此多个进程间通过内存共享、交换数据的方式与多个线程间的方式就有所不同。</p><p><em>多进程相对于单进程的特点是：</em></p><ol><li>资源控制更加简单。</li><li>多进程中单个进程出现问题，不会造成整体的不可用。</li></ol><blockquote><p>当然，使用多进程会比多线程复杂，多进程也可以共享数据，但是代价比多进程大，会涉及序列化和反序列化。</p></blockquote><h2 id="1-3-网络-IO-实现"><a href="#1-3-网络-IO-实现" class="headerlink" title="1.3 网络 IO 实现"></a>1.3 网络 IO 实现</h2><p>主要介绍 <strong>BIO NIO AIO</strong> 三种方式。</p><h3 id="1-3-1-BIO-方式"><a href="#1-3-1-BIO-方式" class="headerlink" title="1.3.1 BIO 方式"></a>1.3.1 BIO 方式</h3><p>一个 Socket 套接字需要一个线程来进行处理，发生「建立连接」、「读数据」、「写数据」的时候，都可能发生阻塞。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190423154656.png" alt></p><h3 id="1-3-2-NIO-方式"><a href="#1-3-2-NIO-方式" class="headerlink" title="1.3.2 NIO 方式"></a>1.3.2 NIO 方式</h3><p>基于事件驱动的思想，采用『Reactor』模式：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190423154643.png" alt></p><p>『Reactor』会管理所有的「handler」，并把出现的事件交给相应的『Handler』去处理，它的通信过程如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190423154840.png" alt></p><p>在 NIO 的方式下不是所有单个线程去应对单个「socket」套接字，而是统一通过『Reactor』对所有客户端的「socket」进行处理，最后派发到不同的线程中，这解决了 BIO 中需要开启足够多线程的问题。</p><h3 id="1-3-3-AIO-方式"><a href="#1-3-3-AIO-方式" class="headerlink" title="1.3.3 AIO 方式"></a>1.3.3 AIO 方式</h3><p>异步 IO ，采用的是 Proactor 模式，它和 NIO 的差别在于，<strong>AIO 在进行读、写的时候，需要调用相应的 read、write 方法，并且需要传入『CompletionHandler』动作完成处理器；完成以后会调用『CompletionHandler』</strong>，而 NIO 的通知是发生在动作之前，是在可写、可读的时候『Selector』发现这些事件后调用「Handler」处理。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190423162756.png" alt></p><p>所以 NIO 和 AIO 最大的区别是：NIO 在有通知时可以进行相关的操作，例如读或者写；而 AIO 在有通知的时候操作已经完成。</p><h2 id="1-4-控制器的变化"><a href="#1-4-控制器的变化" class="headerlink" title="1.4 控制器的变化"></a>1.4 控制器的变化</h2><p><strong>分布式系统是由多个节点通过网络连接在一起并通过消息的传递进行协调的系统。</strong></p><p>单机系统中，控制器指的是 CPU 中的控制器；而分布式系统中，我们的控制器是不再是 CPU 中那些具体的电子元件，<strong>而是分布式系统中的控制方式</strong>。</p><h3 id="1-4-1-透明代理"><a href="#1-4-1-透明代理" class="headerlink" title="1.4.1 透明代理"></a>1.4.1 透明代理</h3><p>跳过<strong>硬件负载均衡</strong>，我们看看通过 LVS 的方式来进行请求的负载均衡：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190423163234.png" alt></p><p>这是<strong>透明代理</strong>，从发起请求到处理请求，都是透明的。发起方以为是中间的代理提供了服务；处理方以为是中间的代理发起了请求。这个方式有三个不足：</p><ol><li><strong>增加了网络的开销，指的是流量</strong>，如果使用 LVS 的 TUN 或者 DR 模式，那么处理请求服务器上的返回结果会直接到请求服务的机器，不会再通过中间的代理，只有请求的数据包在过程中多一次代理的转发，<strong>数据包小的时候不明显，随着数据包的增大，流量增加会比较明显</strong>。</li><li><strong>延时</strong>，这是结构上存在的理论层面的问题，实际影响很小。</li><li><strong>强依赖于代理</strong>，代理是必经之路，如果代理出现问题，那么所有请求都会收到影响，我们需要考虑对代理服务器的热备份，不过切换时还是会有影响。</li></ol><h3 id="1-4-2-名称服务"><a href="#1-4-2-名称服务" class="headerlink" title="1.4.2 名称服务"></a>1.4.2 名称服务</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190423165121.png" alt></p><p>同样是完成<strong>请求发起到请求处理的请求处理的请求派发工作</strong>，与「透明代理」不同的是，在请求发起和请求处理的两个集群中没有代理服务器这样的设备，而是采用「直连」的方式，现在多了一个「名称服务」的角色，它的作用是：</p><ol><li>收集服务提供者的地址信息。</li><li>提供这些信息给消费者。</li></ol><p>发起请求的机器，需要根据「名称服务」得到的地址进行负载均衡操作，<strong>原来在透明代理上做的工作被拆分到了「名称服务」和发起请求的机器上了</strong>。</p><p>它的优势在于：这个「名称服务」不是必经之路，如果出现问题，我们有不少办法能保证请求的正常。同时它减少了中间路径额外的带宽消耗。</p><p>劣势在于：代码的升级较为复杂。</p><h3 id="1-4-3-规则服务器"><a href="#1-4-3-规则服务器" class="headerlink" title="1.4.3 规则服务器"></a>1.4.3 规则服务器</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190423165132.png" alt></p><p>它和「名称服务」的方式很像，只是这里采用的是「规则服务器」的方式，请求发起和请求处理的机器也是直接连接的，这是靠服务器给的规则实现的，<strong>在请求发起的机器上，对规则进行处理，从而进行「请求处理服务器」选择的代码逻辑</strong>。</p><p>它和「名称服务」的不同在于，<strong>它本身不和请求处理的机器进行交互，只负责将规则提供给请求发起的机器</strong>。</p><p>它的优缺点也和「名称服务」的方式类似。</p><h3 id="1-4-4-Master-Worker"><a href="#1-4-4-Master-Worker" class="headerlink" title="1.4.4 Master + Worker"></a>1.4.4 Master + Worker</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190423165309.png" alt></p><p>存在一个 Master 点来管理任务，它将任务分发给 Worker 进行执行，这个方式更多的是任务的分配和管理。</p><h2 id="1-5-运算器的变化"><a href="#1-5-运算器的变化" class="headerlink" title="1.5 运算器的变化"></a>1.5 运算器的变化</h2><p>在单机系统中运算器是具体的电子元件，而在分布式中，<strong>运算器是多个节点组成的</strong>。单机的计算能力有上限，而分布式系统中的运算器是运用多个节点的计算能力来协同完成整体的计算任务。</p><h3 id="1-5-1-DNS-协调"><a href="#1-5-1-DNS-协调" class="headerlink" title="1.5.1 DNS 协调"></a>1.5.1 DNS 协调</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190424131017.png" alt></p><p>在用户在解析 DNS 的时候，就会被给予一个服务器的地址，这样的方式看起来我们在控制器部分的「名称服务」或者「规则服务器的方式」，<strong>没有中间代理设备</strong>，用户直接知道提供服务的服务器的地址。</p><h3 id="1-5-2-负载均衡"><a href="#1-5-2-负载均衡" class="headerlink" title="1.5.2 负载均衡"></a>1.5.2 负载均衡</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190424132946.png" alt></p><p>我们在其间加上一个<strong>负载均衡设备</strong>，可以是纯硬件或者 LVS 软件，DNS 返回的永远是负载均衡的地址，而用户的访问都会通过负载均衡到达后面的网站服务器。</p><p>构成运算器的多个节点在控制器的配合下对外提供服务，构成了分布式系统的运算器。</p><h2 id="1-6-存储器的变化"><a href="#1-6-存储器的变化" class="headerlink" title="1.6 存储器的变化"></a>1.6 存储器的变化</h2><p>在单机系统中，我们一般把存储器分为内存和外村，内存的数据在机器出现状况的情况下会出现丢失，而外存是用于长久保存数据的，当然，也不是绝对可靠。</p><h3 id="1-6-1-代理服务器"><a href="#1-6-1-代理服务器" class="headerlink" title="1.6.1 代理服务器"></a>1.6.1 代理服务器</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190424133649.png" alt></p><p>加上<strong>代理服务器</strong>，这个服务器作为控制器转发来自应用服务器的请求，而转发请求使用的策略与具体业务非常密切，可以用 key 作为划分。</p><h3 id="1-6-2-名称服务"><a href="#1-6-2-名称服务" class="headerlink" title="1.6.2 名称服务"></a>1.6.2 名称服务</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190424133904.png" alt></p><p>采用「名称服务」的方案，「名称服务」用于管理在线的 KV 存储服务器，并且把地址传到应用服务器这边，应用服务器会和 KV 存储服务器直接联系。</p><h3 id="1-6-3-规则服务器"><a href="#1-6-3-规则服务器" class="headerlink" title="1.6.3 规则服务器"></a>1.6.3 规则服务器</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190424133952.png" alt></p><p>我们省去「名称服务」，规则服务器的规则不仅写明了如何对数据做 Sharding ，还包含了具体的目标 KV 存储器的地址，我们根据既定规则让应用服务器去具体的 KV 存储器。</p><h3 id="1-6-4-Master-控制"><a href="#1-6-4-Master-控制" class="headerlink" title="1.6.4 Master 控制"></a>1.6.4 Master 控制</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190424134227.png" alt></p><p>Master 根据请求返回目标 KV 存储服务器地址，然后由应用服务器直接去访问对应的 KV 存储服务器，它和「名称服务」的区别在于，它是<strong>根据请求到 Master 返回 KV 存储服务器的地址，而不是全部地址</strong>，所以具体的 KV 存储服务器选择工作在 Master 上完成了，而不是在应用服务器上。和「规则服务器」相比，它也不需要告诉应用服务器规则，Master 已经将事情完成了。</p><h2 id="1-7-分布式难点"><a href="#1-7-分布式难点" class="headerlink" title="1.7 分布式难点"></a>1.7 分布式难点</h2><h3 id="1-7-1-缺乏全局时钟"><a href="#1-7-1-缺乏全局时钟" class="headerlink" title="1.7.1 缺乏全局时钟"></a>1.7.1 缺乏全局时钟</h3><p><strong>分布式系统中，每个节点都有自己的时钟</strong>，在通过相互发送消息进行协调时，如果仍然依赖时序，那么会很难进行处理，很多时候我们使用时钟，<strong>它是用来区分两个动作的顺序，而不是一个准确的时间</strong>，我们可以把这个工作给一个单独的集群，用这个集群来区分多个动作的顺序。</p><h3 id="1-7-2-面对故障的独立性"><a href="#1-7-2-面对故障的独立性" class="headerlink" title="1.7.2 面对故障的独立性"></a>1.7.2 面对故障的独立性</h3><p>整个分布式系统也是有可能出现宕机的，但实践中，更多是某个或某些节点有问题，我们要保证其他节点的<strong>独立性</strong>，必须找到应对和解决故障独立性的方法。</p><h3 id="1-7-3-处理单点故障"><a href="#1-7-3-处理单点故障" class="headerlink" title="1.7.3 处理单点故障"></a>1.7.3 处理单点故障</h3><p>在分布式系统中，如果某个角色或者功能只有某个单机在支持，那么这个节点就是一个单点，它发生的故障就是单点故障，我们在分布式系统中应该尽量避免，<strong>关键在于把这个功能从单机变成集群实现</strong>，如果不能，一般有另外两个选择：</p><ol><li>给单点做好备份，能够在出现问题时进行恢复，并且尽量做到自动恢复，降低恢复需要的时间。</li><li>降低单点故障的范围，比如 KV 存储的时候增加 KV 服务器的数量，拆分数据，减少故障影响。</li></ol><h3 id="1-7-4-事务的挑战"><a href="#1-7-4-事务的挑战" class="headerlink" title="1.7.4 事务的挑战"></a>1.7.4 事务的挑战</h3><p>数据库中我们有 ACID ，在单机中实现事务是比较简单的，在分布式中如何实现事务也是重要的一部分。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 大型网站系统与 Java 中间件开发实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8与并发</title>
      <link href="/technology/2019-03-01-java8-parallel/"/>
      <url>/technology/2019-03-01-java8-parallel/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java-8的函数式编程"><a href="#1-Java-8的函数式编程" class="headerlink" title="1. Java 8的函数式编程"></a>1. Java 8的函数式编程</h2><p>JS 既不是严格意义上的函数式编程，也不是严格意义上的面向对象，如果我们愿意，它可以被作为面向对象，也可以被作为函数式语言，这样的语言就是<strong>多范式语言</strong>。</p><h3 id="1-1-函数作为一等公民"><a href="#1-1-函数作为一等公民" class="headerlink" title="1.1 函数作为一等公民"></a>1.1 函数作为一等公民</h3><p>看一段 JS 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">"li"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert($(<span class="keyword">this</span>).text());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码里，我们使用了 <code>each()</code> 这个函数，<strong>把一个函数作为一个函数的参数</strong>，是函数式编程的特性之一。</p><p>再一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这段代码里，它返回了函数 <code>f2</code> ，在之后的使用中，我们发现这个「result」就是一个函数，<strong>函数可以作为另外一个函数的返回值</strong>，也是函数式编程的重要特点。</p><h3 id="1-2-无副作用"><a href="#1-2-无副作用" class="headerlink" title="1.2 无副作用"></a>1.2 无副作用</h3><p>所谓「副作用」是指在函数的调用过程中，<strong>除了给出了返回值外，还修改了函数外部的状态</strong>。</p><p>函数的副作用应该被尽可能去除，但是完全无副作用是做不到的，但是与面向对象相比，函数调用的副作用，在函数式编程中，应该被有效限制。</p><blockquote><p>显式函数指函数与外界交换数据的唯一渠道就是参数与返回值。</p><ul><li><p>显式函数不会去读取或者修改函数的外部状态。</p></li><li><p>隐式函数除了参数和返回值，还会读取外部信息，或者修改外部信息。</p></li></ul></blockquote><h3 id="1-3-申明的-Declarative"><a href="#1-3-申明的-Declarative" class="headerlink" title="1.3 申明的 Declarative"></a>1.3 申明的 Declarative</h3><p>相比命令式 Imperative 而言，命令式喜欢大量使用可变对象和指令，而现在，我们不再需要明确的指令操作，我们要做的，仅仅是提出要求，申明我们的用意即可。</p><p>对比一个例子。下面是传统的命令式语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">imperative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] iArr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span> ,<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iArr.length; ++i) &#123;</span><br><span class="line">    System.out.println(iArr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之对应的，我们的申明式的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">declarative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] iArr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span> ,<span class="number">2</span>&#125;;</span><br><span class="line">  Arrays.stream(iArr).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的循环体不见了！而 <code>println</code> 中没有任何参数，我们仅仅说明我们的用意，这些循环以及判断被简单封装到我们的程序库中。</p><h3 id="1-4-不变的对象"><a href="#1-4-不变的对象" class="headerlink" title="1.4 不变的对象"></a>1.4 不变的对象</h3><p>在函数式编程中，几乎所有传递的对象都不会被轻易修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span> ,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.stream(arr).map((x) -&gt; x = x + <span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line">Arrays.stream(arr).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这段代码在将「arr」每一个值加一并打印以后，我们查看原本的数组，发现数组并没有变化，在函数式编程中，这种状态是一种常态，几乎所有对象都拒绝被修改，这非常类似不变模式。</p><h3 id="1-5-易于并行"><a href="#1-5-易于并行" class="headerlink" title="1.5 易于并行"></a>1.5 易于并行</h3><p>由于对象都是不变状态，因此更容易进行并行，而不用考虑安全问题。这也得益于<strong>不变模式</strong>。</p><h3 id="1-6-更少的代码"><a href="#1-6-更少的代码" class="headerlink" title="1.6 更少的代码"></a>1.6 更少的代码</h3><p>通常，函数式编程更加简明扼要，引入函数式以后，我们可以使用更少的代码来完成 Java 的开发。</p><p>下面的代码判断数组中每一个成员是奇数或者偶数，并将奇数加一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span> ,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    arr[i]++;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数式方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(arr).map(x -&gt; (x % <span class="number">2</span> == <span class="number">0</span> ? x : x + <span class="number">1</span>)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="2-函数式编程基础"><a href="#2-函数式编程基础" class="headerlink" title="2. 函数式编程基础"></a>2. 函数式编程基础</h2><h3 id="2-1-FunctionalInterface-注释"><a href="#2-1-FunctionalInterface-注释" class="headerlink" title="2.1 FunctionalInterface 注释"></a>2.1 FunctionalInterface 注释</h3><p>Java 8提出了函数式接口的概念，所谓函数式接口，就是只定义一个单一抽象方法的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它表明这个接口是函数式接口，而这个注释实际上是可有可无的，因为编辑器会给满足条件的接口加上这个注释。</p><p>值得注意的是<strong>函数式接口只能有一个抽象方法，而不是只能有一个方法</strong>。这分两点说明：</p><ul><li>在 Java 8中，接口运行存在实例方法。</li><li>其次任何被『java.lang.Object』实现的方法，都不能视为抽象方法。</li></ul><p>下面的『NonFunc』接口不是函数式接口，因为 <code>equals()</code> 方法『java.lang.Object』中已经实现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NonFunc</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，下面实现的『IntHandler』接口符合函数式接口的要求，虽然看起来不像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式接口的实例可以由方法引用或者 lambda 表达式来构造。</p><h3 id="2-2-接口默认方法"><a href="#2-2-接口默认方法" class="headerlink" title="2.2 接口默认方法"></a>2.2 接口默认方法</h3><p>在 Java 8之前的版本中，接口只能包含抽象方法，但在 Java 8之后，接口也可以包含若干实例方法，一个对象实例，将拥有来自多个不同接口的实例方法。</p><p>比如，对于接口『IHourse』，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHourse</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hourse run"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8中，可以使用「default」关键字，可以在接口内定义实例方法。<strong>这个方法并非抽象方法，而是拥有特定逻辑的具体实例方法</strong>。所有动物都能自由呼吸，所以，这里可以再定义一个『IAnimal』接口，它也包含一个默认的方法 <code>breath()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"breath"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>骡是马和驴的杂交物种，因此『Mule』可以实现为『IHorse』，同时它也是动物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mule</span> <span class="keyword">implements</span> <span class="title">IHorse</span>, <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mule eat"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Mule m = <span class="keyword">new</span> Mule();</span><br><span class="line">    m.run();</span><br><span class="line">    m.breath();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中『Mule』同时拥有来自不同接口的实现方法，这在 Java 8之前是不能办到的，从某种程度上说，这种模式弥补了 Java 单一继承的一些不便，但同时它将面临和多继承相同的问题，如果『IDonkey』也存在一个默认的 <code>run()</code> 方法，那么同时实现它们的『Mule』，就会不知所措：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190228193401.png" alt></p><p>现在实现一个『IDonkey』的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDonkey</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Donkey run"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改『Mule』的实现，注意它同时实现了『IHorse』和『IDonkey』：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mule</span> <span class="keyword">implements</span> <span class="title">IHorse</span>, <span class="title">IDonkey</span>, <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mule eat"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Mule m = <span class="keyword">new</span> Mule();</span><br><span class="line">    m.run();</span><br><span class="line">    m.breath();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，因为两个接口『IHorse』和『IDonkey』都有方法 <code>run()</code> 因此编译器将报错。</p><p>因此，我们不得不重新实现以下 <code>run()</code> 方法，让编译器可以进行方法绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mule</span> <span class="keyword">implements</span> <span class="title">IHorse</span>, <span class="title">IDonkey</span>, <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IHorse.<span class="keyword">super</span>.run();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口默认实现对于整个函数式编程的流式表达非常重要，比如我们熟悉的『java.util.Comparator』接口，它在 Jdk1.2 时被引入，用于在排序时给出两个对象实例的具体比较逻辑，在 Java 8中，『Comparator』接口新增了若干默认方法，用于多个比较器的整合，其中一个常用的默认方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparing</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(other);</span><br><span class="line">  <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> res = compare(c1, c2);</span><br><span class="line">    <span class="keyword">return</span> (res != <span class="number">0</span>) ? res : other.compare(c1, c2);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个默认方法，在进行排序的时候，我们可以非常方便地进行元素的多条件排序，比如如下代码构造一个比较器，它先按照字符串长度排序，继而按照大小写不敏感的字母顺序排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; cmp = Comparator.comparingInt(String::length).thenComparing(String.CASE_INSENSITIVE_ORDER);</span><br></pre></td></tr></table></figure><h3 id="2-3-lambda-表达式"><a href="#2-3-lambda-表达式" class="headerlink" title="2.3 lambda 表达式"></a>2.3 lambda 表达式</h3><p>lambda 表达式即匿名表达式，它是一段没有函数名的函数体，下面在 <code>forEach()</code> 中，传入一个 lambda 表达式，它完成了对元素的标准输出操作，可以看出这段表达式并不像函数一样有名字，非常类似匿名内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">numbers.forEach((Integer value) -&gt; System.out.println(value));</span><br></pre></td></tr></table></figure><p>和匿名对象一样，lambda 表达式也可以访问外部的局部变量，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; stringConverter = (from) -&gt; from * num;</span><br><span class="line">System.out.println(stringConverter.apply(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>但是有一个限制，访问的外部变量需要是「final」的，但是如果我们将上面的关键字「final」去掉，编译还是可以通过，这是因为 lambda 表达式将使用的变量认为是「final」的，如果这样写，就不行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; stringConverter = (from) -&gt; from * num;</span><br><span class="line">num++;</span><br><span class="line">System.out.println(stringConvert.apply(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>上述代码将会因为 <code>num++</code> 而报错。</p><h3 id="2-4-方法引用"><a href="#2-4-方法引用" class="headerlink" title="2.4 方法引用"></a>2.4 方法引用</h3><p>方法引用是 Java 8提出的用来简化 lambda 表达式的一种手段，方法引用再 Java 8中使用非常灵活，可以分为以下几种：</p><ul><li>静态方法引用：<code>ClassName::methodName</code></li><li>实例上的实例方法引用：<code>instanceReference::methodName</code></li><li>超类上的实例方法引用：<code>super::methodName</code></li><li>类型上的实例方法引用：<code>ClassName::methodName</code></li><li>构造方法引用：<code>Class::new</code></li><li>数组构造方法引用：<code>TypeName[]::new</code></li></ul><p>首先，方法引用使用 <code>::</code> 定义，前半部分是类名或者实例名，后半部分是方法名，如果是构造函数则使用 <code>new</code> 表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceMethodRef</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      users.add(<span class="keyword">new</span> User(i, <span class="string">"ronnie"</span> + Integer.toString(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    users.stream().map(User::getName).forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用每一个『User』对象实例的 <code>getName()</code> 方法，并将这些『User』的「name」作为一个新的流。</p><p>有时候编辑器也会困扰，在同时拥有实例方法和静态方法的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadMethodRef</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Double&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      numbers.add(Double.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    numbers.stream().map(Double::toString).forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码会有编辑器警告，这是因为在『Double』中有两个 <code>toString()</code> ，存在歧义。</p></blockquote><p>方法引用也可以直接使用构造函数比如已经存在一个模型类『User』：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么可以这么使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> UserFactory&lt;User&gt; uf = User::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><p>以后我们使用 <code>uf.create()</code> 的方式来创建『User』了。</p><h2 id="3-一步步走入函数式编程"><a href="#3-一步步走入函数式编程" class="headerlink" title="3. 一步步走入函数式编程"></a>3. 一步步走入函数式编程</h2><blockquote><p>流对象，类似集合或者数组，它赋予我们遍历处理流内元素的功能。</p></blockquote><p>早期我们这样写遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jdk 5引入了 for-each 循环，现在 Jdk 8引入了「流」：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Arrays.stream(arr).forEach(<span class="keyword">new</span> IntConsumer() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">      System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>forEach</code> 将循环过程包装，挨个送入『IntConsumer』，除了『IntStream』，还有『DoubleStream』、『LongStream』和普通对象流 Stream ，而这些不同的流就决定了不同的「Consumer」，任性的程序员说：<strong>既然 <code>forEach</code> 的参数可以从上下文得到，我们就不写「Consumer」了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Arrays.stream(arr).forEach((<span class="keyword">final</span> <span class="keyword">int</span> x) -&gt; &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，既然是『IntConsumer』接口，参数自然是『int』啊，代码进一步缩减：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Arrays.stream(arr).forEach((x) -&gt; &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是为了一句执行多个花括号也没必要呀：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Arrays.stream(arr).forEach((x) -&gt; System.out.println(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译发现，内部实现了一个私有的静态方法，等同于实现一个匿名类。</p></blockquote><p>我们知道 Java 8支持方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们连参数申明和传递都省略了…你已经是一个成熟的编译器了，该学会自己写代码了。</p><p>lambda 表达式还可以使用更流畅的流式 API 对各种组件进行更自由的搭配。下面的例子，一次输出标准错误，一次输出标准输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  IntConsumer outprintln = System.out::println;</span><br><span class="line">  IntConsumer errprintln = System.err::println;</span><br><span class="line">  Arrays.stream(arr).forEach(outprintln.andThen(errprintln));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>andThen</code> 方法会一个一个『Consumer』进行执行，从而实现多个处理器的整合，这是一个惯用套路。</p><h2 id="4-并行流与并行排序"><a href="#4-并行流与并行排序" class="headerlink" title="4. 并行流与并行排序"></a>4. 并行流与并行排序</h2><h3 id="4-1-并行流过滤数据"><a href="#4-1-并行流过滤数据" class="headerlink" title="4.1 并行流过滤数据"></a>4.1 并行流过滤数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非常普通的判断素数，可以用快速线性筛</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = number;</span><br><span class="line">  <span class="keyword">if</span> (tmp &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(tmp); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用 lambda 表达式来写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">1000000</span>).filter(PrimeUtil::isPrime).count();</span><br></pre></td></tr></table></figure><p>上面是串行计算，我们用并行来做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">1000000</span>).parallel().filter(PrimeUtil::isPrime).count();</span><br></pre></td></tr></table></figure><blockquote><p>个人认为 stream 相关的函数也可以认为是 lambda 表达式，因为 stream 内部就是用了 lambda 表达式实现的。</p></blockquote><h3 id="4-2-从集合得到并行流"><a href="#4-2-从集合得到并行流" class="headerlink" title="4.2 从集合得到并行流"></a>4.2 从集合得到并行流</h3><p>下面这段代码试图统计集合中所有学生的平均分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; ss = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"><span class="keyword">double</span> ave = ss.stream().mapToInt(s -&gt; s.score).average().getAsDouble();</span><br></pre></td></tr></table></figure><p>我们希望使用并行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> ave = ss.parallelStream().mapToInt(s -&gt; s.score).average().getAsDouble();</span><br></pre></td></tr></table></figure><p>将原来的代码改造成并行化是非常方便的。</p><h3 id="4-3-并行排序"><a href="#4-3-并行排序" class="headerlink" title="4.3 并行排序"></a>4.3 并行排序</h3><p>我们熟悉的排序有 <code>Arrays.sort()</code> 排序，这是串行的，我们还有 <code>Arrays.parallelSort()</code> 来进行并行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000000</span>];</span><br><span class="line">Arrays.parallelSort(arr);</span><br></pre></td></tr></table></figure><p>除了并行排序，还有一些 API 可以作用于数组中数据的赋值，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAll</span><span class="params">(<span class="keyword">int</span>[] array, IntUnaryOperator generator)</span></span>;</span><br></pre></td></tr></table></figure><p>这是一个函数式味道很浓的接口，第二个参数是一个函数式接口，如果我们希望给数组的每一个元素附上一个随机数，那么可以这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">Arrays.parallelSetAll(arr, (i) -&gt; r.nextInt());</span><br></pre></td></tr></table></figure><h2 id="5-增强的-Future：CompletableFuture"><a href="#5-增强的-Future：CompletableFuture" class="headerlink" title="5. 增强的 Future：CompletableFuture"></a>5. 增强的 Future：CompletableFuture</h2><p>『CompletableFuture』是 Java 8的一个<strong>超大型工具类</strong>，一方面是它实现了『Future』接口，另外它实现了『CompletionStage』接口。这个接口有约40种方法！它是为了流式调用准备的，通过这个接口，我们可以在一个执行结果上进行多次流式调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.print(x)).thenRun(() - &gt; System.out.println());</span><br></pre></td></tr></table></figure><p>这一连串将挨个执行。</p><h3 id="5-1-完了通知我"><a href="#5-1-完了通知我" class="headerlink" title="5.1 完了通知我"></a>5.1 完了通知我</h3><p>『CompletableFuture』和『Future』一样，可以作为函数调用的契约，如果我们向它请求一个数据，如果没有准备好，那么线程会等待，不同的是，我们可以手动设置『CompletableFuture』的完成状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AskThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  CompletableFuture&lt;Integer&gt; re = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AskThread</span><span class="params">(CompletableFuture&lt;Integer&gt; re)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.re = re;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myRe = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      myRe = re.get() * re.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(myRe);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> AskThread(future)).start();</span><br><span class="line">    <span class="comment">// 模拟长时间的计算</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 完成</span></span><br><span class="line">    future.complete(<span class="number">60</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个『AskThread』线程的作用是计算『CompletableFuture』表示的数字的平方。</p><h3 id="5-2-执行异步请求"><a href="#5-2-执行异步请求" class="headerlink" title="5.2 执行异步请求"></a>5.2 执行异步请求</h3><p>通过『CompletableFuture』提供的进一步封装，我们可以实现「Future」那样的异步调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureAsyDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">calc</span><span class="params">(Integer para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟一个长时间的执行</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> para * para;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future = CompletableFuture</span><br><span class="line">      .supplyAsync(() -&gt; calc(<span class="number">50</span>));</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>supplyAsync</code> 会立即返回，它返回的『CompletableFuture』实例就是本次调用的契约，在将来的任何场合，用于获取最终的结果，若直接试图 <code>get</code> 那么线程将等待。</p><p>与之相对的，还有一个 <code>runAsync</code> 方法，这个方法没有返回值，仅仅简单执行一个异步动作。</p><p>但是这些都需要指定一个『Executor』参数，如果不指定，就是在默认的公共的『ForkJoinPool.common』线程池中执行。</p><blockquote><p>JDK1.8 中，新增了 <code>ForkJoinPool.commonPool()</code> 方法，它获取一个公共的『ForkJoin』线程池，但是都是「Daemon」的线程。</p></blockquote><h3 id="5-3-流式调用"><a href="#5-3-流式调用" class="headerlink" title="5.3 流式调用"></a>5.3 流式调用</h3><p>我们看看前面说的『CompletionStage』的约40个接口是如何使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; fu = CompletableFuture</span><br><span class="line">    .supplyAsync(() -&gt; calc(<span class="number">50</span>))</span><br><span class="line">    .thenApply((i) -&gt; Integer.toString(i))</span><br><span class="line">    .thenApply((str) -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>)</span><br><span class="line">    .thenAccept(System.out::println);</span><br><span class="line">fu.get();</span><br></pre></td></tr></table></figure><blockquote><p>为什么我们总要执行 <code>get()</code> 方法，因为异步调用的缘故，不等 <code>cal</code> 执行完，这个方法在「Daemon」线程中执行，就直接退出了。</p></blockquote><h3 id="5-4-CompletableFuture-中的异常处理"><a href="#5-4-CompletableFuture-中的异常处理" class="headerlink" title="5.4 CompletableFuture 中的异常处理"></a>5.4 CompletableFuture 中的异常处理</h3><p>『CompletableFuture』提供一个异常处理的方法 <code>exceptionally()</code> ，看一下 demo ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">calcExcption</span><span class="params">(Integer para)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> para / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">  CompletableFuture&lt;Void&gt; fuEx = CompletableFuture</span><br><span class="line">      .supplyAsync(() -&gt; calcExcption(<span class="number">50</span>))</span><br><span class="line">      .exceptionally(ex -&gt; &#123;</span><br><span class="line">        System.out.println(ex.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      .thenApply((i) -&gt; Integer.toString(i))</span><br><span class="line">      .thenApply((str) -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>)</span><br><span class="line">      .thenAccept(System.out::println);</span><br><span class="line">  fuEx.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-组合多个-CompletableFuture"><a href="#5-5-组合多个-CompletableFuture" class="headerlink" title="5.5 组合多个 CompletableFuture"></a>5.5 组合多个 CompletableFuture</h3><p>我们可以将多个『CompletableFuture』组合起来，一个方法是使用 <code>thenCompose</code> 方法，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uniComposeStage(<span class="keyword">null</span>, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个『CompletableFuture』 完成后，会通过「Function」传递给下一个『CompletionStage』处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; fuEx = CompletableFuture</span><br><span class="line">    .supplyAsync(() -&gt; calcExcption(<span class="number">50</span>))</span><br><span class="line">    .thenCompose((i) -&gt; CompletableFuture.supplyAsync(() -&gt; calcExcption(i)))</span><br><span class="line">    .thenApply((str) -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><p>另外一个组合方式是使用 <code>thenCombine()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">  BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> biApplyStage(<span class="keyword">null</span>, other, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先完成当前『CompletableFuture』和「other」的执行，接着，将两者的执行结果传递给『BitFunction』，并返回代表『BitFunction』实例的『CompletableFuture』对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; intFuture = CompletableFuture.supplyAsync(() -&gt; calcExcption(<span class="number">50</span>));</span><br><span class="line">CompletableFuture&lt;Integer&gt; intFuture2 = CompletableFuture.supplyAsync(() -&gt; calcExcption(<span class="number">25</span>));</span><br><span class="line">CompletableFuture&lt;Void&gt; fuEx3 = intFuture</span><br><span class="line">    .thenCombine(intFuture2, (i, j) -&gt; (i + j))</span><br><span class="line">    .thenApply((str) -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="6-读写锁改进：StampedLock"><a href="#6-读写锁改进：StampedLock" class="headerlink" title="6. 读写锁改进：StampedLock"></a>6. 读写锁改进：StampedLock</h2><p>『StampedLock』是 Java 8新的锁机制，简单理解，它是读写锁的一个改进，它提供一个乐观的读策略，类似无锁，使得乐观锁完全不会阻塞写进程。</p><blockquote><p>读写锁分离读和写，但是读和写之间还是有冲突。</p></blockquote><h3 id="6-1-StampedLock-使用例子"><a href="#6-1-StampedLock-使用例子" class="headerlink" title="6.1 StampedLock 使用例子"></a>6.1 StampedLock 使用例子</h3><p>下面是一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StampedLock s1 = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// 一个排他锁</span></span><br><span class="line">    <span class="keyword">long</span> stamp = s1.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      x += deltaX;</span><br><span class="line">      y += deltaY;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      s1.unlockWrite(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// 只读</span></span><br><span class="line">    <span class="keyword">long</span> stamp = s1.tryOptimisticRead(); <span class="comment">// 凭证</span></span><br><span class="line">    <span class="keyword">double</span> currentX = x, currentY = y;</span><br><span class="line">    <span class="keyword">if</span> (!s1.validate(stamp)) &#123; <span class="comment">// 校验凭证，CAS</span></span><br><span class="line">      stamp = s1.readLock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        currentX = x;</span><br><span class="line">        currentY = y;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        s1.unlockRead(stamp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>涨知识了，CAS 可不仅仅是 <code>for(;;)</code> 这么简单。</p></blockquote><h3 id="6-2-StampedLock-的小陷阱"><a href="#6-2-StampedLock-的小陷阱" class="headerlink" title="6.2 StampedLock 的小陷阱"></a>6.2 StampedLock 的小陷阱</h3><p>『StampedLock』内部使用 CAS 操作来循环反复尝试，在挂起线程的时候使用了 <code>Unsafe.park()</code> 这个方法挂起线程，中断就直接返回，不会抛出异常。这就导致了『StampedLock』没有处理中断的逻辑，会疯狂占用 CPU 。</p><h3 id="6-3-StampedLock-实现思想"><a href="#6-3-StampedLock-实现思想" class="headerlink" title="6.3 StampedLock 实现思想"></a>6.3 StampedLock 实现思想</h3><p>基于 CLH 锁，是一种自旋锁，它保证没有饥饿发生，保证 FIFO ，思想：<strong>维护一个等待线程队列，所有申请锁，但没有成功的线程都记录在这个队列中。每一个节点就是一个线程，保存一个标记位，用于判断当前线程是否已经释放锁</strong>。</p><p>当一个线程试图获得锁，取得当前等待队列的尾部节点作为其前序节点时，使用类似如下代码判断前序节点是否已经释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pred.locked) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>只要前序节点没有释放，则当前节点不能执行，会自旋等待。</li><li>反之，前序释放，当前节点可以继续执行。</li><li>释放锁，也遵循这个逻辑，线程会叫标记设置为「false」，后续等待的线程就能继续执行了。</li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190301000503.png" alt></p><h2 id="7-原子类的增强"><a href="#7-原子类的增强" class="headerlink" title="7. 原子类的增强"></a>7. 原子类的增强</h2><p>无锁的原子类操作使用系统的 CAS 指令，有着远超锁的性能，在 Java 8中引入了『LongAdder』类，这个类在『java.util.concurrent.atomic』包下，它也使用 CAS 指令。</p><h3 id="7-1-更快的原子类：LongAdder"><a href="#7-1-更快的原子类：LongAdder" class="headerlink" title="7.1 更快的原子类：LongAdder"></a>7.1 更快的原子类：LongAdder</h3><p>我们知道『AtomicInteger』是在一个死循环里面不断尝试修改，在大量修改失败后，这些原子操作的性能也是存疑的，一个基本思路是<strong>热点分离</strong>，将竞争的数据进行分解，虽然在 CAS 中没有锁，但是减小锁粒度这种分离热点的思想仍然可用。</p><p>我们可以仿造『ConcurrentHashMap』，将热点数据分离，我们在『AtomicInteger』内部核心数据「value」分离成一个数组，每个线程访问的时候，通过哈希映射其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190301001405.png" alt></p><p>其中，热点数据「value」被分离成多个单元「cell」，每个「cell」单独维护内部的值，当前对象的实际值由所有的「cell」累计合成，这样，热点就进行了有效的分离，提高了并行度。</p><p>在实际操作中，『LongAdder』不会一开始就动用数组来进行处理，将所有数据标记在一个「base」数组里，大家修改都没有冲突也就没有必要扩展「cell」数组，但是一旦「base」有冲突，就初始化「cell」数组，如果「cell」上还有冲突，创建新的「cell」。</p><hr><p>『LongAdder』的另外一个优化就是避免了伪共享，它的实现不是「padding」，而是一个新的注释 <code>@sun.misc.Contended</code> 。</p><blockquote><p><code>class {int x ,int y}</code> 「x」和「y」被放在同一个高速缓存区，如果一个线程修改「x」；那么另外一个线程修改「y」，必须等待「x」修改完成后才能实施。</p></blockquote><h3 id="7-2-LongAdder-的功能增强版：LongAccumulator"><a href="#7-2-LongAdder-的功能增强版：LongAccumulator" class="headerlink" title="7.2 LongAdder 的功能增强版：LongAccumulator"></a>7.2 LongAdder 的功能增强版：LongAccumulator</h3><p>它们有公共父类『Striped64』，因此内部优化是一样，都将一个『long』型整数进行分割，它是『LongAdder』的功能扩展，它不是一次执行一次加法，而是实现任意函数操作。</p><p>它的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LongAccumulator</span><span class="params">(LongBinaryOperator accumulatorFunction, <span class="keyword">long</span> identity)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是需要执行的二元函数，第二个参数是初始值。</p><p>下面是 demo ，它通过多线程访问多个整数，返回最大的那个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAccumulatorDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator(Long::max, Long.MIN_VALUE);</span><br><span class="line">    Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">      ts[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">long</span> value = random.nextLong();</span><br><span class="line">        accumulator.accumulate(value);</span><br><span class="line">      &#125;);</span><br><span class="line">      ts[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">      ts[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(accumulator.longValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 高并发程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行模式与算法</title>
      <link href="/technology/2019-02-23-parallel-pattern/"/>
      <url>/technology/2019-02-23-parallel-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><p>不再赘述</p><h2 id="2-不变模式"><a href="#2-不变模式" class="headerlink" title="2. 不变模式"></a>2. 不变模式</h2><p>重点在于给类加上「final」关键字，使其无法拥有子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要的不变模式类型</span></span><br><span class="line">java.lang.String</span><br><span class="line">java.lang.Boolean</span><br><span class="line">java.lang.Byte</span><br><span class="line">java.lang.Character</span><br><span class="line">java.lang.Double</span><br><span class="line">java.lang.Float</span><br><span class="line">java.lang.Integer</span><br><span class="line">java.lang.Long</span><br><span class="line">java.lang.Short</span><br></pre></td></tr></table></figure><blockquote><p>不变模式通过回避问题而不是解决问题的方式来处理多线程并发访问控制。</p></blockquote><h2 id="3-生产者-消费者模式"><a href="#3-生产者-消费者模式" class="headerlink" title="3. 生产者-消费者模式"></a>3. 生产者-消费者模式</h2><ul><li>生产者线程负责提交用户请求</li><li>消费者线程负责处理生产者提交的任务</li><li>生产者和消费者共享内存缓存区进行通信。</li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190222153638.png" alt></p><blockquote><p>上图中，三个「生产者」将任务提交到「共享内存缓存区」，「消费者」不直接和生产者线程通信，而是在共享内存缓存区中获取任务，并进行处理。</p></blockquote><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190222153844.png" alt></p><p>这里使用了『BlockingQueue』充当内存缓存区，维护任务和数据队列，『PCData』充当一个生产任务，「生产者」和「消费者」将引用同一个『BlockingQueue』实例。</p><blockquote><p>生产者消费者模式对「生产者」和「消费者」线程进行了解耦，优化了系统整体结构，又由于缓存区的作用，允许「生产者」和「消费者」在执行上的性能差异，从一定程度上环节了性能瓶颈对系统性能的影响。</p></blockquote><h2 id="4-无锁生产者-消费者模式"><a href="#4-无锁生产者-消费者模式" class="headerlink" title="4. 无锁生产者-消费者模式"></a>4. 无锁生产者-消费者模式</h2><p>『BlockingQueue』是一个不错的选择，但是并不是一个高性能的实现，<strong>它完全使用锁和阻塞来实现线程间同步</strong>，高并发场合『ConcurrentLinkedQueue』是一个高性能队列，使用『BlockingQueue』仅仅是为了方便数据共享。</p><p>而『ConcurrentLinkedQueue』成功的秘诀在于大量使用了无锁的 CAS 操作，使用 CAS 来进行编程非常困难，目前有一个现成的 Disruptor 框架，它已经实现了这个功能。</p><h3 id="4-1-无锁缓存框架：Disruptor"><a href="#4-1-无锁缓存框架：Disruptor" class="headerlink" title="4.1 无锁缓存框架：Disruptor"></a>4.1 无锁缓存框架：Disruptor</h3><p>它使用<strong>环形队列</strong>实行一个数组，只需要一个当前位置的指针即可，这个指针用于出队和入队，由于环形队列，总大小需要预先指定，<strong>不能动态扩展</strong>，为了快速从一个序列 sequence 对应到数组的实际位置，需要数组大小是2的整数次方，这样通过 <code>sequence &amp; (queueSize - 1)</code> 就能立即定位实际的元素位置 index ，这要比取模快得多。</p><blockquote><p>queueSize 是2的整数次方，这样通过这行代码就能将 sequence 限定在 queueSize - 1 的范围内，不会有任何一位浪费。</p></blockquote><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190222161317.png" alt></p><p>现在，「生产者」写入数据的时候使用 CAS 操作，「消费者」读取数据的时候，为了防止多个「消费者」同时处理一个数据，也使用 CAS 进行数据保护。</p><p>另外一个好处就是完全做到内存复用，不会有新的空间需要分配或者老的空间需要回收，大大减少系统分配空间以及回收空间的额外开销。</p><h2 id="5-Future-模式"><a href="#5-Future-模式" class="headerlink" title="5. Future 模式"></a>5. Future 模式</h2><blockquote><p>Future 模式是多线程中非常常见的设计模式，核心思想是异步调用。</p></blockquote><p>我们对比一下传统的程序调用流程：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223143856.png" alt></p><blockquote><p>然后再看看广义 Future 模式的实现，虽然 call 本身的执行时间很长，但是服务程序不等数据处理完成便立即返回客户端一个伪造的数据。</p></blockquote><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223144054.png" alt></p><h3 id="5-1-Future-模式的主要角色"><a href="#5-1-Future-模式的主要角色" class="headerlink" title="5.1 Future 模式的主要角色"></a>5.1 Future 模式的主要角色</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223144158.png" alt></p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223144216.png" alt></p><h3 id="5-2-Future-模式简单实现"><a href="#5-2-Future-模式简单实现" class="headerlink" title="5.2 Future 模式简单实现"></a>5.2 Future 模式简单实现</h3><p>「RealData」是最终使用的数据模型，它的构造很慢，「FutureData」是 Future 模式的关键，它是真实数据的代理，封装了「RealData」的等待过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> RealData realdata = <span class="keyword">null</span>; <span class="comment">// FutureData是 RealData的包装</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realdata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isReady) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.realdata = realdata;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll(); <span class="comment">// RealData已经被注入,通知 getResult()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span></span>&#123; <span class="comment">//会等待 RealData构造完成</span></span><br><span class="line">    <span class="keyword">while</span> (!isReady) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        wait(); <span class="comment">//一直等待,知道 RealData被注入</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> realdata.result; <span class="comment">//由 RealData实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-JDK-中的-Future-模式"><a href="#5-3-JDK-中的-Future-模式" class="headerlink" title="5.3 JDK 中的 Future 模式"></a>5.3 JDK 中的 Future 模式</h3><p>JDK 已经在内部准备好了一套完整的实现：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223144906.png" alt></p><p>其中『Future』接口就类似于前文描述的订单或者说是契约。通过它,你可以得到真实的数据。『RunnableFuture』继承了『Future』和『Runnable』两个接口，其中 <code>run</code> 方法用于构造真实的数据。</p><p>它有一个具体的实现『FutureTask』类。『FutureTask』有一个内部类『Sync』，一些实质性的工作，会委托『Sync』类实现。而『Sync』类最终会调用『Callable』接口，完成实际数据的组装工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        sb.append(data);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 构造 FutureTask</span></span><br><span class="line">    FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> RealData(<span class="string">"a"</span>));</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 执行 FutureTask</span></span><br><span class="line">    <span class="comment">// 这里开启线程进行 call 方法调用</span></span><br><span class="line">    executor.submit(future);</span><br><span class="line">    System.out.println(<span class="string">"请求完毕"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 用 sleep 代替业务逻辑</span></span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// call 没有结束就继续等待</span></span><br><span class="line">    System.out.println(<span class="string">"数据:"</span> + future.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-并行流水线"><a href="#6-并行流水线" class="headerlink" title="6. 并行流水线"></a>6. 并行流水线</h2><p>假设我们现在要计算 $(B+C)*B/2$ ，但是因为 $B+C$ 没有完成，数据之间存在依赖性，无法进行并行化，此时，我们可以参考「流水线思想」。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223145418.png" alt></p><p>即使上面的式子我们无法并行，但是如果有一大堆的 B 和 C ，我们可以使用流水线，将该计算流程分为三步：</p><ol><li>A = B + C</li><li>D = A X B</li><li>D = D / 2</li></ol><p>上述三步可以使用三个线程单独计算。</p><h2 id="7-并行搜索"><a href="#7-并行搜索" class="headerlink" title="7. 并行搜索"></a>7. 并行搜索</h2><p>搜索是一个软件并不可少的功能，对于有序的数据，通常采用二分搜索，对于无序数据，只能挨个查找。</p><blockquote><p>一种简单的策略，是将数据分割，如果使用两个线程并行，则分成两个数组，每个数组独立搜索。</p></blockquote><h2 id="8-并行排序"><a href="#8-并行排序" class="headerlink" title="8. 并行排序"></a>8. 并行排序</h2><p>这里有几种相对简单，但也足以让人脑洞大开的排序算法。</p><h3 id="8-1-奇偶交换排序"><a href="#8-1-奇偶交换排序" class="headerlink" title="8.1 奇偶交换排序"></a>8.1 奇偶交换排序</h3><p>对于一般的冒泡，我们使用下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223150109.png" alt></p><p>问题在于，这样排序很难并行化，因此可以进行分离，对于奇交换而言，总是比较奇搜索以及其相邻的后续元素；而偶交换总是比较偶索引和其相邻的后续元素，如下所示：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223150241.png" alt></p><h3 id="8-2-改进插入排序：希尔排序"><a href="#8-2-改进插入排序：希尔排序" class="headerlink" title="8.2 改进插入排序：希尔排序"></a>8.2 改进插入排序：希尔排序</h3><p>插入排序的思想是：一个数组分成两个部分，一部分是排序的，一部分是未排序的，把未排序的内容插入排序的部分，实现排序的效果。</p><p>简单插入很难实现并行化，因此，我们对其扩展，就是希尔排序，对整个数组间隔 h 分割为多个子数组，数组互相插在一起，每次对一个子数组排序；每一组排序完成，递减 h 的值，进行下一轮排序，直到 h 为1。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223151040.png" alt></p><h2 id="9-矩阵乘法"><a href="#9-矩阵乘法" class="headerlink" title="9. 矩阵乘法"></a>9. 矩阵乘法</h2><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223151119.png" alt></p><p>这个很好理解，分割矩阵即可。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223151148.png" alt></p><h2 id="10-NIO"><a href="#10-NIO" class="headerlink" title="10. NIO"></a>10. NIO</h2><p>NIO 是 New IO 的简称，涉及通道和缓存区。</p><h3 id="10-1-基于-Socket-的服务端多线程模式"><a href="#10-1-基于-Socket-的服务端多线程模式" class="headerlink" title="10.1 基于 Socket 的服务端多线程模式"></a>10.1 基于 Socket 的服务端多线程模式</h3><p>服务端多线程处理的结构如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223151321.png" alt></p><p>服务器为每一个客户端连接启动一个线程，为了接受客户端连接，服务器还需要一个派发线程。</p><blockquote><p>结果自然是慢吞吞的，因为服务器先读入客户端的输入，而客户端缓慢的处理速度，使得服务端花费不少时间用于等待。</p></blockquote><p>下面看看服务端 Demo 吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService tp = Executors.newCachedThreadPool();</span><br><span class="line">  <span class="comment">// 服务端</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleMsg</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Socket clientSocket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandleMsg</span><span class="params">(Socket clientSocket)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.clientSocket = clientSocket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      BufferedReader is = <span class="keyword">null</span>;</span><br><span class="line">      PrintWriter os = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        os = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 从 InputStream 中读取客户端所发送的数据</span></span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> b = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> ((inputLine = is.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          System.out.println(inputLine);</span><br><span class="line">          os.println(inputLine);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"spend"</span> + (e - b) + <span class="string">"ms"</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is != <span class="keyword">null</span>) is.close();</span><br><span class="line">          <span class="keyword">if</span> (os != <span class="keyword">null</span>) os.close();</span><br><span class="line">          clientSocket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ServerSocket echoServer = <span class="keyword">null</span>;</span><br><span class="line">    Socket clientSocket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      echoServer = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        clientSocket = echoServer.accept();</span><br><span class="line">        System.out.println(clientSocket.getRemoteSocketAddress() + <span class="string">" connect!"</span>);</span><br><span class="line">        tp.execute(<span class="keyword">new</span> HandleMsg(clientSocket)); <span class="comment">// 用线程池处理每一个请求</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClientDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 客户端</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Socket client = <span class="keyword">null</span>;</span><br><span class="line">    PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client = <span class="keyword">new</span> Socket();</span><br><span class="line">      client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8000</span>));</span><br><span class="line">      writer = <span class="keyword">new</span> PrintWriter(client.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">      writer.println(<span class="string">"hello"</span>);</span><br><span class="line">      writer.flush();</span><br><span class="line">      reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">      System.out.println(<span class="string">"from server: "</span> + reader.readLine());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (writer != <span class="keyword">null</span>) writer.close();</span><br><span class="line">      <span class="keyword">if</span> (reader != <span class="keyword">null</span>) reader.close();</span><br><span class="line">      <span class="keyword">if</span> (client != <span class="keyword">null</span>) client.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的致命弱点就是客户端输入缓慢，服务端一直等待，主要时间都花费在等待上。</p><h3 id="10-2-使用-NIO-进行网络编程"><a href="#10-2-使用-NIO-进行网络编程" class="headerlink" title="10.2 使用 NIO 进行网络编程"></a>10.2 使用 NIO 进行网络编程</h3><p>通道，类似于流，一个「Channel」可以和文件或者网络「Socket」对应，和它一起使用的另外一个组件是「Buffer」，可以理解成一个内存区域或者 byte 数组，数据包装成「Buffer」的形式才能和「Channel」进行交互。</p><p>另外一个和「Channel」相关的是「Selector」，在「Channel」众多实现中，有一个是「SelectableChannel」，表示可被选择的通道，任何一个「SelectableChannel」可以被注册到一个「Selector」中，这样一个「Channel」就能被「Selector」所管理，而一个「Selector」可以管理多个「SelectableChannel」，当「SelectableChannel」数据准备好了，「Selector」就会接到通知，得到已经准备好的数据。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190223152552.png" alt></p><p>当与客户端连接的数据没有准备好时，「Selector」处于等待状态，一旦任何一个「Channel」准备好了数据，「Selector」就能立即得到通知，获取数据并处理。</p><h2 id="11-AIO"><a href="#11-AIO" class="headerlink" title="11. AIO"></a>11. AIO</h2><p>这是异步 IO 的缩写，即 Asynchronized 。对于 AIO 而言，它不是在 IO 准备好时通知线程，而是 IO 操作完成以后，再通知线程，因为它完全不会阻塞。</p><p>使用特殊的『AsynchronousServerSocketChannel』实现。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 高并发程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁的优化及注意事项</title>
      <link href="/technology/2019-02-21-lock-optimize/"/>
      <url>/technology/2019-02-21-lock-optimize/</url>
      
        <content type="html"><![CDATA[<h1 id="一、几点建议"><a href="#一、几点建议" class="headerlink" title="一、几点建议"></a>一、几点建议</h1><p>锁将导致整体性能下降，这里有几点建议。</p><h2 id="1-1-减小锁持有时间"><a href="#1-1-减小锁持有时间" class="headerlink" title="1.1 减小锁持有时间"></a>1.1 减小锁持有时间</h2><p><strong>程序应该减少对某个锁的占有时间，减少互斥的可能</strong>。下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  othercode1();</span><br><span class="line">  mutextMethod();</span><br><span class="line">  othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设在 <code>syncMethod</code> 方法中只有 <code>mutextMethod</code> 方法是需要同步的，而 <code>othercode1</code> 和 <code>othercode2</code> 方法不需要同步，而假设这两个方法是重量级的，需要时间去使用 CPU ，那么需要大量等待，一个更好的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  othercode1();</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    mutextMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们仅仅对 <code>mutextMethod</code> 方法进行同步，占用时间短，而且有更高的并行性，这样类似的还有比如正则表达式的『Pattern』类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Matcher <span class="title">matcher</span><span class="params">(CharSequence input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!compiled) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!compiled) &#123;</span><br><span class="line">        compile();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Matcher m = <span class="keyword">new</span> Matcher(<span class="keyword">this</span>, input);</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>matcher</code> 方法有条件地进行锁申请，进行局部加锁。</p><blockquote><p><strong>减少锁的持有时间有助于降低锁冲突的可能，进而提高并发能力</strong>。</p></blockquote><h2 id="1-2-减小锁粒度"><a href="#1-2-减小锁粒度" class="headerlink" title="1.2 减小锁粒度"></a>1.2 减小锁粒度</h2><p>减小粒度是一种削弱多线程的一种手段，比如『ConcurrentHashMap』，之前说到过，使用『Collections』包可以实现线程安全的『HashMap』，其中使用了「mutex」对象进行互斥。</p><p>对于『HashMap』而言，最重要的自然是 <code>get</code> 方法和 <code>put</code> 方法，我们如果全局加锁，那么锁的粒度太大，在『ConcurrentHashMap』中，将细分若干小的『HashMap』，这些被称作<strong>段</strong>，默认下一个『ConcurrentHashMap』被分为16个段。</p><p>如果现在往『ConcurrentHashMap』中添加元素，不是将整个『HashMap』加锁，而是<strong>根据「hashcode」决定将该项放到哪个段中，然后对段进行加锁</strong>，如果多线程执行 <code>put</code> 方法，只要不是同一个段，那么就是真正的并行！</p><p>因为默认是16个段，如果够幸运，应该最多能同时接受16个线程，大大提高了吞吐量。下面是 <code>put</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span> <span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  Segment&lt;K,V&gt; s;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> hash = hash(key); <span class="comment">// 获取 key 相应的 hash</span></span><br><span class="line">  <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; <span class="comment">// 获取段序号</span></span><br><span class="line">  <span class="keyword">if</span> ((s = (Segment&lt;K, V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT)+ SBASE)) == <span class="keyword">null</span>) <span class="comment">// recheck</span></span><br><span class="line">    s = ensureSegment(j); <span class="comment">// 得到段</span></span><br><span class="line">  <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少锁粒度将引发一个新的问题：<strong>当系统获取全局锁的时候，消耗的内存比较多</strong>。</p><p>虽然我们的 <code>put</code> 方法很好的分离了锁，但是当我们试图访问『ConcurrentHashMap 的全局信息的时候，需要同时取得所有锁才能顺利实施，比如说 <code>size</code> 方法，它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) <span class="comment">// 对所有的段加锁</span></span><br><span class="line">  segments[i].lock();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) <span class="comment">// 统计总数</span></span><br><span class="line">  sum += segments[i].count;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) <span class="comment">// 释放所有锁</span></span><br><span class="line">  segments[i].unlock();</span><br></pre></td></tr></table></figure><p>事实上 <code>size</code> 方法不总是这样的，它先使用无锁的方式求和，如果失败才采取这样的方式。</p><p><strong>只有在 <code>size</code> 这样获取全局信息不频发的情况下，减少锁粒度的方法才能提高系统吞吐量</strong>。</p><blockquote><p>或者说减少锁定对象的范围，从而减少锁冲突的可能。</p></blockquote><h2 id="1-3-读写分离锁替换独占锁"><a href="#1-3-读写分离锁替换独占锁" class="headerlink" title="1.3 读写分离锁替换独占锁"></a>1.3 读写分离锁替换独占锁</h2><p>我们知道读写锁『ReadWriteLock』可以提高系统性能，这也是减小锁粒度的一种情况，<strong>如果说减少锁粒度是分割数据结构，那么读写锁是对系统功能点的分割</strong>。</p><blockquote><p>在读多写少的场景，使用读写锁可以有效提高系统的并行能力。</p></blockquote><h2 id="1-4-锁分离"><a href="#1-4-锁分离" class="headerlink" title="1.4 锁分离"></a>1.4 锁分离</h2><p>将读写锁的思想进一步延伸，就是所分离。一个例子就是『java.util.concurrent.LinkedBlockingQueue』的实现。</p><blockquote><p>可以回忆它的近亲，『ArrayBlockingQueue』。</p></blockquote><p>同样，这里的 <code>take</code> 方法和 <code>put</code> 方法分别实现了从队列取和放入队列的功能，由于是链表，这两个操作分别作用在队列的前端和尾端。</p><blockquote><p> 使用独占锁，这两个方法就不可能真正并发，它们互相等待对方资源释放。</p></blockquote><p>因此，在 JDK 中，我们取而代之的是使用两把不同的锁，分离 <code>take</code> 方法和 <code>put</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// take 方法需要持有 takeLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// put 方法需要持有 putLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><blockquote><p>可以发现和『ArrayBlockingQueue』很像。</p></blockquote><p>以上，我们定义好「takeLock」和「putLock」，它们分别在 <code>take</code> 方法和 <code>put</code> 方法中使用，因此它们互相独立，<code>take</code> 方法和 <code>take</code> 方法竞争，<code>put</code> 方法和 <code>put</code> 方法竞争，做到削弱竞争的可能性。</p><p>下面是 <code>take</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  E x;</span><br><span class="line">  <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">  takeLock.lockInterruptibly(); <span class="comment">// 不能有两个线程同时取数据</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">// 没有可用线程进行等待</span></span><br><span class="line">      notEmpty.await(); <span class="comment">// 等待 put 方法的通知</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = dequeue(); <span class="comment">// 取得第一个数</span></span><br><span class="line">    c = count.getAndDecrement(); <span class="comment">// 数量减一，原子操作，变量 c 是 count 减一前的数字</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">      notEmpty.signal(); <span class="comment">// 通知其他 take 操作</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    takeLock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c == capacity)</span><br><span class="line">    signalNotFull(); <span class="comment">// 通知 put 方法，已经没有空间了</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 <code>put</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">  Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">  <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">  putLock.lockInterruptibly(); <span class="comment">// 不能两个线程同时 put</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count.get() == capacity) &#123; <span class="comment">// 队列满了</span></span><br><span class="line">      notFull.await(); <span class="comment">// 等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    enqueue(node); <span class="comment">// 插入数据</span></span><br><span class="line">    c = count.getAndIncrement(); <span class="comment">// 更新总是，c 是 count 加一前的数</span></span><br><span class="line">    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">      notFull.signal(); <span class="comment">// 空间足够，通知其他线程</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    putLock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">    signalNotEmpty(); <span class="comment">// 插入成功，通知 take 取数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过「takeLock」和「putLock」两把锁，实现取和写的分离。</p><h2 id="1-5-锁粗化"><a href="#1-5-锁粗化" class="headerlink" title="1.5 锁粗化"></a>1.5 锁粗化</h2><p>通常情况下，我们要求线程持有锁的时间尽可能短，完成就释放，<strong>如果对一个锁不断请求，同步，释放，那么也会消耗资源，反而不利于优化</strong>。</p><p><strong>虚拟机遇到一系列对锁的请求和释放，就会整合对锁一次的请求，减少同步次数</strong>，就是锁粗化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 做其他不需要同步的工作，但很快完毕</span></span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合成以下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">    <span class="comment">// 其他工作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合理粗化是有用的，但是下面的情况就不必要了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CIRCLE; ++i) &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更合理的，应该这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CIRCLE; ++i) &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>锁粗化的思想和减少持有时间正好相反，应该根据实际情况，进行权衡。</p></blockquote><h1 id="二、Java-虚拟机对锁的优化"><a href="#二、Java-虚拟机对锁的优化" class="headerlink" title="二、Java 虚拟机对锁的优化"></a>二、Java 虚拟机对锁的优化</h1><h2 id="2-1-锁偏向"><a href="#2-1-锁偏向" class="headerlink" title="2.1 锁偏向"></a>2.1 锁偏向</h2><p>如果一个线程获得锁，那么锁就进入偏向模式，<strong>再次请求这个线程，无需再做同步操作</strong>，因此在几乎没有锁竞争的场合，偏向锁很好，因为多次极有可能是同一个线程请求相同的锁。<strong>而在竞争激烈的场合，效果不佳</strong>，最可能的情况是不同线程请求相同的锁。</p><blockquote><p>可以使用参数「-XX:+UseBiasedLocking」开启偏向锁。</p></blockquote><h2 id="2-2-轻量级锁"><a href="#2-2-轻量级锁" class="headerlink" title="2.2 轻量级锁"></a>2.2 轻量级锁</h2><p>偏向锁失败，虚拟机不会立即挂起线程，而是采用轻量级锁的优化手段，简单将对象头部作为指针，指向持有锁的线程堆栈内部，以此判断线程是否持有锁。<strong>如果线程获得轻量级锁成功，则进入临界区；如果失败，则表示其他线程获得了锁，当前线程的锁清秋膨胀为重量级锁</strong>。</p><h2 id="2-3-自旋锁"><a href="#2-3-自旋锁" class="headerlink" title="2.3 自旋锁"></a>2.3 自旋锁</h2><p>锁膨胀以后，虚拟机还会最后努力一下，也许在几个 CPU 时钟周期后就获得锁了，因此虚拟机将当前线程进行几个<strong>空循环</strong>（这也是自旋的含义），如果获得就进入临界区；如果没有，才真正进行挂起。</p><h2 id="2-4-锁消除"><a href="#2-4-锁消除" class="headerlink" title="2.4 锁消除"></a>2.4 锁消除</h2><p>JVM 在 JIT 编译时，通过上下文扫描，<strong>去除不可能共享资源竞争的锁</strong>。</p><p>比如我们日常使用的『Vector』，这个类是线程安全的，而如果我们在方法内使用，那么该对象就是局部变量，在<strong>虚拟机栈上分配内存</strong>，此时，这些锁同步操作就会被去除。</p><blockquote><p>当在方法区外使用这个『Vector』时，就涉及了<strong>逃逸分析</strong>，不能进行锁消除了。</p><p>逃逸分析必须在「-server」模式下进行，使用「-XX:+DoEscapeAnalysis」参数打开逃逸分析，使用「-XX:+EliminateLocks」参数可以打开锁消除。</p></blockquote><h1 id="三、ThreadLocal"><a href="#三、ThreadLocal" class="headerlink" title="三、ThreadLocal"></a>三、ThreadLocal</h1><h2 id="3-1-ThreadLocal-简单实用"><a href="#3-1-ThreadLocal-简单实用" class="headerlink" title="3.1 ThreadLocal 简单实用"></a>3.1 ThreadLocal 简单实用</h2><p>加锁只是一种解决办法，另外一种办法则是使用『ThreadLocal』，感受人手一支笔。</p><p>比如下面的 demo :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>.i=i;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Date t=sdf.parse(<span class="string">"2015-03-29 19:29:"</span>+i%<span class="number">60</span>);</span><br><span class="line">      System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">      e.printstackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">  ExecutorService es=Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) &#123;</span><br><span class="line">    es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是解析字符串类型的日期，但是一般，会有一场，因为 <code>SimpleDateFormat.parse()</code> 不是线程安全的，在线程池中共享这个对象会导致错误。</p><p><strong>一个办法是在 <code>sdf.parse()</code> 前后加锁</strong>，而另外一个办法则是<strong>使用『ThreadLocal』为每一个线程产生一个『SimpleDateformat』对象实例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; t1 = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>.i=i;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t1.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t1.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      Date t = t1.get().parse(<span class="string">"2015-03-29 19:29:"</span> + i % <span class="number">60</span>);</span><br><span class="line">      System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果线程不持有『SimpleDateformat』对象，则新建，否则直接使用。当然，如果再应用上为每一个线程分配相同的对象，那么『ThreadLocal』也不能保证线程安全。</p><h2 id="3-2-ThreadLocal-的实现原理"><a href="#3-2-ThreadLocal-的实现原理" class="headerlink" title="3.2 ThreadLocal 的实现原理"></a>3.2 ThreadLocal 的实现原理</h2><p>『ThreadLocal』如何保证对象只有当前线程可以访问呢？问题自然是它的 <code>set</code> 和 <code>get</code> 两个方法。从 <code>set</code> 开始看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获得当前线程，然后获得线程的『ThreadLocal』，并将值设入『ThreadLocalMap』中，这可以理解成一个『HashMap』，它是定义在『Thread』内部的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>我们在设置『ThreadLocal』的数据，就是写入这个「map」中，其中「key」是当前对象，而「value」是我们需要的值，那么 <code>get</code> 就是从「map」中取出数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先 <code>get</code> 获得当前线程的『ThreadLocalMap』对象，然后通过自己作为「key」获得内部实际数据。</p></blockquote><p>这些变量维护在『Thread』内部，意味着只要线程不退出，对象引用一直存在。</p><p>线程退出，『Thread』类会进行清理工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">    group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">    group = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  target = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 加速资源清理</span></span><br><span class="line">  threadLocals = <span class="keyword">null</span>;</span><br><span class="line">  inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">  inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">  blocker = <span class="keyword">null</span>;</span><br><span class="line">  uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果使用线程池，那么线程未必会退出，如果设置对象到『ThreadLocal』但是又不清理，几次之后，对象也无法回收，也不能再用，因此，最好使用 <code>ThreadLocal.remove()</code> 将变量移除。</p><hr><p>我们也可以像释放普通变量那样释放『ThreadLocal』。我们会写下 <code>obj=null</code> 这样的代码，会更容易让垃圾回收器发现对象，从而回收。</p><p>同样，对于『ThreadLocal』我们也可以使用 <code>t1=null</code> ，现在这个对象的所有线程局部变量都可能被回收。</p><p>下面的代码执行以后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo_Gc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadLocal&lt;SimpleDateFormat&gt; t1 = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.toString() + <span class="string">" is gc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          t1.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              System.out.println(<span class="keyword">this</span>.toString() + <span class="string">" is gc"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          System.out.println(Thread.currentThread().getId() + <span class="string">":create SimpleDateFormat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date t = t1.get().parse(<span class="string">"2019-02-19 22:08:"</span> + i % <span class="number">60</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cd.countDown(); <span class="comment">// 一个线程完成，计时器减一</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">      es.submit(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">    &#125;</span><br><span class="line">    cd.wait(); <span class="comment">// 等待 CountDownLatch 完成</span></span><br><span class="line">    System.out.println(<span class="string">"mission complete!"</span>);</span><br><span class="line">    t1 = <span class="keyword">null</span>; <span class="comment">// 进行一次 GC 同时也是单单删除了 t1</span></span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(<span class="string">"first GC complete!!"</span>);</span><br><span class="line">    <span class="comment">// 在设置 ThreadLocal 的时候，会清除 ThreadLocalMap 中的无效对象</span></span><br><span class="line">    t1 = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line">    cd = <span class="keyword">new</span> CountDownLatch(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">      es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">    &#125;</span><br><span class="line">    cd.await(); <span class="comment">// 等待 CountDownLatch 完成</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(<span class="string">"second GC complete!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先10个线程创建各自的『SimpleDateFormat』，然后进行一次 GC ，发现一开始的『ThreadLocal』对象被回收，<strong>因为我们把它设置为了 「null」 </strong>；接着提交第二次任务，也创建10个『SimpleDateFormat』，然后第二次没有单独指定就进行 GC ，发现第一次全部10个『SimpleDateFormat』被回收了，</p><blockquote><p>出现这样的原因是因为『ThreadLocalMap』的实现使用了弱引用，JVM 在垃圾回收的时候，如果发现弱引用，会立即回收，当『ThreadLocal』的外部强引用被回收时，『ThreadLocalMap』的「key」会变成 null ，因此在第一次 GC 时，一个『ThreadLocal』对象被回收，第二次其对应的10个『SimpleDateFormat』自然被删除了。</p></blockquote><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190219230459.png" alt></p><h2 id="3-3-对性能有何帮助"><a href="#3-3-对性能有何帮助" class="headerlink" title="3.3 对性能有何帮助"></a>3.3 对性能有何帮助</h2><blockquote><p>如果共享对象对于竞争的处理容易引起性能损失，我们就应该使用『ThreadLocal』为每一个线程分配单独的对象。</p></blockquote><p>比如多线程下产生随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RndTaskTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GEN_COUNT = <span class="number">10000000</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">static</span> ExecutorService exe = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random(<span class="number">123</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Random&gt; tRnd = <span class="keyword">new</span> ThreadLocal&lt;Random&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Random <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Random(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RndTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RndTask</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.mode = mode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Random <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mode == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rnd;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tRnd.get();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> b = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; GEN_COUNT; i++) &#123;</span><br><span class="line">        getRandom().nextInt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"spend "</span> + (e - b) + <span class="string">"ms"</span>);</span><br><span class="line">      <span class="keyword">return</span> e - b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Future&lt;Long&gt;[] futs = <span class="keyword">new</span> Future[THREAD_COUNT];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">      futs[i] = exe.submit(<span class="keyword">new</span> RndTask(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> totaltime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">      totaltime += futs[i].get();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"多线程访问同一个 Random 实例："</span> + totaltime + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">// ThreadLocal 的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">      futs[i] = exe.submit(<span class="keyword">new</span> RndTask(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    totaltime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">      totaltime += futs[i].get();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"使用 ThreadLocal 包装 Random 实例："</span> + totaltime + <span class="string">"ms"</span>);</span><br><span class="line">    exe.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果发现，如果多线程共享同一个『Random』实例，总耗时接近13秒，在『ThreadLocal』模式下，耗时不到1秒。</p><h1 id="四、无锁"><a href="#四、无锁" class="headerlink" title="四、无锁"></a>四、无锁</h1><h2 id="4-1-比较交换"><a href="#4-1-比较交换" class="headerlink" title="4.1 比较交换"></a>4.1 比较交换</h2><p>CAS 包含三个参数「V E N」，V 表示要更新的变量，E 表示预期，N 表示新值，<strong>仅当 V 等于 E 时，才会将 V 改成 N </strong>，如果 V 和 E 不同，表示有其他线程进行了修改，则什么都不做。最后，CAS 会返回当前 V 的真实值。</p><blockquote><p>CAS 是乐观态度的操作，它总是认为可以完成操作，当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，<strong>失败的线程不会挂起，仅是被告知失败，并允许重新尝试</strong>。</p></blockquote><p>从 JDK5 以后，虚拟机可以使用这个指令来实现并发操作和并发数据结构。</p><h2 id="4-2-AtomicInteger"><a href="#4-2-AtomicInteger" class="headerlink" title="4.2 AtomicInteger"></a>4.2 AtomicInteger</h2><p>JDK 并发包里面实现了一些直接使用 CAS 操作的线程安全的类型。其中，最常用的就是『AtomicInteger』，与『Integer』不同，它是可变的，而且是线程安全的，下面是『AtomicInteger』的一些主要方法，其他原子类也是类似的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>; <span class="comment">// 取得当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>; <span class="comment">// 设置当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>; <span class="comment">// 设置新值，并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> u)</span></span>; <span class="comment">// 如果当前值是 expect 则设置成 u</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>; <span class="comment">// 当前值加1，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span></span>; <span class="comment">// 当前值减1，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span></span>; <span class="comment">// 当前值加 delta ，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>; <span class="comment">// 当前值加1，返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span></span>; <span class="comment">// 当前值减1，返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span></span>; <span class="comment">// 当前值加 delta ，返回新值</span></span><br></pre></td></tr></table></figure><p>就内部实现而言，『AtomicInteger』中保存一个核心字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>它表示『AtomicInteger』的当前实际取值，此外还有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br></pre></td></tr></table></figure><p>它保存着「value」字段在『AtomicInteger』对象中的偏移量，这个偏移量是实现『AtomicInteger』的关键。</p><p>下面是一个关于『AtomicInteger』的 demo ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; ++k)</span><br><span class="line">        i.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">      ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) ts[k].start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) ts[k].join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，最后输出的结果是100000，所以执行是正确的，如果线程不安全，结果应该小于100000。</p><p>下面是 <code>incrementAndGet()</code> 的内部实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAnGet</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="title">for</span> <span class="params">(;;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current = get();</span><br><span class="line">    <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSet(current, next));</span><br><span class="line">      <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>get</code> 方法就非常简单，只是返回内部的「value」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，我们应该好奇为什么设置一个值这么简单的操作都需要一个死循环，<strong>CAS操作未必成功，对于不成功，我们不断重复尝试</strong>。</p></blockquote><p>和『AtomicInteger』类似的还有『AtomicLong』来代替『Long』类型，『AtomicBoolean』代替『Boolean』类型，『AtomicRegerence』表示对象引用。</p><h2 id="4-3-Java-中的指针：Unsafe-类"><a href="#4-3-Java-中的指针：Unsafe-类" class="headerlink" title="4.3 Java 中的指针：Unsafe 类"></a>4.3 Java 中的指针：Unsafe 类</h2><p>我们特别注意到 <code>compareAndSet</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里涉及一个特殊的变量「unsafe」，它是『sun.misc.Unsafe』类型，从名字看，什么是不安全？指针是不安全的，这也是在 Java 中把指针去除的原因。</p></blockquote><p>这里的『Unsafe』就是封装了一些类似指针的操作，<code>compareAndSwapInt()</code> 方法是一个 native 方法，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数「o」是给定的对象，「offset」是对象内的偏移量，其实就是一个字段到对象头部的偏移量，通过这个偏移量可以快速定位字段，「expected」表示期望，「x」表示要设置的值。如果指定的字段的值等于「expected」，那么就会把它设置为「x」。</p><p><code>compareAndSwapInt</code> 方法的内部，使用 CAS 原子指令，此外，『Unsafe』类还提供了一些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得给定对象偏移量上的 int 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 设置给定对象偏移量上的 int 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 获得字段在对象中的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"><span class="comment">// 设置给定对象的 int 值，使用 volatile 语义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 获得给定对象的 int 值，使用 volatile 语义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 和 putIntVolatile 一样，但是要求被操作字段是 volatile 类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>可以回忆『ConcurrentLinkedQueue』中对「node」的一些操作就是使用『Unsafe』类来实现的。</p></blockquote><p>虽然 Java 抛弃了指针，但是在关键时刻，类似指针的技术是必不可少的。对于『Unsafe』实现就是最好的例子，但是 JDK 的开发人员不希望大家使用这个类，获取『Unsafe』实例的方法是调用其工厂方法 <code>getUnsafe</code> ，它的实现是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class cc = Reflection.getClasserClass();</span><br><span class="line">  <span class="keyword">if</span> (cc.getClassLoader() != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">  <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>它会检查 <code>getUnsafe</code> 函数的类，如果这个类的『ClassLoader』不为「null」，就抛出异常，这导致我们无法直接使用『Unsafe』类。</p></blockquote><h2 id="4-4-无锁对象引用：AtomicReference"><a href="#4-4-无锁对象引用：AtomicReference" class="headerlink" title="4.4 无锁对象引用：AtomicReference"></a>4.4 无锁对象引用：AtomicReference</h2><p>在介绍『AtomicReference』前，先提出一个关于原子操作的逻辑上的不足。</p><p>当我们在获得对象当前值以后，<strong>准备修改为新值前，对象被其他线程连续修改了两次</strong>，而经过修改后，对象的值又恢复为旧值，这样，我们无法判断对象是否被修改过。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190221133013.png" alt></p><blockquote><p>现实中，我们要修改的值，通常不仅仅取决于当前值，还和对象的过程变化有关，这时，『AtomicRegerence』就无能为力了。</p></blockquote><p>有个蛋糕店，为了挽留客户，对余额低于20元的客户一次赠送20元，但只能被赠送一次，首先定义账户余额：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> AtomicReference&lt;Integer&gt; money = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置账户低于20，显然需要一个需要被充值的账户</span></span><br><span class="line">    money.set(<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟多个线程同时更新后台数据库，为用户充值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              Integer m = money.get();</span><br><span class="line">              <span class="keyword">if</span> (m &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (money.compareAndSet(m, m + <span class="number">20</span>)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"余额低于20元，充值成功，余额为"</span> + money.get() + <span class="string">"元"</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// System.out.println("余额大于20元，无需充值");</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户消费线程，模拟消费行为</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Integer m = money.get();</span><br><span class="line">            <span class="keyword">if</span> (m &gt; <span class="number">10</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">"大于10元"</span>);</span><br><span class="line">              <span class="keyword">if</span> (money.compareAndSet(m, m - <span class="number">10</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费10元，剩余"</span> + money.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">"金额不足"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，这个账户被反复多次充值，修改后的值等于原值，这种情况就比较尴尬。运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">余额低于20元，充值成功，余额为39元</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余29</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余19</span><br><span class="line">余额低于20元，充值成功，余额为39元</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余29</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余19</span><br><span class="line">余额低于20元，充值成功，余额为39元</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余29</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="4-5-带时间戳的对象引用：AtomicStampedReference"><a href="#4-5-带时间戳的对象引用：AtomicStampedReference" class="headerlink" title="4.5 带时间戳的对象引用：AtomicStampedReference"></a>4.5 带时间戳的对象引用：AtomicStampedReference</h2><p>之所以『AtomicRegerence』无法解决上述问题的根本原因，对象值本身和状态被画上了等号，『AtomicStampedReference』不仅维护了对象值，还维护了一个时间戳，当值被修改了，时间戳也要进行更新。</p><p>它新增了几个关于时间戳的 Api ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较设置参数依次：期望 新值 期望时间戳 新时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expectedReference, V newReference, <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前对象引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取当前时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 设置当前对象引用和时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span></span>;</span><br></pre></td></tr></table></figure><p>有了这个法宝，我们不用担心对象被写坏了，修正贵宾发的 demo ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; money = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">19</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟多线程更新后台，为用户充值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> timeStamp = money.getStamp();</span><br><span class="line">      <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              Integer m = money.getReference();</span><br><span class="line">              <span class="keyword">if</span> (m &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (money.compareAndSet(m, m + <span class="number">20</span>, timeStamp, timeStamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"余额小于20元，充值成功，余额"</span> + money.getReference() + <span class="string">"元"</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// System.out.println("余额大于20元，无需充值");</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用户消费线程，模拟消费行为</span></span><br><span class="line">      <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> timeStamp = money.getStamp();</span><br><span class="line">              Integer m = money.getReference();</span><br><span class="line">              <span class="keyword">if</span> (m &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"大于10元"</span>);</span><br><span class="line">                <span class="keyword">if</span> (money.compareAndSet(m, m - <span class="number">10</span>, timeStamp, timeStamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"消费10元，剩余"</span> + money.getReference());</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"金额不足"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为修改时间戳，所以系统不可能发生二次赐予，运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">余额小于20元，充值成功，余额39元</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余29</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余19</span><br><span class="line">大于10元</span><br><span class="line">消费10元，剩余9</span><br><span class="line">金额不足</span><br><span class="line">金额不足</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="4-6-数组也能无锁：AtomicIntegerArray"><a href="#4-6-数组也能无锁：AtomicIntegerArray" class="headerlink" title="4.6 数组也能无锁：AtomicIntegerArray"></a>4.6 数组也能无锁：AtomicIntegerArray</h2><p>除了对于基本类型，JDK 还提供了数组等复合结构，当前可用的原子数组有：『AtomicIntegerArray』、『AtomicLongArray』、『AtomicReferenceArray』。这里以『AtomicIntegerArray』为例，展示原子数组的使用方式。</p><p>它的本质是对 <code>int[]</code> 的封装，使用『Unsafe』类通过 CAS 的方式控制 <code>int[]</code> 在多线程下的安全性，其核心 Api 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得数组第i个下标元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 获得数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 将数组第i个下标设置成newValue，并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"><span class="comment">// 进行CAS操作，如果第i个下标是expect，则设置成update，设置成功返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;</span><br><span class="line"><span class="comment">// 将第i个下标的元素加1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 将第i个下标的元素减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 将第i个下标的元素增加delta</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span></span>;</span><br></pre></td></tr></table></figure><p>跑一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> AtomicIntegerArray arr = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; ++k) &#123;</span><br><span class="line">        arr.getAndIncrement(k % arr.length());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">      ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">      ts[k].start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">      ts[k].join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面声明一个包含10个元素的数组，每个元素各加1000次，每个线程结果都是10000，如果线程不安全，那么即通过应该会小于10000，结果如下，可以看出，『AtomicIntegerArray』保证了数组的线程安全性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br></pre></td></tr></table></figure><h2 id="4-7-让普通变量也享受原子操作：AtomicIntegerFieldUpdater"><a href="#4-7-让普通变量也享受原子操作：AtomicIntegerFieldUpdater" class="headerlink" title="4.7 让普通变量也享受原子操作：AtomicIntegerFieldUpdater"></a>4.7 让普通变量也享受原子操作：AtomicIntegerFieldUpdater</h2><blockquote><p>如果我们随意在开发中将一个变量变成线程安全的，那么需要在每一处使用它的地方都进行修改，并且这还不符合开闭原则，系统功能的增加应该是开放的，而修改应该是相对保守的，一个一个修改也令人厌烦。</p></blockquote><p>『AtomicIntgerFieldUpdater』类可以在不改动原有代码基础上，让普通变量享受 CAS 带来的线程安全性，这个「Updater」有三种，分别是『AtomicIntegerFieldUpdater』、『AtomicLongFieldUpdater』、『AtomicReferenceFieldUpdater』它们可以对『int』、『long』以及普通对象进行 CAS 修改。</p><p>假设有一个选举，每个选民有一票，投了记为1，没投记为0，最终选票显然就是所有数据的求和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">"score"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查Updater是否工作正确</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger allScore = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Candidate stu = <span class="keyword">new</span> Candidate(); <span class="comment">// 假设只有一个候选人</span></span><br><span class="line">    Thread[] t = <span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">      t[i] = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.4</span>) &#123;</span><br><span class="line">            scoreUpdater.incrementAndGet(stu);</span><br><span class="line">            allScore.incrementAndGet();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      t[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) t[i].join();</span><br><span class="line">    System.out.println(<span class="string">"score="</span> + stu.score);</span><br><span class="line">    System.out.println(<span class="string">"allScore="</span> + allScore);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，候选人的得票数被记录在「Candidate.score」中，它不是线程安全的，而「allScore」是线程安全的，它是用来检验结果是否正确的。</p><blockquote><ol><li>「Updater」只能修改可见范围内的变量，因为使用了反射，如果上面的「score」是 private 的，那么是不行的。</li><li>为了保证正确读取，它必须是 volatile 类型。</li><li>由于 CAS 操作会对对象实例中的偏移量直接赋值，因此，不支持 static 字段。<code>Unsafe.objectFieldOffset()</code> 不支持静态变量。</li></ol></blockquote><h2 id="4-8-无锁-Vector-实现"><a href="#4-8-无锁-Vector-实现" class="headerlink" title="4.8 无锁 Vector 实现"></a>4.8 无锁 Vector 实现</h2><p>使用『AtomicReferenceArray』实现。</p><h2 id="4-9-细看-SynchronousQueue-的实现"><a href="#4-9-细看-SynchronousQueue-的实现" class="headerlink" title="4.9 细看 SynchronousQueue 的实现"></a>4.9 细看 SynchronousQueue 的实现</h2><p>曾经我们看过一个非常特殊的等待队列『SynchronousQueue』，任何一个对它的写需要等待读，因此与其说它是一个队列，不如说是一个通道。它将 <code>put</code> 和 <code>take</code> 两个功能截然不同的操作抽象为一个共通的方法 <code>Transferer.tansfer()</code> ，完整签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">transfer</span><span class="params">(Object e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure><p>当参数 e 为非空，表示当前操作传递给一个消费者，如果为空，则表示当前操作需要请求一个数据。timed 参数决定是否存在 timeout 时间。nanos 表示了 timeout 的时长。如果返回值非空，则表示数据已经接受或正常提供，如果为空，则表示失败。</p><p>它的内部维护了一个线程等待队列，等待队列会保存等待线程以及相关数据的信息，比如生产者将数据放入『SynchronousQueue』时，如果没有消费者接收，那么数据本身和线程对象都会打包在队列中等待。</p><p><code>Transferer.transfer()</code> 函数的实现是『SynchronousQueue』的核心，它分三个步骤：</p><ol><li>如果等待队列为空，或者队列中节点的类型和本次操作是一致的，那么将当前操作压入队列等待；</li><li>如果等待队列中的元素和本次操作是互补的，则插入一个「完成」状态，并且让他匹配到一个等待节点上。接着弹出这两个节点，使得对应的两个线程继续执行；</li><li>如果线程发现等待队列的节点是「完成」节点，则帮助节点完成任务。</li></ol><h1 id="五、有关死锁的问题"><a href="#五、有关死锁的问题" class="headerlink" title="五、有关死锁的问题"></a>五、有关死锁的问题</h1><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190219233222.png" alt></p><p>我们可以用代码来模拟哲学家就餐问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Object tool;</span><br><span class="line">  <span class="keyword">static</span> Object fork1 = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">static</span> Object fork2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DeadLock</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tool = obj;</span><br><span class="line">    <span class="keyword">if</span> (tool == fork1)</span><br><span class="line">      <span class="keyword">this</span>.setName(<span class="string">"哲学家A"</span>);</span><br><span class="line">    <span class="keyword">if</span> (tool == fork2)</span><br><span class="line">      <span class="keyword">this</span>.setName(<span class="string">"哲学家B"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tool == fork1) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (fork1) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (fork2) &#123;</span><br><span class="line">          System.out.println(<span class="string">"哲学家 A 开始吃饭了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tool == fork2) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (fork2) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (fork1) &#123;</span><br><span class="line">          System.out.println(<span class="string">"哲学家 B 开始吃饭了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    DeadLock A = <span class="keyword">new</span> DeadLock(fork1);</span><br><span class="line">    DeadLock B = <span class="keyword">new</span> DeadLock(fork2);</span><br><span class="line">    A.start();</span><br><span class="line">    B.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哲学家 A 先用叉子1，哲学家 B 先占用叉子2，接着他们相互等待，都没有办法同时获得两个叉子。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 高并发程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK 并发包小结</title>
      <link href="/technology/2019-02-14-jdk-concurrent-package/"/>
      <url>/technology/2019-02-14-jdk-concurrent-package/</url>
      
        <content type="html"><![CDATA[<h1 id="一、同步控制"><a href="#一、同步控制" class="headerlink" title="一、同步控制"></a>一、同步控制</h1><h2 id="1-重入锁"><a href="#1-重入锁" class="headerlink" title="1. 重入锁"></a>1. 重入锁</h2><p>重入锁可以替代 synchronized 关键字，在 jdk5.0 早期，重入锁的性能好于 synchronized，从 jdk6.0 开始，synchronized 优化，两者性能差不多了。</p><p>重入锁例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重入锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000000</span>; ++j) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReenterLock tl = <span class="keyword">new</span> ReenterLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    t1.start(); t2.start();</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常直观地，我们发现和 synchronized 相比，这里的重入锁更加注重<strong>锁的细节</strong>，包括了上锁和解锁的过程。更加灵活。</p><p>值得注意的是，重入锁可以<strong>重入</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，一个线程连续两次获得同一把锁。这是允许的！<strong>如果同一个线程多次获得锁，那么在释放锁的时候，也必须释放相同次数！</strong>如果释放锁的次数多，那么会得到一个 <code>java. lang. IllegalMonitorState Exception</code> 异常，反之，如果释放锁的次数少了，那么相当于线程还持有这个锁，因此，其他线程也无法进入临界区。</p><h3 id="1-1-中断响应"><a href="#1-1-中断响应" class="headerlink" title="1.1 中断响应"></a>1.1 中断响应</h3><p>对于 synchronized 来说，如果一个线程在等待锁，那么结局是<strong>获得锁</strong>或者是<strong>保持等待</strong>；对于重入锁而言，还有可能被<strong>中断</strong>。</p><blockquote><p>如果一个线程正在等待锁，那么它收到一个通知，被告知无须再等待，可以停止了。</p></blockquote><p>下面的代码就是一个死锁，得益于锁中断，我已解决这个死锁！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IntLock</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line">        lock1.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        lock2.lockInterruptibly();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lock2.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        lock1.lockInterruptibly();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) lock1.unlock();</span><br><span class="line">      <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) lock2.unlock();</span><br><span class="line">      System.out.println(Thread.currentThread().getId() + <span class="string">":线程退出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    IntLock r1 = <span class="keyword">new</span> IntLock(<span class="number">1</span>);</span><br><span class="line">    IntLock r2 = <span class="keyword">new</span> IntLock(<span class="number">2</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 中断其中一个线程</span></span><br><span class="line">    t2.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到一个方法，叫做 <code>lockInterruptiby()</code> ，这个方法可以对中断进行响应，<strong>在等待锁的过程中，可以响应中断</strong>。</p><blockquote><p>线程 t1 获取了 lock1 ，然后去获取 lock2 ；线程 t2 获取了 lock2 ，然后去获取 lock1 。现在他们相互等待了，现在，我们中断一个线程，<strong>t2 会放弃对于 lock1 的申请，同时释放 lock2</strong> 。</p></blockquote><p>所以，最后完成任务的是 t1 ，而 t2 线程放弃任务直接退出，释放资源。</p><h3 id="1-2-锁申请等待限时"><a href="#1-2-锁申请等待限时" class="headerlink" title="1.2 锁申请等待限时"></a>1.2 锁申请等待限时</h3><p>避免死锁的另外一种方法是<strong>限时等待</strong>，给定一个时间，让线程自动放弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"get lock failed"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock.isHeldByCurrentThread()) lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TimeLock tl = <span class="keyword">new</span> TimeLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的方法，是使用了 <code>tryLock()</code> ，第一个参数是等待时间，第二个参数是计时单位。这个例子中，用于持有锁长达 6s ，另外一个线程会申请失败。当然，这个不会导致死锁了。</p><blockquote><p><code>tryLock()</code> 方法也可以不需要参数。立即获取或者立即失败。同样不会死锁。</p></blockquote><p>现在我们看一个非常绕的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">":My Job done"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock2.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock1.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>外层是一个 while 循环</strong>，线程1执行这里，然后线程2和它相反。如果不是 <code>tryLock()</code> 就非常容易死锁了，但是这里不会，因为是 <code>tryLock()</code> 嘛，立即返回结果，有意思的是这里的代码不能这样更改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getId() + <span class="string">":My Job done"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock2.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock1.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样改将报错！</strong>这是因为，我们假设有两个线程，线程1现在有 lock1 ，线程2现在有 lock2 ，此刻，线程1尝试获取 lock2 ，就是 <code>try{}</code> 代码里再用 <code>try{}</code> ，去获取 lock2 ，使用的是 <code>tryLock()</code> ，那么，现在我们失败了，于是执行到 <code>finally{}</code> ，<strong>问题在这里</strong>，我们没有 lock2 啊！所以这样改是错的。</p><h3 id="1-3-公平锁"><a href="#1-3-公平锁" class="headerlink" title="1.3 公平锁"></a>1.3 公平锁</h3><p>在大多情况下，锁都是非公平的，系统在一个锁可用的时候，从等待列表中随机挑选一个，因此不能保证其公平性。公平锁的特点是：<strong>不会产生解，只要排队，总会得到资源</strong>。如果使用 synchronized 关键字，那么锁就是非公平的。重入锁可以设置公平性，当 fair 为 true 时，锁公平。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure><p><strong>实现公平锁要维护一个有序序列</strong>，因此公平锁的实现成本较高，性能相对较低，默认情况下，锁是非公平的。下面的代码突出了公平锁的特点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公平锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock fairLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fairLock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 获得锁"</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fairLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FairLock r1 = <span class="keyword">new</span> FairLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(r1, <span class="string">"Thread_t1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(r1, <span class="string">"Thread_t2"</span>);</span><br><span class="line">    t1.start(); t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的情况下，t1 和 t2 将轮流获得锁，而在非公平锁的情况下，<strong>一个线程会倾向于再次获取已经持有的锁</strong>。</p><p>重入锁的实现，主要集中在 Java 层面，包含三个要素：</p><ol><li>原子状态。原子状态使用 CAS 操作来存储当前锁的状态，判断锁是否已经被别的线程持有。</li><li>等待队列。所有没有请求到锁的线程，会进入等待队列进行等待，待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作。</li><li>阻塞原语 park() 和 unpark() ，用来挂起和恢复线程。没有得到锁的线程将会被挂起。</li></ol><h2 id="2-Condition-条件"><a href="#2-Condition-条件" class="headerlink" title="2. Condition 条件"></a>2. Condition 条件</h2><p>我们知道 <code>wait()</code> 和 <code>notify()</code> 是配合 synchronized 关键字使用的，而 Condition 是与重入锁相关联的。</p><p>主要有下面几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 类似于 Object.wait(); 可以响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>; <span class="comment">// 与 await(); 的区别在于不响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>; <span class="comment">// 类似于 Object.notify(); 方法</span></span><br></pre></td></tr></table></figure><p>下面是一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockCondition</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Condition</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Condition conditon = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      conditon.await(); <span class="comment">// 释放了这把锁，进行等待</span></span><br><span class="line">      System.out.println(<span class="string">"Thread is going on"</span>); <span class="comment">// 又获得了锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReenterLockCondition tl = <span class="keyword">new</span> ReenterLockCondition();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    conditon.signal(); <span class="comment">// 从队列中唤醒一个线程</span></span><br><span class="line">    lock.unlock(); <span class="comment">// 把锁谦让给唤醒的线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的第27行，<strong>如果我们仅仅只是唤醒了一个线程，而不放弃这个锁，那么那个线程也是没有办法继续执行的</strong>。</p><p>在 JDK 内部，也使用了重入锁和 Condition ，比如 ArrayBlockingQueue 。</p><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h2><p>信号量是锁的扩展，无论是 synchronized 和 ReentrantLock ，一次只允许一个线程访问一个资源，而信号量可以指定多个线程，同时访问一个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> <span class="comment">//第二个参数可以指定是否公平</span></span></span><br></pre></td></tr></table></figure><p>信号量的主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="comment">// 尝试获取一个准入许可，若无法获得，将等待，直到获取或中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span> <span class="params">()</span> <span class="comment">// 不响应中断</span></span></span><br><span class="line"><span class="function">ublic <span class="keyword">boolean</span> <span class="title">tryAcquire</span> <span class="params">()</span> <span class="comment">// 立即返回，不等待</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span> <span class="params">()</span> <span class="comment">// 释放一个许可，其他线程可以进行资源访问</span></span></span><br></pre></td></tr></table></figure><p>小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemapDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      semp.acquire(); <span class="comment">// 获取一个锁</span></span><br><span class="line">      <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getId() + <span class="string">": done!"</span>);</span><br><span class="line">      semp.release(); <span class="comment">// 释放一个锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newFixedThreadPool(<span class="number">20</span>); <span class="comment">// 开启20个线程</span></span><br><span class="line">    <span class="keyword">final</span> SemapDemo demo = <span class="keyword">new</span> SemapDemo();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">      exec.submit(demo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，因为我们设置信号量为5，所以会分组完成。</p><h2 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4. 读写锁"></a>4. 读写锁</h2><p>ReadWriteLock 是 Jdk5 中提供的读写分离锁。假设有线程 A1、A2、A3 用来写，线程 B1、B2、B3 用来读，如果是重入锁或者内部锁那么理论上来讲：<strong>读之间、读写之间、写之间</strong>都是串行操作。这显然是不合理的。</p><p>读写锁允许多线程<strong>同时读</strong>，使得 B1、B2、B3 之间真正并行。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190202154736.png" alt></p><p>下面有个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 读写锁</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock(); <span class="comment">// 模拟读操作</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>); <span class="comment">// 读操作的耗时越多，读写锁的优势更加明显</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(Lock lock, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock(); <span class="comment">// 模拟写操作</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      value = index;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">    Runnable readRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          demo.handleRead(readLock); <span class="comment">// 并行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Runnable writeRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          demo.handleWrite(writeLock, <span class="keyword">new</span> Random().nextInt()); <span class="comment">// 串行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(readRunnable).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(writeRunnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用读写锁，上面的代码只要2秒多，而重入锁需要进行20多秒。</p><h2 id="5-倒计时器"><a href="#5-倒计时器" class="headerlink" title="5. 倒计时器"></a>5. 倒计时器</h2><p>CountDownLatch 中，CountDown 在英文中为倒计时，Latch 为门闩。</p><blockquote><p>把门锁起来，不让里面的线程跑出来，因此，这个工具通常用来控制线程等待。<strong>它让一个线程等待直到倒计时结束，再开始执行</strong>。</p></blockquote><p>比如火箭发射，火箭发射前，要等待所有的检查完毕，才能点火，执行。</p><p>下面就是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLoatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 倒计时器</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); <span class="comment">// 倒计时器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> CountDownLoatchDemo demo = <span class="keyword">new</span> CountDownLoatchDemo();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟检查任务</span></span><br><span class="line">      Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">      System.out.println(<span class="string">"check complete"</span>);</span><br><span class="line">      end.countDown(); <span class="comment">// 一个线程完成任务，倒计时器减一</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 线程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      exec.submit(demo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待检查</span></span><br><span class="line">    end.await(); <span class="comment">// 等到10个线程完成方可继续</span></span><br><span class="line">    <span class="comment">// 发射火箭</span></span><br><span class="line">    System.out.println(<span class="string">"File!"</span>);</span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述逻辑如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190203140459.png" alt></p><h2 id="6-循环栅栏"><a href="#6-循环栅栏" class="headerlink" title="6. 循环栅栏"></a>6. 循环栅栏</h2><p>CyclicBarrier 是另外一个多线程并发控制工具，和 CountDownLatch 类似，它实现线程间的计数等待，但是它的功能更加复杂且强大。</p><p>前面的 Cyclic 意为循环，也就是说这个计数器可以反复使用，<strong>假如我们将计数器设置为10，那么凑齐第一批10个线程后，计数器就会归零，然后接着凑齐下一批10个线程，这就是循环栅栏内在的含义</strong>。</p><p>比 CountDownLatch 略微强大的地方，CyclicBarrier 可以接收一个参数作为 barrierAction 。所谓的 barrierAction 就是当计数器完成一次计数后，系统会执行的动作。</p><p>下面第一个参数是等待数，第二个参数是执行的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span>;</span><br></pre></td></tr></table></figure><p>比如下面的司令命令士兵的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 循环栅栏</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String soldier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(CyclicBarrier cyclic, String soldier)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.soldier = soldier;</span><br><span class="line">      <span class="keyword">this</span>.cyclic = cyclic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待所有士兵到齐</span></span><br><span class="line">        cyclic.await();</span><br><span class="line">        doWork(); <span class="comment">// 执行任务</span></span><br><span class="line">        <span class="comment">// 等待所有士兵任务完成</span></span><br><span class="line">        cyclic.await();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(Math.abs(<span class="keyword">new</span> Random().nextInt() % <span class="number">10000</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(soldier + <span class="string">":任务完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> flag;</span><br><span class="line">      <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        N = n;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">          System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个，任务完成！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个，集合完成！"</span>);</span><br><span class="line">          flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">      Thread[] allSoldier = <span class="keyword">new</span> Thread[N];</span><br><span class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">      CyclicBarrier cyclic = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));</span><br><span class="line">      <span class="comment">// 设置屏障点，主要是为了执行这个方法</span></span><br><span class="line">      System.out.println(<span class="string">"集合队伍！"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        System.out.println(<span class="string">"士兵"</span> + i + <span class="string">"报道！"</span>);</span><br><span class="line">        allSoldier[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclic, <span class="string">"士兵"</span> + i));</span><br><span class="line">        allSoldier[i].start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>CyclicBarrier.await()</code> 以后每一个士兵线程集合完毕，之后再次使用该方法，将进行下一次计数，这次是监控士兵是否已经完成了任务。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190203233118.png" alt></p><p>这里可能有一个异常是 BrokenBarrierException ，一旦遇到这个异常，则表示当前的 CyclicBarrier 已经破损了，可能系统已经出现了问题没有办法达到线程到齐。</p><p>如果我们插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">  allSoldier[<span class="number">0</span>].interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将产生1个 InterruptedException 和9个 BrokenBarrierException 。</p><h2 id="7-LockSupport"><a href="#7-LockSupport" class="headerlink" title="7. LockSupport"></a>7. LockSupport</h2><p>LockSupport 是一个非常方便实用的线程阻塞工具，它可以在线程内任意位置让线程阻塞。<strong>和 <code>Thread.suspend()</code> 相比，它弥补了由于 <code>resume()</code> 在前发生，导致线程无法继续执行</strong>。它不会像 <code>Object.wait()</code> 相比，它不需要先获取对象的锁，也不会抛出 InterruptedException 异常。</p><p>LockSupport 的静态方法 <code>park()</code> 可以阻塞当前线程，类似的还有 <code>parkNanos()</code>、<code>parkUntil()</code> 等<br>方法。它们实现了一个限时的等待。</p><p>我们重写关于 <code>suspend()</code> 永久挂起的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LockSupport</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">  <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">        System.out.println(<span class="string">"in "</span> + getName());</span><br><span class="line">        LockSupport.park();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    LockSupport.unpark(t1); LockSupport.unpark(t2);</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们依然不能保证 <code>unpark()</code> 在 <code>park()</code> 后执行，<strong>但是可以正常结束</strong>。只有合适因为 LockSupport 内部使用了类似信号量的机制，每为一个线程准备一个许可，如果许可可用，那么 <code>park()</code> 会立即返回，并消费这个许可。不可用时，会阻塞。而 <code>unpark()</code> 会让一个许可可用，与信号量不同的是，许可不可能超过一个，永远只有一个！</p><blockquote><p>即使 <code>unpark()</code> 在 <code>park()</code> 前执行，它也可以在下一次 <code>park()</code> 的时候返回。</p></blockquote><p>虽然 LockSupport 不会抛出 <code>InterruptedException</code> 异常，但是我们可以通过 <code>Thread.interrupted()</code> 等方法获取中断标志。</p><h1 id="二、ThreadPool"><a href="#二、ThreadPool" class="headerlink" title="二、ThreadPool"></a>二、ThreadPool</h1><p>最简单的线程创建和回收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>上面的代码在 <code>run()</code> 之后自动回收该线程。<strong>对线程的使用必须掌握一个度，在有限的范围内，增加线程的数量可以明显提高系统的吞吐量</strong>。</p><h2 id="1-什么是线程池"><a href="#1-什么是线程池" class="headerlink" title="1. 什么是线程池"></a>1. 什么是线程池</h2><p>避免系统频繁创建和销毁线程，让创建的线程进行复用。好比数据库连接池。<strong>创建线程变成了从线程池获得空闲线程，关闭线程变成了向池子归还线程</strong>。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190205163029.png" alt></p><h2 id="2-JDK-对线程池的支持"><a href="#2-JDK-对线程池的支持" class="headerlink" title="2. JDK 对线程池的支持"></a>2. JDK 对线程池的支持</h2><p>为了更好的控制多线程，JDK 有一套 Executor 框架，帮助开发人员有效进行线程控制，其本质就是一个线程池。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190205163226.png" alt></p><p>这些成员都在 java.util.concurrent 包中，是并发包的核心类。其中 ThreadPoolExecutor 表示一个线程池，Executors 类则扮演线程池工厂的角色，通过它获得一个拥有特定功能的线程池，ThreadPoolExecutor 类实现了 Executor 接口，因此通过它，任何 Runnable 对象都可以被 ThreadPoolExecutor 线程池调度。</p><p>Executor 框架提供了各种类型的线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor Service <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> <span class="comment">// 返回固定线程数量的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> <span class="comment">// 返回只有一个线程的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadpool</span><span class="params">()</span> <span class="comment">// 返回一个根据实际情况调整线程数量的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadscheduledExecutor</span><span class="params">()</span> <span class="comment">// ScheduledExecutorService 接口在 ExecutorService 接口上扩展了给定时间执行某任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolsize)</span> <span class="comment">// 和上面的区别在于线程池数量可以指定</span></span></span><br></pre></td></tr></table></figure><p>下面是一个简单的例子，创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 固定大小的线程池</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(System.currentTimeMillis() + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">    ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      es.submit(task); <span class="comment">// 提交任务</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我们一直有提到计划任务，它返回一个 ScheduledExecutorService 对象，它可以根据时间对线程进行调度，具体方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit); <span class="comment">// 在给定的时间，对任务进行一次调度</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay (Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit);</span><br></pre></td></tr></table></figure><p>要知道一点，ScheduledExecutorService 并不一定会立即安排执行任务，它其实是一个计划任务的作用，<strong>会在指定时间，进行调度</strong>。</p><p>关于 <code>scheduleAtFixedTime()</code> 和 <code>scheduleWithFixedDelay()</code> 的区别如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190205225937.png" alt></p><p><strong>对于 rate 而言，任务的频率是一定的，上一次任务开始到下一次任务开始，经过了一个周期时间；对于 delay 而言，上一次任务结束，经过 delay 时间后，再开始下一次的任务</strong>。</p><p>下面是一个关于 <code>scheduleAtFixedRate()</code> 方法的调用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorServiceDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// scheduleAtFixedRate 方法的例子</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 如果前面的任务没有完成，则调度不会启动</span></span><br><span class="line">    ses.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          System.out.println(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任务周期是 2S ，任务的实际执行是 1S ，两秒调用一次。</p><blockquote><p><strong>如果任务执行的时间超过周期，那么周期被拉长到任务执行的长度</strong>。</p></blockquote><p>任务如果中断，那么不会永久执行！要好好做异常处理。</p><h2 id="3-核心线程池的实现"><a href="#3-核心线程池的实现" class="headerlink" title="3. 核心线程池的实现"></a>3. 核心线程池的实现</h2><p>那么对于核心的几个线程池，使用了 <code>newFixedThreadPool()</code> 方法，<code>newSingleThreadExecutor()</code> 方法还有 <code>newCachedThreadPool()</code> 方法，虽然看起来创建的线程有着完全不同的特点，<strong>但是内部均使用 <code>ThreadPoolExecutor</code> 实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads</span><br><span class="line">                          OL, TimeUnit.MILLISECONDS</span><br><span class="line">                          <span class="keyword">new</span> LinkedBlockingQueue &lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutor Service</span><br><span class="line">      (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                          OL, TimeUnit.MILLISECONDS,</span><br><span class="line">                          <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAXVALUE,</span><br><span class="line">                          <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看 ThreadPoolExecutor 类的封装吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span> <span class="params">(<span class="keyword">int</span> corePoolsize, // 线程池中线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> maximumPoolSize, // 线程池中最大的线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> keepAliveTime, // 当超过 corePoolSize 时，多余线程的存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                        TimeUnit unit, // keepAliveTime 的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue, // 被提交但仍未执行的任务</span></span></span><br><span class="line"><span class="function"><span class="params">                        ThreadFactory threadFactory, // 线程工厂，用于创建线程</span></span></span><br><span class="line"><span class="function"><span class="params">                        RejectedExecutionHandler handler // 拒绝策略)</span></span></span><br></pre></td></tr></table></figure><p>其中值得注意的 workQueue ，是一个 BlockingQueue 接口的对象，仅仅用于存放 Runnable 对象，在 ThreadPoolExecutor 的构造函数中有以下几种 BlockingQueue ：</p><ul><li><strong>直接提交队列</strong>：该功能由 SynchronousQueue 对象提供，这是一个特殊的 BlockingQueue 。它没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除都要等待一个插入操作。</li></ul><blockquote><p>任务提交到 SynchronousQueue 不会被真实保存，而是将新任务提交给线程执行，如果没有空闲进程，则尝试创建新的进程，<strong>如果进行数量已经最大，则执行拒绝策略</strong>。因此使用 SynchronousQueue 队列，通常要设置 maximumPoolSize 值。</p></blockquote><ul><li><strong>有界任务队列</strong>：通过 ArrayBlockingQueue 实现，有新任务时，如果任务数量小于 corePoolSize ，则优先创建新的线程，若大于 corePoolSize ，则将任务加入等待队列，若队列已满，则在总数不大于 maximumPoolSize 的情况下，创建新的线程执行任务，若大于 maximumPoolSize ，则执行拒绝策略。</li></ul><blockquote><p>有界队列在队列装满时，才可能将线程数提升到 corePoolSize 以上，除非系统繁忙，否则将确保线程数维持在 corePoolSize 。</p></blockquote><ul><li><strong>无界任务队列</strong>：无界任务队列通过 LinkedBlockingQueue 类实现，当有新的任务到来，系统线程数小于 corePoolSize 时，会生成新的线程执行任务，但达到 corePoolSize 后，不会继续增加了。若还有任务，而没有空闲线程，则进入队列等待，直到耗尽系统内存。</li><li><strong>优先任务队列</strong>：通过 PriorityBlockingQueue 实现，它是特殊的无界队列，之前的有界和无界队列都是按照先进先出算法处理任务的，而 PriorityBlockingQueue 则可以通过任务自身的优先级顺序先后执行（确保高优先级任务先执行）。</li></ul><p>使用 <code>newFixedThreadPool()</code> 方法将返回一个 corePoolSize 和 maximumPoolSize 大小一样的使用<strong>无界任务队列</strong>的线程池。使用的是 LinkedBlockingQueue 任务队列。使用这个任务队列存放无法立即执行的任务。</p><p>使用 <code>newCachedThreadPool()</code> 方法将返回 corePoolSize 为 0 ，maximumPoolSize 无穷大的线程池，没有任务时，线程池中没有现成，当任务被提交，线程池将使用空闲的线程执行任务，若无空闲线程，则将任务加入 SynchronounsQueue 队列，直接提交队列，它迫使线程池增加新的线程执行任务，当任务完毕，由于 corePoolSize 为 0 ，因此空闲线程会在指定时间内被回收。</p><p>下面是 ThreadPoolExecutor 线程池的核心调度逻辑：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190206233820.png" alt></p><h2 id="4-拒绝策略"><a href="#4-拒绝策略" class="headerlink" title="4. 拒绝策略"></a>4. 拒绝策略</h2><p>JDK 内置如下拒绝策略：</p><ul><li>AbortPolicy 策略：该策略会直接抛出异常，阻止系统正常工作。</li><li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li><li>DiscardOldestPolicy 策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li>DiscardPolicy 策略：该策略默默地丢弃无法处理的任务，不予仼何处理。如果允许任务丢失，我觉得这可能是最好的一种方案了吧!</li></ul><p>这些策略都实现了 RejectedExecutionHandler 接口，我们可以自己扩展这个接口，该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>; <span class="comment">// r 是请求执行的任务，executor 是当前的线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码执行需要 100 毫秒，因此有大量任务被直接丢弃：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectThreadPoolDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(System.currentTimeMillis() + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">    ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">10</span>), <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        System.out.println(r.toString() + <span class="string">" is discard"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; ++i) &#123;</span><br><span class="line">      es.submit(task);</span><br><span class="line">      Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-自定义线程创建"><a href="#5-自定义线程创建" class="headerlink" title="5. 自定义线程创建"></a>5. 自定义线程创建</h2><p>我们开始思考一个问题：线程池里的线程是哪里来的？最开始的时候，线程通过 ThreadFactory 创建。ThreadFactory 是一个接口，它只有一个方法，用来创建线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br></pre></td></tr></table></figure><p>下面的案例使用自定义的 ThreadFactory ，一方面记录了线程的创建，另一方面将所有线程设置为守护线程，这样主线程退出的时候，会强制销毁线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 自定义线程创建</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(System.currentTimeMillis() + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">    ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"create "</span> + t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-扩展线程池"><a href="#6-扩展线程池" class="headerlink" title="6. 扩展线程池"></a>6. 扩展线程池</h2><p>虽然线程池已经有了，但是我们需要对它扩展，比如任务开始、结束的时间，或者其他一些功能。ThreadPoolExecutor 是一个可以扩展的线程池，有 <code>beforeExecute()</code> 、 <code>afterExecute()</code> 、 <code>terminated()</code> 三个接口对线程池进行控制。</p><p>在 <code>ThreadPoolExecutor.Worker.runTask()</code> 方法内部有这样的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">beforeExecute(thread, task); <span class="comment">// 运行前</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  task.run(); <span class="comment">// 运行任务</span></span><br><span class="line">  ran = <span class="keyword">true</span>;</span><br><span class="line">  afterExecute(task, <span class="keyword">null</span>); <span class="comment">// 任务执行后</span></span><br><span class="line">  ++completedTasks;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ran) afterExecute(task, ex); <span class="comment">// 运行结束</span></span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 Worker 是 ThreadPoolExecutor 的内部类，实现了 Runnable 接口。ThreadPoolExecutor 线程池中的线程正是 Worker 实例。<code>Worker.runTask()</code> 方法会被线程池以多线程模式异步调用，就是说这个方法会同时被多个线程访问，因此这里的 <code>beforeExecute()</code> 和 <code>afterExecute()</code> 接口也将同时被多线程访问。</p><p>默认下，这两个方法是空的，我们可以对其扩展，对线程池运行状态跟踪，输出有用的调试信息，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtThreadPool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 扩展线程池</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"正在执行:Thread ID:"</span> + Thread.currentThread().getId() + <span class="string">", Task name = "</span> + name);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;()) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备执行："</span> + ((MyTask) r).name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行完成："</span> + ((MyTask) r).name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      MyTask task = <span class="keyword">new</span> MyTask(<span class="string">"Task-"</span> + i);</span><br><span class="line">      es.execute(task);</span><br><span class="line">      Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    es.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有意思的是这里使用的是 <code>execute()</code> 而不是 <code>submit()</code> 。</p><ul><li><code>execute(Runnable x)</code> 没有返回值。可以执行任务，但无法判断任务是否成功完成。（异步执行）</li><li><code>submit(Runnable task)</code> 返回一个 Future 。通过 get 等待直到获取到检索结果为止。（同步执行）</li></ul><h2 id="7-优化线程池线程的数量"><a href="#7-优化线程池线程的数量" class="headerlink" title="7. 优化线程池线程的数量"></a>7. 优化线程池线程的数量</h2><p>在 《Java Concurrency in Practice》 选中有一个估算线程池带下的公式：</p><script type="math/tex; mode=display">Ncpu = CPU 的数量\\Ucpu = 目标的使用率，0 \leq Ucpu \leq 1\\W/C = 等待时间与计算时间的比率</script><p>最优的池的大小：</p><script type="math/tex; mode=display">Nthreads = Ncpu * Ucpu * (1 + W/C)</script><p>在 Java 中，我么可以通过如下方法获取可用 CPU 数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure><h2 id="8-在线程池中寻找堆栈"><a href="#8-在线程池中寻找堆栈" class="headerlink" title="8. 在线程池中寻找堆栈"></a>8. 在线程池中寻找堆栈</h2><p>计算两个数的商：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DivTask</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> re = a / b;</span><br><span class="line">    System.out.println(re);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor pools = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      pools.submit(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码只有4个输出，当除数 i 为0，结果没有计算，一个简单的方法是放弃 <code>submit()</code> ，使用 <code>execute()</code> 。</p><p>这里我们可以得到一些错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "pool-1-thread-1" java.lang.ArithmeticException: / by zero</span><br><span class="line">  at threadPool.DivTask.run(DivTask.java:19)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>我们还想要一个重要信息，就是任务在哪里提交的？与其以后加班，不如扩展 ThreadPoolExecutor 线程池，让它在调度任务之前，先保存一下提交任务线程的堆栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.execute(wrap(command, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">"Client stack trace"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task, <span class="keyword">final</span> Exception clientStack, String clientThreadName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          clientStack.printStackTrace(); <span class="comment">// 这里的参数含义是保存着提交任务的线程的堆栈信息</span></span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor pools = <span class="keyword">new</span> TraceThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    <span class="comment">// 错误堆栈中可以看到哪里提交的任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      pools.execute(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在代码报错还将显示以下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Exception: Client stack trace</span><br><span class="line">  at threadPool.TraceThreadPoolExecutor.clientTrace(TraceThreadPoolExecutor.java:22)</span><br><span class="line">  at threadPool.TraceThreadPoolExecutor.execute(TraceThreadPoolExecutor.java:13)</span><br><span class="line">  at threadPool.TraceThreadPoolExecutor.main(TraceThreadPoolExecutor.java:43)</span><br></pre></td></tr></table></figure><p>我们现在找到了任务提交的地方。</p><h2 id="9-Fork-Join-框架"><a href="#9-Fork-Join-框架" class="headerlink" title="9. Fork/Join 框架"></a>9. Fork/Join 框架</h2><p>分而治之是非常有效处理大量数据的方法，著名的 MapReduce 也是采用了分而治之的思想，在 Linux 平台，函数 <code>fork()</code> 用来创建子进程，使得系统进程可以多一个执行分支，在 Java 中类似，而 <code>join()</code> 的意思是等待，使用了 <code>fork()</code> 以后多了一个执行分支，所以需要等待。</p><p>在 JDK 中，有一个 ForkJoinPool 线程池，对于 <code>fork()</code> 方法并不急着开启的，而是交给 ForkJoinPool 线程池进行处理。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190208234838.png" alt></p><p>大多数情况下一个物理线程需要处理多个逻辑任务，每个线程需要一个<strong>任务队列</strong>，可能存在：线程 A 已经将任务完成，而 B 还有任务要处理，线程 A 将帮助线程 B ，达到平衡，这是一种互助，如下图所示。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190208235327.png" alt></p><blockquote><p>当线程帮助别人的时候，总是从底部开始拿数据，这样避免了数据的竞争。</p></blockquote><p>下面是一个 ForkJoinPool 的重要接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span></span><br></pre></td></tr></table></figure><p>我们可以向 ForkJoinPool 线程池提交一个 ForkJoinTask 任务，这样的任务就是支持 <code>fork()</code> 和 <code>join()</code> 的任务，而它有两个重要的子类，RecursiveAction 和 RecursiveTask ，他们分别表示没有返回值的任务和可以携带返回值的任务。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190208235648.png" alt></p><p>下面是一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// fork/join demo</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start = start;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> canCompute = (end - start) &lt; THRESHOLD;</span><br><span class="line">    <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 分任务咯，100个</span></span><br><span class="line">      <span class="keyword">long</span> step = (start + end) / <span class="number">100</span>;</span><br><span class="line">      ArrayList&lt;CountTask&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">long</span> pos = start;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastOne = pos + step;</span><br><span class="line">        <span class="keyword">if</span> (lastOne &gt; end) lastOne = end;</span><br><span class="line">        CountTask subTask = <span class="keyword">new</span> CountTask(pos, lastOne);</span><br><span class="line">        pos += step + <span class="number">1</span>;</span><br><span class="line">        subTasks.add(subTask);</span><br><span class="line">        subTask.fork();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (CountTask t : subTasks) &#123;</span><br><span class="line">        sum += t.join();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    CountTask task = <span class="keyword">new</span> CountTask(<span class="number">0</span>, <span class="number">200000L</span>);</span><br><span class="line">    ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">long</span> res = result.get();</span><br><span class="line">      System.out.println(<span class="string">"sum + "</span> + res);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoin 线程池使用一个无锁的栈来管理空闲的线程，如果工作线程暂时取不到可用的任务，则可能挂起，挂起线程被压入由线程池维护的栈中，待将来有任务时，再唤醒这些线程。</p><h1 id="三、JDK-的并发容器"><a href="#三、JDK-的并发容器" class="headerlink" title="三、JDK 的并发容器"></a>三、JDK 的并发容器</h1><h2 id="1-并发集合"><a href="#1-并发集合" class="headerlink" title="1. 并发集合"></a>1. 并发集合</h2><p>JDK 提供的这些容器大部分在 java.util.concurrent 包中，这些容器主要如下：</p><ul><li>ConcurrentHashMap：这是一个高效的并发 HashMap 。你可以理解为一个线程安全的 HashMap 。</li><li>CopyOnWriteArrayList：这是一个 List ，从名字看就是和 ArrayList 是一族的。在<strong>读多写少</strong>的场合，这个 List 的性能非常好，远远好于 Vector 。</li><li>ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看做一个线程安全的 Linkedlist 。</li><li>BlockingQueue：这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li><li>ConcurrentSkipListMap：跳表的实现。这是一个 Map ，使用跳表的数据结构进行快速查找。</li></ul><p>此外，Vector 也是线程安全，但是性能和上述专用工具没得比，另外 Collections 工具类可以帮助我们将任意集合包装成线程安全的集合。</p><h2 id="2-线程安全的-HashMap"><a href="#2-线程安全的-HashMap" class="headerlink" title="2. 线程安全的 HashMap"></a>2. 线程安全的 HashMap</h2><p>做到线程安全的 HashMap ，一种可行的是 <code>Colletions.synchronizedMap()</code> 方法包装我们的 HashMap ，下面的 HashMap 就是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure><blockquote><p><code>Collections.synchronizedMap()</code> 会生成一个名为 SynchronizedMap 的 Map 。它使用了委托，将自己所有 Map 相关的功能交给传入的 HashMap 实现，而自己则负责保证线程安全。</p></blockquote><p>首先，我们用 SynchronizedMap 包装一个 Map ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">197</span>...L;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; m; <span class="comment">// Backing Map</span></span><br><span class="line">  <span class="keyword">final</span> Object mutex; <span class="comment">// Object on which to synchronize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们通过 mutex 实现对这个 m 的互斥操作。比如，对于 <code>Map.get()</code> 方法，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">    <span class="keyword">return</span> m.get(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他相关的 Map 操作都会使用这个 mutex 进行同步，从而实现线程安全。</p><p>如果并发级别不高，一般够用，但是在高并发下我们需要新的解决方案，一个更加专业的并发 HashMap 是 ConcurrentHashMap ，它专门为并发进行性能优化。</p><h2 id="3-有关-List-的线程安全"><a href="#3-有关-List-的线程安全" class="headerlink" title="3. 有关 List 的线程安全"></a>3. 有关 List 的线程安全</h2><p>在 Java 中 ArrayList 和 Vector 都是使用数组作为实现，前者非线程安全，后者为线程安全，我们也可以使用 Collections 包来完成 ArrayList 的线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br></pre></td></tr></table></figure><h2 id="4-高效读写队列-ConcurrentLinkedQueue"><a href="#4-高效读写队列-ConcurrentLinkedQueue" class="headerlink" title="4. 高效读写队列 ConcurrentLinkedQueue"></a>4. 高效读写队列 ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 应该算在高并发环境中性能最好的队列。</p><p>首先在 ConcurrentLinkedQueue 中，定义了节点 Node ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> E item;</span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 CAS 操作对 Node 进行一些维护：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123; <span class="comment">// 第一个参数是期望值，第二个参数是设置目标值</span></span><br><span class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它内部有两个字段，head 和 tail ，分别代表链表头和链表尾，我们可以通过 head 以及 <code>succ()</code> 方法来遍历，而 tail 表示队列的末尾。</p><p>一般，我们期望 tail 总是末尾，但是实际上更新不是及时的，存在拖延现象，如下所示：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190210110501.png" alt></p><blockquote><p>tail 的更新会延后，每次跳跃两个元素。</p></blockquote><p>我们看一下加入节点的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">    Node&lt;E&gt; q = p.next;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// p is last node</span></span><br><span class="line">      <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">        <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">        <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">        <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">        <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">          casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">      <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">      <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">      <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">      <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">      p = (t != (t = tail)) ? t : head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">      p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始情况下，由于队列为空，所以 p.next 为 null ，然后将 p 的 next 节点赋值 newNode ，也就是将新的元素加入到队列中，此时 p == t 是成立的，因此不会更新结尾 tail ，因此增加一个元素后，tail 并不会更新。</p><p>当我们试图增加第二个元素时，由于 t 在 head 的位置，因此 p.next 指向第一个元素，现在 q != null ，q 不是最后的节点。于是代码开始寻找最后一个节点。此时， p 指向第一个元素，而它的 next 是 null ，p 更新自己的 next ，此时 p != t ，于是更新 t 所在的位置，到链表的最后。</p><p>那么什么时候会出现 p == q 呢？这是因为遇到了哨兵节点，就是 next 指向自己的节点。主要表示要删除的节点和空节点。出现了的话，则使用新的 tail 作为结尾，避免重新查找 tail 的开销。</p><p>在单线程下，这就话不容易理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = (t != (t = tail)) ? t : head;</span><br></pre></td></tr></table></figure><blockquote><p>!= 不是原子操作，首先是 t 的值，然后执行 t = tail ，取得新的 t 的值，然后比较是否相等，单线程不会出现 t != t ，但是在并发下，右边可能修改了，如果修改了，就现在进行修改，如果没有修改，重新查找结尾。</p></blockquote><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190210170913.png" alt></p><p>哨兵是怎么产生的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentLinkedQueue&lt;String&gt; q = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;();</span><br><span class="line">q.add(<span class="string">"1"</span>);</span><br><span class="line">q.poll();</span><br></pre></td></tr></table></figure><p>下面是 <code>poll()</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  restartFromHead:</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">      E item = p.item;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">        <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">        <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">          updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        updateHead(h, p);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">        <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于现在队列中只有一个元素，所以 tail 没有更新，而是指向和 head 相同的位置，此时 head 本身的 item 是空的，next 是第一个元素，首先我们代码到 p = q 的位置，p 现在指向了第一个元素，第二次循环，p 的 item 被设置成了 null ，也就是弹出元素，被删除，此时 p 和 h 当然不等了，故执行了 <code>updateHead()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">    h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 p 设置为链表的表头，原来的 head 被设置成了哨兵，通过 <code>lazySetNext()</code> 实现。现在一个哨兵节点被创建了，原来的 head 和 tail 实际上就是一个元素，如果再次执行 <code>offer()</code> 将会遇到这个 tail 。</p><blockquote><p>原来头节点没用了，next指向本身，变成哨兵节点。</p></blockquote><h2 id="5-不变模式下的-CopyOnWriteArrayList"><a href="#5-不变模式下的-CopyOnWriteArrayList" class="headerlink" title="5. 不变模式下的 CopyOnWriteArrayList"></a>5. 不变模式下的 CopyOnWriteArrayList</h2><p>有些场景下，读远远大于写，我们希望读尽可能快，写慢一点点没关系。</p><p>我们应该允许多个线程访问，但是写应该受到阻碍。所谓 CopyOnWrite 就是在写的时候，进行一次自我复制，如果需要修改，我们并不修改<strong>原有的内容</strong>，写完之后再替换，不影响读操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和读取相比，写入就比较麻烦了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">    newElements[len] = e;</span><br><span class="line">    setArray(newElements);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里为什么需要使用 <code>final ReentrantLock lock = this.lock;</code> 这句话，一部分重要一部分不重要。</p><p>重要：</p><ul><li>this.lock 是类的成员变量，一般都是存到堆上，访问堆上的变量会涉及内存同步的操作(这个建议通过编译后的 bytecode 进行观察)，而将其 copy 到栈上，然后访问就不存在这个问题了。</li><li>在访问堆上的 this.lock 时，对于多个 CPU ，可能会存在 cache 命中的问题，这样必然会导致内存重新 load ，而 copy 到栈上，则直接是线程相关的，就不存在这个问题了。</li></ul><p>不重要：</p><ul><li>这个 final 对于编译而言是可有可无的，即便将其final修饰符去掉，效果也一样。</li><li>Jdk1.6 及以前是没有这句话的，对结果是没有影响的。</li></ul></blockquote><p>首先使用锁，生成一个新的数组，然后将元素加入，接着新数组替换老数组，不影响读，修改完成，读就察觉了，因为 array 是 volatile 类型的。</p><h2 id="6-数据共享通道"><a href="#6-数据共享通道" class="headerlink" title="6. 数据共享通道"></a>6. 数据共享通道</h2><p>我们说过 ConcurrentLinkedQueue 可以作为高性能的队列，但多线程的开发还有一个问题，如何在多个线程之间进行数据共享呢？</p><blockquote><p>一般来说，我们总是希望系统是松耦合的。</p></blockquote><p>如果我们进行重构或者升级，可以不修改线程 A ，而直接把线程 B 升级成线程 C ，保证系统的平滑过渡，其中升级的意见箱使用 BlockingQueue 来实现。</p><p>与之前的 ConcurrentLinkedQueue 和 CopyOnWriteArrayList 不同，BlockingQueue 是一个接口，而不是一个实现，主要实现有下面的内容：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190213233354.png" alt></p><p>其中 ArrayBlockingQueue 是基于数组实现的，而 LinkedBlockingQueue 基于链表。正因为如此 ArrayBlockingQueue 更适合做有界队列，因为队列中可以容纳的最大元素在创建的时候指定；而 LinkedBlockingQueue 适合做无界队列，内部元素可以动态增加。</p><p>BlockingQueue 之所以适合作为数据共享的通道，关键在于 Blocking 上，它有阻塞的意思，当服务线程处理完队列中信息后，如何知道下一条信息何时到来？</p><p>它会让服务线程在队列为空的时候，进行等待，当有信息进入队列后，自动将线程唤醒。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190213235359.png" alt></p><p>ArrayBlockingQueue 内部有一个对象数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] items;</span><br></pre></td></tr></table></figure><p>向队列中压入元素使用 <code>offer()</code> 方法和 <code>put()</code> 方法，对于 offer ，如果队列满了，返回 false ，如果没有满，则正常入队列。对于 put ，是压入队列的末尾，如果队列满了，会一直等待，直到队列中有空闲的位置。</p><p>从队列中弹出元素可以使用 <code>poll()</code> 方法和 <code>take()</code> 方法，他们都是从头部获取一个元素，不同在于，队列如果为空 poll 方法会直接返回 null ，而 take 会等待，直到队列内有元素。</p><p>为了做好等待和通知两件事，在 ArrayBlockingQueue 内部定义了以下一些字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>当执行 <code>take()</code> 操作时，如果队列为空，则让当前线程等待在 notEmpty 上，新元素加入，则进行一次 notEmpty 上的通知。</p><p>下面是 take 的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">      notEmpty.await();</span><br><span class="line">    <span class="keyword">return</span> extract();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码会循环进行等待，当有新元素进入，线程会得到通知，下面是加入元素的代码。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">  items[putIndex] = x;</span><br><span class="line">  putIndex = inc(putIndex);</span><br><span class="line">  ++count;</span><br><span class="line">  notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当新元素进入队列，需要通知在 notEmpty 上的线程，让他们继续工作。</p><p>同理，对于 put 操作，当队列满的时候，需要让压入线程等待：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="keyword">final</span> Reentrantlock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == items.length)</span><br><span class="line">      notFull.await();</span><br><span class="line">    insert(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有元素挪走，出现了空位，自然也需要通知入队的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">extract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  E x = items[takeIndex];</span><br><span class="line">  items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">  takeIndex = inc(takeIndex);</span><br><span class="line">  --count;</span><br><span class="line">  notFull.signal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在生产者消费者中还会有 BlockingQueue 的身影。</p></blockquote><h2 id="7-跳表"><a href="#7-跳表" class="headerlink" title="7. 跳表"></a>7. 跳表</h2><p>跳表有点类似平衡树，平衡树的插入和删除往往可能导致平衡树进行一次全局的调整。而跳表的插入和删除只需要对整个数据结构的局部进行操作即可。在高并发下，我们需要一个全局锁来保证整个平衡树的线程安全；对于跳表，我们只需要部分锁即可。</p><p>查询而言，跳表的复杂度也是 O(log n) ，JDK 使用跳表来实现一个 Map 。</p><p>跳表的另外一个特点是随机算法，它的本质是维护了多个链表，而且链表是分层的：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190214004331.png" alt></p><p>每上面一层链表都是下面的子集，一个元素插入哪些层是完全随机的。查找时，我们从顶层链表开始找，一旦发现查找元素大于当前链表的取值，跳到下一层继续。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190214004910.png" alt></p><p>到第二层，我们找到 8 ，但是 8 比 7 大，不行，继续进入下一层，这样查找，比从元素 1 开始逐个查找要快得多。</p><blockquote><p>和哈希算法不同在于：哈希不会保存元素的顺序，而跳表的元素是排序的。</p></blockquote><p>实现这一数据结构的类是 ConcurrentSkipListMap 。下面是一个跳表的简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map=<span class="keyword">new</span> ConcurrentskipListMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">  map. put(, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry:map.entrySet()) &#123;</span><br><span class="line">  System.out.println(entry.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 HashMap 不同，跳表的输出是有序的。</p><p>跳表的内部实现有几个关键的数据结构组成。首先是 Node ，一个 Node 就是一个节点，里面含有两个重要的元素 key 和 value 。每个 Node 还会指向下一个 Node ，因此还有一个元素 next 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="keyword">volatile</span> Object value;</span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 Node 的所有操作，使用的是 CAS 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123; <span class="comment">// 设置 value</span></span><br><span class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123; <span class="comment">// 设置 next</span></span><br><span class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个数据结构是 Index ，表示索引，内部包装了 Node ，同时增加了向下的引用和向右的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">  <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">  <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个跳表就是根据 Index 进行全网的组织的。</p><p>此外，对于每一层的表头，还需要记录当前在哪一层，为此，还需要一个称为 HeadIndex 的数据结构，表示链表头部的第一个 Index ，它集成自 Index 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>, <span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>, <span class="title">v</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">  HeadIndex(Node&lt;K, V&gt; node, Index&lt;K, V&gt; down, Index&lt;K, v&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">    <span class="keyword">super</span>(node, down, right);</span><br><span class="line">    <span class="keyword">this</span>.level = level;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于跳表的所有操作，就是组织好这些 Index 之间的连接关系。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 高并发程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全与锁优化</title>
      <link href="/technology/2018-12-29-jvm-understanding-chapter13/"/>
      <url>/technology/2018-12-29-jvm-understanding-chapter13/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h2><p>定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是<strong>线程安全</strong>的。</p><h3 id="1-1-Java-语言中的线程安全"><a href="#1-1-Java-语言中的线程安全" class="headerlink" title="1.1 Java 语言中的线程安全"></a>1.1 Java 语言中的线程安全</h3><p>我们￼可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><ul><li><strong>不可变</strong></li></ul><p>在 Java 语言中（特指JDK 1.5以后，即 Java 内存模型被修正之后的Java语言），不可变（Immutable）的对象一定是线程安全的，<strong>无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施</strong>，final 关键字带来的可见性时曾经提到过这一点，<strong>只要一个不可变的对象被正确地构建出来（没有发生 this 引用逃逸的情况），那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态</strong>。“不可变”带来的安全性是最简单和最纯粹的。</p><p>如果是一个基本数据类型，那么只需简单的 final 关键字就可以保证<strong>不可变</strong>，如果是对象，需要保证对象的行为不会对其状态产生影响。</p><blockquote><p>比如 String 类，它的所有方法都是产生一个新的值，而不是改变值。</p></blockquote><p>保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer JDK</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java API 中符合不可变要求的类型，除了上面提到的 String 之外，常用的还有枚举类型，以及 java.lang.Number 的部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型；但同为 Number 的子类型的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。</p><ul><li><strong>绝对线程安全</strong></li></ul><p>绝对线程安全满足我们开头对于<strong>线程安全的定义</strong>，这个定义非常严格。</p><p>在 Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。我们可以通过 Java API 中一个不是“绝对线程安全”的线程安全类来看看这里的“绝对”是什么意思。<strong>Vector 就不是说永远不需要同步手段了</strong>。</p><p>因为 Vetcot 中的方法都是以当前实例为锁对象，即同时只会有一个方法被执行，但是由于外部条件，预测到的都是 Vector 正常执行的情况，外部会出错，Vector 内部还是没有问题的，因此，假设我们在外部调用 size() 方法，一个线程删除的同时另外一个线程打印，就可能出错，<strong>因为现在 size() 可能变了，我们需要加上额外的锁在外部进行限制</strong>。</p><ul><li><strong>相对线程安全</strong></li></ul><p>这是我们通常意义上的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。<strong>我们的 Vector 的例子就是相对安全的典型</strong>。</p><p>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector 、 HashTable 、 Collections 的 synchronizedCollection() 方法包装的集合等。</p><ul><li><strong>线程兼容</strong></li></ul><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，<strong>我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况</strong>。</p><p>Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类ArrayList和 HashMap 等。</p><ul><li><strong>线程对立</strong></li></ul><p><strong>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码</strong>。</p><p>一个线程对立的例子是 Thread 类的 suspend() 和 resume() 方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，<strong>无论调用时是否进行了同步，目标线程都是存在死锁风险的</strong>，如果 suspend() 中断的线程就是即将要执行 resume() 的那个线程，<strong>那就肯定要产生死锁了</strong>。也正是由于这个原因， suspend() 和 resume() 方法已经被 JDK 声明废弃（@Deprecated）了。常见的线程对立的操作还有 System. setIn() 、 Sytem.setOut() 和 System.runFinalizersOnExit() 等。</p><blockquote><p>如果使用 suspend 的目标线程对一个重要的系统资源持有锁，那么没任何线程可以使用这个资源直到要 suspend 的目标线程被 resume ；如果一个线程在 resume 目标线程之前尝试持有这个重要的系统资源锁再去 resume 目标线程，这两条线程就相互死锁了。</p></blockquote><h3 id="1-2-线程安全的实现方法"><a href="#1-2-线程安全的实现方法" class="headerlink" title="1.2 线程安全的实现方法"></a>1.2 线程安全的实现方法</h3><p>这里我们更加侧重于<strong>虚拟机如何实现同步和锁</strong>，然后我们思考如何<strong>代码实现线程安全</strong>就不是一个困难的事情。</p><ul><li><strong>互斥同步</strong></li></ul><p>互斥同步（Mutual Exclusion &amp; Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这4个字里面，<strong>互斥是因，同步是果；互斥是方法，同步是目的</strong>。</p><p> synchronized 指定了 renfrence 那锁定的就是这个 reference ，实例方法没有指定 reference 锁定的就是该实例对象，类方法没有指定 reference 就是该 class 对象。</p><p>在虚拟机规范对 monitorenter 和 monitorexit 的行为描述中，有两点是需要特别注意的:</p><ol><li>首先， synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</li><li>其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</li></ol><blockquote><p>Java 的线程是映射到操作系统的原生线程上的，因此，synchronized 关键字是一个重量级的操作，它会设计用户态转换成内核态。</p></blockquote><p><strong>ReentrantLock 实现同步</strong><br>除了 synchronized 之外，我们还可以使用 java.util.concurrent（下文称 J.U.C ）包中的重入锁（ReentrantLock）来实现同步，在基本用法上， ReentrantLock 与 synchronized 很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为 API 层面的互斥锁（ lock() 和 unlock() 方法配合 try/finally 语句块来完成），另一个表现为原生语法层面的互斥锁。不过，相比 synchronized ， ReentrantLock 增加了一些高级功能，主要有以下3项：<strong>等待可中断</strong>、<strong>可实现公平锁</strong>，以及<strong>锁可以绑定多个条件</strong>。</p><ol><li><strong>等待可中断</strong>：等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li><li><strong>公平锁</strong>：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。 synchronized 中的锁是非公平的， ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li><li><strong>锁绑定多个条件</strong>：锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。</li></ol><p>我们用下面两个图来比较 JUC 包和 synchronized 关键字的性能：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190125144109.png" alt></p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190125144139.png" alt></p><blockquote><p>横坐标线程数、纵坐标吞吐量</p></blockquote><p>与其说 ReentrantLock 性能好，还不如说 synchronized 还有非常大的优化余地。后续的技术发展也证明了这一点， Jdk1.6 中加入了很多针对锁的优化措施， Jdk1.6 发布之后，人们就发现 synchronized 与 ReentrantLock 的性能基本上是完全持平了。因此，如果读者的程序是使用 Jdk1.6 或以上部署的话，性能因素就不再是选择 ReentrantLock 的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized ，<strong>所以还是提倡在 synchronized 能实现需求的情况下，优先考虑使用 synchronized 来进行同步</strong>。</p><ul><li><strong>非阻塞同步</strong></li></ul><p><strong>互斥同步</strong>最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步<strong>也称为阻塞同步</strong>（Blocking Synchronization）。阻塞同步是一种悲观的并发策略，总是认为只要不去做正确的同步措施，那么就会出现问题。</p><p>随着硬件指令集的发展，我们有了另外一个选择：<strong>基于冲突检测的乐观并发策略</strong>。先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施。</p><blockquote><p>随着硬件指令集发展这一点，我们需要<strong>操作</strong>和<strong>冲突检测</strong>这两个步骤具备原子性。</p></blockquote><p>这种<strong>乐观的并发策略</strong>的许多实现都<strong>不需要把线程挂起</strong>，因此这种同步操作<strong>称为非阻塞同步</strong>（Non-Blocking Synchronization）。</p><p><strong>操作</strong>和<strong>冲突检测</strong>这两个步骤如何具备原子性？再用互斥同步就失去意义了，所有我们依靠硬件来完成这一点，硬件保证一个从<strong>语义上看起来需要多次操作的行为只通过一条处理器指令就能完成</strong>，这类指令常用的有：</p><ol><li>测试并设置（Test-and-Set）</li><li>获取并增加（Fetch-and-Increment）</li><li>交换（Swap）</li><li>比较并交换（Compare-and-Swap，下文称CAS）</li><li>加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC）</li></ol><p>CAS 指令需要有3个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。 CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。</p><p>我们来看一下 AtomicInteger 的 incrementAndGet() 方法，它具有原子性，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">￼/＊＊￼</span><br><span class="line">＊ Atomically increment by one the current value.￼</span><br><span class="line">＊ <span class="meta">@return</span> the updated value￼</span><br><span class="line">＊/￼</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;￼</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> current = get();</span><br><span class="line">    <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSet(current, next))￼</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;￼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>incrementAndGet() 方法在一个无限循环中，不断尝试将一个比当前值大1的新值赋给自己。如果失败了，那说明在执行“获取-设置”操作的时候值已经有了修改，于是再次循环进行下一次操作，直到设置成功为止。</p><p>CAS 存在逻辑漏洞，被称为 <strong>ABA</strong> 问题：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然为 A 值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了 B ，后来又被改回为 A ，那 CAS 操作就会误认为它从来没有被改变过。</p><p>JUC 包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证 CAS 的正确性。不过目前来说这个类比较“鸡肋”，<strong>大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效</strong>。</p><ul><li><strong>无同步方案</strong></li></ul><p>如果一个方法，本身就不涉及共享数据，那么它自然无需任何同步措施去保证正确性，有些代码天生线程安全，比如下面两种：</p><ol><li>可重入代码</li></ol><p>Reentrant Code ，或者称之为纯代码 Pure Code 。可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><blockquote><p>相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p></blockquote><p>我们可以通过一个简单的原则来判断代码是否具备可重入性：<strong>如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的</strong>。</p><ol><li>线程本地存储</li></ol><p>Thread Local Storage ，如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>Java 语言中，如果一个变量要被多线程访问，可以使用 volatile 关键字声明它为“易变的”；如果一个变量要被某个线程独享，Java 可以通过 java.lang.ThreadLocal 类来实现线程本地存储的功能。</p><h2 id="2-锁优化"><a href="#2-锁优化" class="headerlink" title="2. 锁优化"></a>2. 锁优化</h2><p>高效并发是从 Jdk1.5 到 Jdk1.6 的一个重要改进，HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p><h3 id="2-1-自旋锁与自适应自旋"><a href="#2-1-自旋锁与自适应自旋" class="headerlink" title="2.1 自旋锁与自适应自旋"></a>2.1 自旋锁与自适应自旋</h3><p>线程互斥同步的问题在于阻塞的实现，挂起和恢复都需要转入内核态，但是锁定可能仅仅是很短的一段时间，非常不值得。</p><p>如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让<strong>后面请求锁的那个线程“稍等一下”</strong>，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>自旋锁在 Jdk1.4.2 中就已经引入，只不过默认是关闭的，可以使用 -XX:+UseSpinning 参数来开启，在 Jdk1.6 中就已经改为默认开启了。</p><p>自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。</p><p>因此，自旋等待的时间必须要有一定的限度，<strong>如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了</strong>。自旋次数的默认值是10次，用户可以使用参数 -XX:PreBlockSpin 来更改。</p><p>在 Jdk1.6 中引入了<strong>自适应</strong>的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><h3 id="2-2-锁消除"><a href="#2-2-锁消除" class="headerlink" title="2.2 锁消除"></a>2.2 锁消除</h3><p>锁消除是指<strong>虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</strong>。</p><p>为什么要存在锁消除？难道我们自己不知道代码有没有加同步锁吗？我们看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也知道，由于 String 是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此 Javac 编译器会对 String 连接做自动优化。在 Jdk1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作，在 Jdk1.5 及以后的版本中，会转化为 StringBuilder 对象的连续 append() 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.sppend(s2);</span><br><span class="line">  sb.append(s3);</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 StringBuffer.append() 方法中都有一个同步块，锁就是 sb 对象。虚拟机观察变量 sb ，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会“逃逸”到 concatString() 方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，<strong>在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了</strong>。</p><h3 id="2-3-锁粗化"><a href="#2-3-锁粗化" class="headerlink" title="2.3 锁粗化"></a>2.3 锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><p>我们上面的代码 append() 方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，<strong>这样只需要加锁一次就可以了</strong>。</p><h3 id="2-4-轻量级锁"><a href="#2-4-轻量级锁" class="headerlink" title="2.4 轻量级锁"></a>2.4 轻量级锁</h3><p>轻量级锁是 Jdk1.6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此<strong>传统的锁机制就称为“重量级”锁</strong>。首先需要强调一点的是，<strong>轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</p><p>我们回忆一下 HotSpot 虚拟机对象头 Mark Word ：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190125231742.png" alt></p><p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word ）。</p><p>然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（Mark Word 的最后2bit）将转变为“00”，即表示此对象处于轻量级锁定状态：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190125232008.png" alt></p><p>如果只线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p><blockquote><p>首先，多个线程运行到同步块以后，会检查锁对象状态值标志是否加锁，如果没有锁就把锁对象的 Mark Word 的信息拷贝到自己线程存起来，然后通过 cas 尝试把对象的 Mark 的值改变成一个指向自己线程的指针，一旦成功其他线程的 cas 就会失败，因为锁对象的 Mark 已经变成一个新的指针了，必须等待线程释放锁，其他线程才能继续获取。</p><p>其他线程通过自旋竞争锁，当自旋次数超过 jvm 预期上限，就会影响性能，所以竞争的线程就会把锁的对象 Mark 指向重锁，然后所有的竞争线程放弃自旋，进入阻塞状态。</p><p>当成功获取锁的线程执行完毕，尝试通过 cas 释放锁时，因为 Mark 已经指向重锁，也会解锁失败，这时线程就会知道锁已经升级为重量级锁， 它不仅要释放当前锁，还要唤醒其他阻塞的线程。</p></blockquote><p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p><h3 id="2-5-偏向锁"><a href="#2-5-偏向锁" class="headerlink" title="2.5 偏向锁"></a>2.5 偏向锁</h3><p>偏向锁也是 Jdk1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，<strong>连 CAS 操作都不做了</strong>。</p><p>假设当前虚拟机启用了偏向锁（启用参数-XX:+UseBiasedLocking，这是 Jdk1.6 的默认值），那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如 Locking 、 Unlocking 及对 Mark Word 的 Update 等）。</p><p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。偏向锁、轻量级锁的状态转化及对象 Mark Word 的关系如图所示。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190125234043.png" alt></p><p>偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数 -XX:-UseBiasedLocking 来禁止偏向锁优化反而可以提升性能。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 深入理解 JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高效并发</title>
      <link href="/technology/2018-12-22-jvm-understanding-chapter5/"/>
      <url>/technology/2018-12-22-jvm-understanding-chapter5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里对应该书的第五部分。</p></blockquote><p>我们不希望处理器在大部分时间里都处于等待其他资源的状态，因此使用一些手段来压榨处理器的运算能力，衡量一个服务性能的好坏，<strong>每秒事务处理数（Transactions Per Second , TPS）是一个最重要的指标</strong>，它代表一秒内服务端平均能响应的请求总数，而 TPS 与程序的并发能力又有非常密切的关系。</p><blockquote><p>CPU 太快，而 IO 太慢，不让 CPU 等待的办法就是让它处理多件事情。</p></blockquote><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：<strong>将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了</strong>。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190120155506.png" alt></p><p>现在，因为缓存的出现，我们遇到了新的问题：<strong>缓存一致性</strong>。在多处理器系统中，每个处理器都有自己的高速缓存，而它们共同享有一个主内存，如上图所示。当多个处理器的任务都涉及同一块主内存区域的时候，<strong>同步到主内存时以谁的数据为准</strong>？我们需要各个处理器访问缓存时都遵循一些协议。</p><p><strong>所谓内存模型，就是在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。</p><p>为了处理器内部的运算单元尽量被充分利用，处理器可能会对代码进行<strong>乱序处理</strong>，JVM 的即时编译器中也有类似的<strong>指令重排序</strong>优化。</p><h2 id="1-Java-内存模型"><a href="#1-Java-内存模型" class="headerlink" title="1. Java 内存模型"></a>1. Java 内存模型</h2><p>就是所谓的 Java Memory Model ，简称 JMM 。用以屏蔽各种硬件和操作系统的内存访问差异，实现 Java 在各个平台下都能一致的内存访问效果。</p><p>我们需要尽可能严谨，保证内存访问不会出现歧义；也要足够宽松，让虚拟机可以有足够的自由空间去利用硬件的各种特性。在 Jdk1.5 发布后，JMM 已经成熟和完善起来了。</p><h3 id="1-1-主内存和工作内存"><a href="#1-1-主内存和工作内存" class="headerlink" title="1.1 主内存和工作内存"></a>1.1 主内存和工作内存</h3><p><strong>JMM 的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存取出变量这样的底层细节。</strong>这里的变量和一般的变量是不同的，它包括了实例字段、静态字段、构成数组的元素，<strong>但不包括局部变量和方法参数</strong>，因为它们是线程私有的，不会存在竞争问题。</p><p>JMM 规定了所有变量都存储在主内存中，同时，每个线程都有自己的工作内存，<strong>工作内存中存放了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量</strong>，不同线程直接无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存完成，下面是线程、主内存、工作内存三者的交互关系。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190120161521.png" alt></p><p>JMM 和 JVM 中的内存划分不是同一个层次的内存划分，两者基本上没有关系，<strong>主内存主要对应于 JVM Heap 中对象实例数据部分，而工作内存对应 JVM 虚拟机栈中的部分</strong>。</p><h3 id="1-2-内存间的交互操作"><a href="#1-2-内存间的交互操作" class="headerlink" title="1.2 内存间的交互操作"></a>1.2 内存间的交互操作</h3><p>JMM 中定义了8种<strong>操作</strong>，虚拟机实现时必须保证下面提及的每一种操作都是原子的，不可再分：</p><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条<strong>线程独占</strong>的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于<strong>锁定状态的变量释放</strong>出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值<strong>从主内存传输到线程的工作内存</strong>中，以便随后的 load 动作使用。</li><li>load（载入）：作用于工作内存的变量，它把 read 操作<strong>从主内存中得到的变量值放入工作内存的变量副本中</strong>。</li><li>use（使用）：作用于工作内存的变量，它把<strong>工作内存中一个变量的值传递给执行引擎</strong>，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个<strong>从执行引擎接收到的值赋给工作内存的变量</strong>，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把<strong>工作内存中一个变量的值传送到主内存</strong>中，以便随后的 write 操作使用。</li><li>￼write（写入）：作用于主内存的变量，它把 store 操作<strong>从工作内存中得到的变量的值放入主内存的变量</strong>中。</li></ul><blockquote><p>lock 和 unlock 在线程中常用，在这里不解释。</p><p>use 和 assign 作用在工作内存，前者把变量给工作引擎；后者把执行引擎的值传给变量。</p><p>read 以后 load ，先读取主内存到工作内存（作用在主内存），再加载到工作内存（作用在工作内存）。</p><p>store 以后 write ，先读取工作内存到主内存（作用在工作内存），再存储到主内存（作用在主内存）。</p></blockquote><p>JMM 只要求了上述两组操作需按顺序执行，并没有保证说是<strong>连续执行</strong>，<strong>这两组操作中间是可以插入其他指令的</strong>。</p><p>在执行上述8种基本操作的时候，必须满足以下<strong>规则</strong>：</p><ul><li>不允许 read 和 load 、 store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它的最近的 assign 操作，即<strong>变量在工作内存中改变了之后必须把该变化同步回主内存</strong>。</li><li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</li><li><strong>一个新的变量只能在主内存中“诞生”</strong>，不允许在工作内存中直接使用一个未被初始化（ load 或 assign ）的变量，换句话说，就是对一个变量实施 use 、 store 操作之前，必须先执行过了 assign 和 load 操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li><li>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li><li>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li><li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store 、 write 操作）。</li></ul><p><strong>这些规则加上 volatile 的特殊规定，已经能完全确定哪些内存访问操作在并发下是安全的</strong>，这里的定义很繁琐，之后有一个<strong>先行发生原则，用以判断一个访问在并发下是否安全</strong>。</p><h3 id="1-3-对于-volatile-型变量的特殊规则"><a href="#1-3-对于-volatile-型变量的特殊规则" class="headerlink" title="1.3 对于 volatile 型变量的特殊规则"></a>1.3 对于 volatile 型变量的特殊规则</h3><p>它是 JVM 提供最轻量级的同步机制，但是它并不容易被正确、完整地理解，以至于许多程序员都习惯不使用它，遇到需要多线程数据竞争的时候一律使用 synchronized 来进行同步，了解 volatile 变量的语义对后面了解多线程操作的其他特性很有意义。</p><blockquote><p>volatile 适用的场景是一写多读，例如比较经典的单例对象，它可以保证所有读取的值都会是最新的，<strong>实现原理是该关键字在读的时候回强制从主内存中读取</strong>。</p></blockquote><p>当一个变量定义为 volatile 之后，它将具备两种特性，<strong>第一是保证此变量对所有线程的可见性</strong>，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</p><p>volatile 变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile 变量也可以存在不一致的情况，<strong>但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题</strong>），但是 <strong>Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的</strong>。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/＊＊￼</span><br><span class="line">＊ <span class="keyword">volatile</span>变量自增运算测试￼</span><br><span class="line">＊￼</span><br><span class="line">＊ <span class="meta">@author</span> zzm￼</span><br><span class="line">＊/￼</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;￼</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line">  ￼</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;￼</span><br><span class="line">    race++;￼</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;￼</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];￼</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;￼</span><br><span class="line">      threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;￼</span><br><span class="line">        <span class="meta">@Override</span>￼</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;￼</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;￼</span><br><span class="line">            increase();￼</span><br><span class="line">          &#125;￼</span><br><span class="line">        &#125;￼</span><br><span class="line">      &#125;);￼</span><br><span class="line">      threads[i].start();￼</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有累加线程都结束￼</span></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)￼</span><br><span class="line">      Thread.yield();</span><br><span class="line">    System.out.println(race);￼</span><br><span class="line">  &#125;￼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案不是我们预想的200000，而是一个比它小的数字，问题就在我们的 <code>race++</code> 里面，反编译代码得到 <code>increase</code>  方法的以下指令码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;￼</span><br><span class="line">  Code:￼</span><br><span class="line">    Stack=<span class="number">2</span>, Locals=<span class="number">0</span>, Args_size=<span class="number">0</span>￼</span><br><span class="line">    0:   getstatic       #13; //Field race:I￼</span><br><span class="line">    <span class="number">3</span>:   iconst_1￼</span><br><span class="line">    <span class="number">4</span>:   iadd￼</span><br><span class="line">    5:   putstatic       #13; //Field race:I￼</span><br><span class="line">    <span class="number">8</span>:   <span class="keyword">return</span>￼</span><br><span class="line">    LineNumberTable:￼</span><br><span class="line">    line <span class="number">14</span>: <span class="number">0</span>￼</span><br><span class="line">    line <span class="number">15</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure><p>首先是一条 <code>getstatic</code> 指令，把 race 的值取到操作栈顶， volatile 关键字保证了 race 的值再此时是正确的，但是执行 <code>iconst_1</code> 和 <code>iadd</code> 的时候，可能有其他线程把 race 的值改变了（变大），而操作栈顶的值也就过期了，现在我们使用 <code>putstatic</code> 把一个较小的 race 值写回到了主内存中。</p><blockquote><p>一条字节码指令，也并不意味着这条指令就是一个原子操作，一条字节码指令执行的时候，解释器要运行许多行代码才能实现它的语义，使用指令 -XX:+PrintAssembly 会更加严谨。</p></blockquote><p>由于 volatile 变量<strong>只能保证可见性</strong>，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。</p><ol><li><p>￼<strong>运算结果并不依赖变量的当前值</strong>，或者能够确保<strong>只有单一的线程修改变量的值</strong>。</p></li><li><p>￼<strong>变量不需要与其他的状态变量共同参与不变约束</strong>。</p></li></ol><p>比如说下面的代码，就非常适合使用使用 volatile 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;￼</span><br><span class="line">  shutdownRequested = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;￼</span><br><span class="line">  <span class="keyword">while</span> (!shutdownRequested) &#123;￼</span><br><span class="line">    <span class="comment">// do stuff￼</span></span><br><span class="line">  &#125;￼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 volatile 变量的第二个语义是禁止指令重排序优化</strong>，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是 Java 内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。</p><p>对于一个双锁单例 DCL ，我们看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;￼</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;￼</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class) &#123;￼</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;￼</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();￼</span><br><span class="line">        &#125;￼</span><br><span class="line">      &#125;￼</span><br><span class="line">    &#125;￼</span><br><span class="line">    <span class="keyword">return</span> instance;￼</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;￼</span><br><span class="line">    Singleton.getInstance();￼</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把它转换成指令码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01a3de0f</span>: mov    $<span class="number">0x3375cdb0</span>,%esi      ;...beb0cd75 <span class="number">33</span>￼</span><br><span class="line">                                         ;   &#123;oop(<span class="string">'Singleton'</span>)&#125;￼</span><br><span class="line"><span class="number">0x01a3de14</span>: mov    %eax,<span class="number">0x150</span>(%esi)      ;...<span class="number">89865001</span> <span class="number">0000</span>￼</span><br><span class="line"><span class="number">0x01a3de1a</span>: shr    $<span class="number">0x9</span>,%esi             ;...c1ee09￼</span><br><span class="line"><span class="number">0x01a3de1d</span>: movb   $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi)  ;...c6860048 <span class="number">100100</span>￼</span><br><span class="line"><span class="number">0x01a3de24</span>: lock addl $<span class="number">0x0</span>,(%esp)        ;...f0830424 <span class="number">00</span>￼</span><br><span class="line">                                         ;＊putstatic instance￼</span><br><span class="line">                                         ;-￼</span><br><span class="line">Singleton::getInstance@<span class="number">24</span></span><br></pre></td></tr></table></figure><p>我们可以发现变化在于用 volatile 修饰的变量，赋值后（<code>mov %esp ...</code>）多执行了一条 <code>lock addl ...</code> 指令 ，这个操作相当于<strong>内存屏障</strong>，指<strong>重排序的时候不能把后面的指令重排序到内存屏障之前的位置</strong>。</p><p>单 CPU 的时候不需要内存屏障，但如果有两个或更多 CPU 访问一块内存，且其中有一个在观测另外一个，就需要内存屏障来保证一致性。它的操作是 <code>addl $0x0, (%esp)</code> 把 ESP 寄存器的值加0，显然，这是无意义的操作，而关键不是这里，而是前面的 <strong>lock</strong> ，这个指令的作用是使本 CPU 的 Cache 写入内存，该写入操作使得其他 CPU 的 Cache 无效化，相当于对 Cache 中的变量做了一次 store + write ，工作内存到主内存，通过这个操作可以让前面 volatile 的变量的修改对其他 CPU 是立即可见。</p><blockquote><p>空操作前的 lock 使其他工作内存的变量无效，从而重新去主内存读取，因此对 volatile 可见。</p></blockquote><p>关于指令重排，比如现在有如下指令：</p><ol><li>A + 10</li><li>A * 2</li><li>B - 3</li></ol><p>指令1和指令2明显是相互依赖的，因为 (A + 10) <em> 2 和 A </em> 2 + 10 是不一样的，但指令3可以插入到指令1和2的中间，所以我们上面的 <code>lock addl $0x0, (%esp)</code> 指令把修改同步到内存时，意味着之前的操作已经完成，这样便形成了<strong>指令重排序无法越过内存屏障的效果</strong>。</p><blockquote><p>可以这么理解，volatile 变量的读写都意味着产生一个内存屏障，由内存屏障分割的指令不能越过内存屏障，这才是影响重排的含义，而不是重排不存在了。</p></blockquote><p>如果让 volatile 自己与自己比较，那可以确定一个原则：volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为<strong>它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</strong>。</p><p>尽管如此，大多数场景下 volatile 的总开销还是低于锁的，<strong>我们在 volatile 和锁之间选择的唯一依据仅仅是 volatile 能不能满足需求</strong>。</p><p>JMM 对 volatile 变量定义了特殊规则，假定 T 是一个线程，V 和 W 都是 volatile 的变量，那么在进行<strong>基本操作</strong>(read load use 等)的时候，需要满足以下规则：</p><ul><li>只有当线程 T 对变量 V 执行的前一个动作是 load 的时候，线程 T 才能对变量 V 执行 use 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 use 的时候，线程 T 才能对变量 V 执行 load 动作。线程 T 对变量 V 的 use 动作可以认为是和线程 T 对变量 V 的 load 、 read 动作相关联，必须连续一起出现（这条规则要求在工作内存中，<strong>每次使用 V 前都必须先从主内存刷新最新的值</strong>，用于保证能看见其他线程对变量 V 所做的修改后的值）。</li></ul><blockquote><p>回忆一下，load 操作执行在工作内存，把主内存的值加载到工作内存。</p><p>use 操作执行在工作内存，把工作内存的值传递给执行引擎。</p></blockquote><ul><li>只有当线程 T 对变量 V 执行的前一个动作是 assign 的时候，线程 T 才能对变量 V 执行 store 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 store 的时候，线程 T 才能对变量 V 执行 assign 动作。线程 T 对变量 V 的 assign 动作可以认为是和线程 T 对变量 V 的 store 、 write 动作相关联，必须连续一起出现（这条规则要求在工作内存中，<strong>每次修改 V 后都必须立刻同步回主内存中</strong>，用于保证其他线程可以看到自己对变量 V 所做的修改）。</li></ul><blockquote><p>assign 操作执行在工作内存，把执行引擎的值传递到工作内存。</p><p>store 操作执行在工作内存，把工作内存的值存到主内存。</p></blockquote><ul><li>￼假定动作 A 是线程 T 对变量 V 实施的 use 或 assign 动作，假定动作 F 是和动作 A 相关联的 load 或 store 动作，假定动作 P 是和动作 F 相应的对变量 V 的 read 或 write 动作；类似的，假定动作 B 是线程 T 对变量 W 实施的 use 或 assign 动作，假定动作 G 是和动作 B 相关联的 load 或 store 动作，假定动作 Q 是和动作 G 相应的对变量 W 的 read 或 write 动作。如果 A 先于 B ，那么 P 先于 Q （<strong>这条规则要求 volatile 修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同</strong>）。</li></ul><blockquote><p>T 对 V</p><p>A : use 、 assign</p><p>F : load 、 store</p><p>P : read 、 write</p><p>T 对 W</p><p>B : use 、 assign</p><p>G : load 、 store</p><p>Q : read 、 write</p><hr><p>主内存          工作内存           主内存</p><p>read 以后 load ； store 以后 write</p></blockquote><h3 id="1-4-对-long-和-double-型变量的特殊规则"><a href="#1-4-对-long-和-double-型变量的特殊规则" class="headerlink" title="1.4 对 long 和 double 型变量的特殊规则"></a>1.4 对 long 和 double 型变量的特殊规则</h3><p>对于64位的数据，特指 double 和 long ，允许虚拟机将没有被 volatile 修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择<strong>可以不保证</strong>64位数据类型的 load 、 store 、 read 和 write 这4个操作的原子性，这点就是所谓的 long 和 double 的<strong>非原子性协定</strong>。</p><p>目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般<strong>不需要把用到的 long 和 double 变量专门声明为 volatile </strong>。</p><blockquote><p>JMM 没有保证 long 和 double 的原子性，但是 JVM 保证了。</p></blockquote><h3 id="1-5-原子性、可见性与有序性"><a href="#1-5-原子性、可见性与有序性" class="headerlink" title="1.5 原子性、可见性与有序性"></a>1.5 原子性、可见性与有序性</h3><ul><li>原子性（Atomicity）：由 Java 内存模型来直接保证的原子性变量操作包括 read 、 load 、 assign 、 use 、 store 和 write ，我们大致可以认为<strong>基本数据类型的访问读写是具备原子性的</strong>（例外就是 long 和 double 的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。</li><li>可见性（Visibility）：可见性是指当<strong>一个线程修改了共享变量的值，其他线程能够立即得知这个修改</strong>。普通变量与 volatile 变量的区别是，volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。<strong>除了 volatile 之外，Java 还有两个关键字能实现可见性，即 synchronized 和 final </strong>。</li></ul><blockquote><p>同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store 、 write 操作）”这条规则获得的；</p><p>final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把 “this” 的引用传递出去（ this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见 final 字段的值。</p></blockquote><ul><li>有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</li></ul><blockquote><p>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p></blockquote><h3 id="1-6-先行发生原则"><a href="#1-6-先行发生原则" class="headerlink" title="1.6 先行发生原则"></a>1.6 先行发生原则</h3><p>happen-before 原则，先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，如果说操作 A 先行发生于操作 B ，其实就是说在发生操作 B 之前，<strong>操作 A 产生的影响能被操作 B 观察到</strong>，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>JMM 下有一些天然的先行发生关系，这些先行发生关系无须任何同步器协助就存在了，可以在编码中直接使用，如果两个操作的关系不在此列，<strong>且无法从这些规则推导</strong>，就无法保证顺序性，JVM 可以对它们随意重排序。</p><ul><li>程序次序规则（Program Order Rule）：<strong>在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作</strong>。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则（Monitor Lock Rule）：<strong>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</strong>。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li><li>volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li><li>线程启动规则（Thread Start Rule）：Thread 对象的 start() 方法先行发生于此线程的每一个动作。</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值等手段检测到线程已经终止执行。</li><li>线程中断规则（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测到是否有中断发生。</li><li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li><li>传递性（Transitivity）：如果操作 A 先行发生于操作 B ，操作 B 先行发生于操作 C ，那就可以得出操作 A 先行发生于操作 C 的结论。</li></ul><p>有一个很有意思的地方，就是上文提及的<strong>时间上的先后顺序</strong>。<strong>先行发生</strong>和<strong>时间上的先后顺序</strong>有什么关系呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个非常平产的 getter/setter ，假设有两个线程 A 和 B ，线程 A 先（时间上的先后）调用了“setValue(1)”，然后线程 B 调用了同一个对象的“getValue()”，那么线程 B 收到的返回值是什么？</p><p>答案是不确定的，因为在两个线程里，所以上面的<strong>先行发生规则</strong>不适用。对于它的修改有两种：</p><ol><li>把 getter/setter 都定义为 synchronized ，可以套用<strong>管程锁定规则</strong>；</li><li>把 value 定义为 volatile ，可以套用 <strong>volatile 变量规则</strong>。</li></ol><p>一个操作“时间上的先发生”<strong>不代表</strong>这个操作会是“先行发生”，那如果一个操作“先行发生”是否就能推导出这个操作必定是“时间上的先发生”呢？很遗憾，这个推论也是不成立的！一个典型的例子就是多次提到的“指令重排序”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>在同一个线程之中，根据程序次序规则，“int i=1”的操作先行发生于“int j=2”，但是“int j=2”的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这点。</p><p><strong>时间先后顺序与先行发生原则之间基本没有太大的关系</strong>，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p><blockquote><p>时间顺序不是我们衡量问题的标准。</p></blockquote><h2 id="2-Java-与线程"><a href="#2-Java-与线程" class="headerlink" title="2. Java 与线程"></a>2. Java 与线程</h2><p><strong>每个已经执行 start() 且还未结束的 java.lang.Thread 类的实例就代表了一个线程</strong>。我们注意到 Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的。<strong>在 Java API 中，一个 Native 方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用 Native 方法，不过，通常最高效率的手段也就是平台相关的手段）</strong>。正因为如此，作者把本节的标题定为“线程的实现”而不是“Java线程的实现”。</p><p>实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p><blockquote><p>这里我们不细究具体三种实现。</p><p>我们先只看具体的线程。</p></blockquote><p>Java 语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态。</p><ul><li>新建（New）：创建后尚未启动的线程处于这种状态。</li><li>运行（Runable）：Runable 包括了操作系统线程状态中的 Running 和 Ready ，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间。</li><li>￼无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：<ul><li>没有设置 Timeout 参数的 Object.wait() 方法。</li><li>没有设置 Timeout 参数的 Thread.join() 方法。</li><li>LockSupport.park() 方法。</li></ul></li><li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配 CPU 执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul><li>Thread.sleep() 方法。</li><li>设置了 Timeout 参数的 Object.wait() 方法。</li><li>设置了 Timeout 参数的 Thread.join() 方法。</li><li>LockSupport.parkNanos() 方法。</li><li>LockSupport.parkUntil() 方法。</li></ul></li><li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li><li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li></ul><p>上述5种状态在遇到特定事件发生的时候将会互相转换。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190121165533.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 深入理解 JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器与内存分配策略</title>
      <link href="/technology/2018-12-15-jvm-understanding-chapter2/"/>
      <url>/technology/2018-12-15-jvm-understanding-chapter2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一些探讨"><a href="#1-一些探讨" class="headerlink" title="1. 一些探讨"></a>1. 一些探讨</h2><p>目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了自动化的时代，为什么还需要去了解 GC 和内存分配呢？<strong>当需要排查各种内存溢出、内存泄露问题时，当垃圾收集器称为系统达到高并发量的瓶颈时，我们就需要对这些技术进行必要的监控和调节</strong>。</p><blockquote><p>早年使用垃圾回收机制去完成需求，渐渐的，垃圾回收反而称为了瓶颈，这个时候就需要关注垃圾回收了。</p></blockquote><p>对于线程私有的程序计数器、虚拟机栈、本地方法栈，它们随着线程而生，线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出入栈的操作。<strong>每一个栈帧中分配多少内存基本上在类结构确定下来的时候就已知了</strong>。因此这些区域的内存分配和回收都具备确定性。</p><p><strong>Heap</strong> 和<strong>方法区</strong>则不一样。一个接口的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，<strong>我们只有在程序运行期间才能知道会创建哪些对象</strong>，这部分内存是动态的，垃圾收集器所关注的也是这部分内存。</p><blockquote><p>比如有多少常量(方法区)，多少对象(堆)，这些在运行时才能知道。</p></blockquote><h3 id="1-1-对象消亡"><a href="#1-1-对象消亡" class="headerlink" title="1.1 对象消亡"></a>1.1 对象消亡</h3><p><strong>对象有没有消亡有两个判断标准</strong>：</p><ol><li>引用计数器，这有漏洞，互相引用就回收不了</li><li>可达性分析，主流</li></ol><p><strong>引用计数算法</strong>：给对象添加一个引用计数器，初始是0，有一个地方引用就加1，失效就减1，当引用计数器的数值为0，mnior gc 的时候回回收对象，如果不为0，则标志位加1，到15就进入老年代。</p><blockquote><p>主流 JVM 因为循环引用的原因不选择该方法，但仅仅是语言层面的问题，只要能做到一个是弱引用，就可以解决了。</p></blockquote><p><strong>可达性分析算法</strong>：从一些的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所过的路径称为引用链 Reference Chain ，但一个对象到 GC Roots 没有任何引用链想连，那么这些对象是不可达的，可以回收。</p><blockquote><p>可以作为 GC Roots 的对象都是可预期的，它们就像风筝的线，不管风筝怎么摇晃，只要抓住线就好了。</p></blockquote><p>可以作为 GC Roots 的对象包括下面几种：</p><ol><li>虚拟机栈 (栈帧中的本地变量表) 中引用的对象。</li><li>方法区中静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中 JNI 即一般说的 Native 方法引用的对象。</li></ol><h3 id="1-2-再谈引用"><a href="#1-2-再谈引用" class="headerlink" title="1.2 再谈引用"></a>1.2 再谈引用</h3><p>Jdk1.2 前， Java 对于引用的定义比较传统：<strong>如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用</strong>。</p><p>我们除了描述<strong>被引用</strong>和<strong>没有被引用</strong>两种状态外，还希望描述这样一类对象：<strong>当内存空间还够，则能保留在内存中；如果内存空间在进行 GC 后还是紧张，则可以抛弃这些对象</strong>。事实上，很多系统的缓存功能都符合这样的应用场景。</p><p>Jdk1.2 后，我们对引用进行了扩充，将引用分为了强引用、软引用、弱引用、虚引用，这4种引用强度依次递减。</p><ul><li><strong>强引用就是指在程序代码之中普遍存在的</strong>。类似 <code>Object obj = new Object()</code> 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li><strong>软引用是用来描述一些还有用但并非必需的对象</strong>。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 Jdk1.2 之后，提供了 SoftReference 类来实现软引用。</li><li><strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 Jdk1.2 之后，提供了 WeakReference 类来实现弱引用。</li><li><strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系</strong>。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到个系统通知。在 Jdk1.2 之后，提供了 PhantomReference 类来实现虚引用。</li></ul><blockquote><p>强引用：地位不可撼动，绝对的实力派。<br>软引用：正所谓食之无味，弃之可惜，JVM 实在忍不住了才会收拾它们。<br>弱引用：必死无疑。<br>虚引用：或者浪费空气，死去浪费土地。</p></blockquote><h3 id="1-3-生存还是死亡"><a href="#1-3-生存还是死亡" class="headerlink" title="1.3 生存还是死亡"></a>1.3 生存还是死亡</h3><p>在可达性分析中即使是不可达的对象，也并非是非死不可，它们只是被缓刑了，期间需要经历<strong>两次</strong>标记过程：</p><ol><li>如果对象在进行可达性分析后发现没有与 GC Roots 相连接引用链，那么它会被第一次标记，并且进行一次筛选，这里筛选的条件是此对象是否有必要执行一次 <code>finalize()</code> 方法，当对象没有覆盖该方法，或者该方法已经被虚拟机调用过，<strong>虚拟机将这两种情况视作“没有必要执行 GC”</strong> 。如果这个方法被判定有必要执行 <code>finalize()</code> 方法，那么这个对象将被放置在一个叫做 F-Queue 的队列中，并在稍后由 JVM 自动建立的、低优先级的 Finalizer 线程去执行它，<strong>但并不承诺它运行结束</strong>，这样做的原因是，如果一个对象在 <code>finalize()</code> 方法中执行缓慢，或者死循环，将有可能导致整个 F-Queue 队列中其他对象永久处于等待，甚至整个内存回收系统崩溃。</li><li><strong><code>finalize()</code> 方法是对象躲过死亡的最后机会</strong>，接着 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象在 <code>finalize()</code> 方法中成功拯救自己——只要重新与引用链上任何一个对象建立连接，<strong>比如把 this 赋值给某个类变量或者对象的成员变量</strong>，那么在第二次标记的时候将把它移出，如果没有逃离，那么就真的被回收了。</li></ol><p>任何一个对象的 <code>finalize()</code> 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 <code>finalize()</code> 不会再次执行，也就是说，它只能自救一次，或者说，第二次标记直接省略了已经执行过该方法的对象。</p><p>值得一提的是， <code>finalize()</code> 方法运行代价高昂，不确定性大不建议使用，它的功能在 <code>try...finally</code> 语句中可以做的更好更及时，它是对 C 语言的一种妥协。</p><blockquote><p>JVM 自动创建的 Finalizer 线程优先级低，无法保证执行时讯，并且也不保证即使得到执行，也一定等待其返回，因为其是利用 F-Queue 队列加创建独立 Finalizer 线程执行的方式。</p></blockquote><h3 id="1-4-回收方法区"><a href="#1-4-回收方法区" class="headerlink" title="1.4 回收方法区"></a>1.4 回收方法区</h3><p>很多人认为方法区没有 GC ， JVM 中确实说过可以不要求 JVM 在方法区中实现垃圾收集，并且在方法区中进行 GC 的性价比低得一塌糊涂。</p><p>HotSpot 中永久代（即方法区）的 GC 包括两部分：常量、类。常量还好，只要没有引用，在必要的时间，它会被清除，接口、方法、字段的符号引用也类似，而无用的类的判定略显复杂，需要满足以下三者，才算是“无用的类”：</p><ol><li>该类所有的实例都已经被回收， Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对相应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p><strong>满足以上三条，才算是可以回收，还不一定回收</strong>。在大量使用反射、动态代理、GCLib 等 ByteCode 框架、动态生成 JSP 以及 OSGI 这类平凡自定义 ClassLoader 的场景中都需要 JVM 具备类写在的功能，保证永久代不会溢出。</p><h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h2><h3 id="2-1-标记—清除算法"><a href="#2-1-标记—清除算法" class="headerlink" title="2.1 标记—清除算法"></a>2.1 标记—清除算法</h3><p>Mark - Sweep 算法，算法分为<strong>标记</strong>和<strong>清除</strong>两个步骤，首先编辑出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>不足之处：1. <strong>效率</strong>，标记和清除的效率都不高； 2.<strong>空间</strong>，标记清除之后会产生大量不连续的内部碎片。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190113213711.png" alt></p><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h3><p>为了解决<strong>效率</strong>问题，一种称为 Copying 的收集算法出现了，它可以进内存按容量划分为大小相等的两块，每次使用其中一块，当这一块用完了，将存活的对象复制到另外一块上，然后将使用过的内存空间清理，这样使得每次都是对半区进行内存收集，<strong>不用考虑内存碎片的问题</strong>，只要一动指针，按顺序分配内存即可，实现简单，运行高效。</p><p>不足之处：内存缩小一半，代价太高。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190113215437.png" alt></p><p>现在商业 JVM 都采用这种 GC 算法来回收新生代，新生代中对象 98% 是朝生夕死，所以不需要 1:1 来划分内存空间，而是内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor ，当回收时，将 Eden 和 Survivor 中存活的对象一次性复制到另外一块 Survivor 上，最后清理掉 Eden 和刚用过的 Survivor 空间， HotSpot 默认 Eden 和 Survivor 的比例是8:1，所以只有10%的内存会被浪费，<strong>我们无法保证每次回收都只有不多于10%的对象存活，当 Survivor 空间不够时，需要依赖其他内存（老年代）进行分配担保</strong>。</p><p>如果另外一块 Survivor 空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p><blockquote><p>这会导致当有大量临时大对象，例如一些序列化字节数组，会直接跳过 survivor ，到老年代中，导致平凡 full gc 。</p></blockquote><h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a>2.3 标记-整理算法</h3><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低，根据老年代的特点，有人提出了 Mark-Compact 算法，标记过程和标记清除一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一段移动，然后进行清理。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190113232831.png" alt></p><h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h3><p>当前商业 JVM 的 GC 都采用 Generational Collection 算法，只是根据对象存活周期的不同将内存划分为几块，一般是把 Java Heap 分为新生代和老年代，新生代中每次收集都发现大量死亡对象，那就使用复制算法；而老年代因为对象存活率高，就使用标记—清理或者标记—整理算法进行回收。</p><h2 id="3-HotSpot-算法实现"><a href="#3-HotSpot-算法实现" class="headerlink" title="3. HotSpot 算法实现"></a>3. HotSpot 算法实现</h2><p>从可达性分析中从 GC Roots 节点找引用链这个操作为例，可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，<strong>如果要逐个检查这里面的引用，那么必然会消耗很多时间</strong>。</p><p>另外，可达性分析对执行时间的敏感还体现在 GC 停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被<strong>冻结</strong>在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程（ Sun 将这件事情称为“ Stop The World ”）</p><p>当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的的，在类加载完成的时候， HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p><blockquote><p>普通对象指针（Ordinary Object Pointer）</p></blockquote><p><strong>GC 时为什么要 stop the world</strong>？为了确保标记对象是否可达的准确性。即使是 cms 收集器如其名： concurrent mark sweep 并发标记清理也会短暂的 stop the world 。</p><ul><li>初始标记：标记能关联到的对象 很快 stw 。</li><li>并发标记：标记对象是否可达 很耗时 但是不会 stw 。</li><li>重新标记  修正标记结果 很短 stw 。</li><li>并发清除：基于标记结果直接清理对象耗时不会 stw 。</li></ul><p>其中，初始标记、重新标记仍然需要“ Stop The World ”。初始标记标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记进行 GC Roots Tracing ，重新标记修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间比初始标记阶段长，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说， CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p><p><strong> JVM 什么时候开始 GC ？</strong><br>程序执行时只有在到达安全点（safe point）时才能暂停下来开始GC。</p><p><strong>那哪些地方出现安全点呢</strong>？<br>遇到方法调用，循环调整，异常跳转等指令时会产生安全点。</p><p><strong>如何在GC发生时让所有线程都“跑”到最近的安全点上再停顿下来</strong>？<br>有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。最常用的是主动式中断，即GC需要中断线程时，设置一个标志位，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><p>当线程处于 Sleep 状态或者 Blocked 状态时，无法响应JVM的中断请求，此时需要<strong>安全区域</strong>（Safe Region）来解决。安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4. 垃圾收集器"></a>4. 垃圾收集器</h2><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114140000.png" alt></p><p><strong>垃圾收集器是内存回收的具体实现</strong>。下面讨论的收集器基于 Jdk1.7 update14 后的 HotSpot 虚拟机。<strong>上图的连线代表组合</strong>。需要尤其值得注意的是 CMS 和 G1 分类器。</p><p><strong>虽然我们是在对各个收集器进行比较，但并非为了挑选出一个最好的收集器。</strong></p><h3 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h3><p>Serial 收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。</p><p>“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是<strong>在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束</strong>。</p><p>虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114140657.png" alt></p><blockquote><p>“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”这确实是一个合情合理的矛盾。</p></blockquote><p>从 Jdk1.3 开始，一直到现在最新的 Jdk1.7 ， HotSpot 虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从 <strong>Serial</strong> 收集器到 <strong>Parallel</strong> 收集器，再到 <strong>Concurrent Mark Sweep</strong>（CMS）乃至 GC 收集器的最前沿成果 <strong>Garbage First</strong>（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括 RT S J 中的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！</p><p>听起来 Serial 收集器已经到老而无用，食之无味弃之可惜的地步了，而它的优点就是<strong>简单高效</strong>，对于限定单个 CPU 的环境，该收集器没有其他线程交互的开销，就是专心垃圾回收。<strong>因此， Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择（默认新生代收集器）</strong>。</p><h3 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，<strong>这两种收集器也共用了相当多的代码</strong>。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114141608.png" alt></p><p>ParNew 收集器除了多线程收集之外，其他与 Serial 收集器相比并没有太多创新之处，但它却是许多运行在 <strong>Server 模式下的虚拟机中首选的新生代收集器</strong>，其中有一个与性能无关但很重要的原因是，<strong>除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作</strong>。</p><p>在 Jdk1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器—— CMS 收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，<strong>现在妈妈打扫我能同时扔纸屑了</strong>~</p><p><strong>CMS 作为老年代的收集器</strong>，却<strong>无法与 Jdk1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作￼</strong>，所以在 Jdk1.5 中使用 CMS 来收集老年代的时候，<strong>新生代只能选择 ParNew 或者 Serial 收集器中的一个</strong>。 ParNew 收集器也是使用 -XX:+UseConcMarkSweepGC 选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC 选项来强制指定它。</p><blockquote><p>CMS 是追求单次停顿时间短，不 care 总停顿时间；</p><p>Parallel Scavenge 是追求高吞吐，也就是总停顿时间短；</p><p>在 full gc 的时候，这两者是冲突的。</p></blockquote><p><strong>该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器</strong>。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（譬如32个，现在 CPU 动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。</p><blockquote><p>在这停顿，关于什么是<strong>并发</strong>和<strong>并行</strong>：</p><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p></blockquote><h3 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h3><p><strong>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</strong>……看上去和ParNew都一样。</p><p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是<strong>达到一个可控制的吞吐量（Throughput）</strong>。</p><blockquote><p>吞吐量 = 运行用户代码时间 /（运行用户代码时间 +垃圾收集时间）</p></blockquote><p>我们通过下面两个指令控制吞吐量：</p><ul><li>-XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间</li><li>-XX:GCTimeRatio 直接设置吞吐量大小，运行用户代码与垃圾回收时间的比例，比如设置19，则吞吐量是 19/20=95% 。</li></ul><p><strong>由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。</strong></p><p>除上述两个参数之外， Parallel Scavenge 收集器还有一个参数 <strong>-XX:+UseAdaptiveSizePolicy</strong> 值得关注。这是一个开关参数，<strong>当这个参数打开之后</strong>，就不需要手工指定新生代的大小（-Xmn）、 Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，<strong>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</strong>，这种调节方式称为 GC 自适应的调节策略（ GC Ergonomics )￼。</p><p>只需要把基本的内存数据设置好（如 -Xmx 设置最大堆），然后使用 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio （更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。<strong>自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别</strong>。</p><h3 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4 Serial Old 收集器"></a>4.4 Serial Old 收集器</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114144312.png" alt></p><p><strong>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法</strong>。</p><p>这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。</p><p>如果在 Server 模式下，那么它主要还有两大用途：一种用途是<strong>在 Jdk1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配</strong>￼，另一种用途就是作为 <strong>CMS 收集器的后备预案</strong>，在并发收集发生 Concurrent Mode Failure 时使用。</p><h3 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h3><p><strong>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法</strong> 。这个收集器是在Jdk1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old（PS MarkSweep） 收集器外别无选择。</p><p>由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。</p><p>直到 Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，<strong>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器</strong>。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114145622.png" alt></p><h3 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114163936.png" alt></p><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器</strong>。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 CMS 收集器就非常符合这类应用的需求。</p><p>CMS 收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记（CMS initial mark） <strong>stop the world</strong></li><li>并发标记（CMS concurrent mark）<strong>时间长</strong></li><li>重新标记（CMS remark）<strong>stop the world</strong></li><li>并发清除（CMS concurrent sweep）<strong>时间长</strong></li></ul><p><strong>初始标记</strong>仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，<strong>并发标记</strong>阶段就是进行 GC Roots Tracing 的过程，而<strong>重新标记</strong>阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114163936.png" alt></p><p>CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，Sun 公司的一些官方文档中也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但是 CMS 还远达不到完美的程度，它有以下3个明显的缺点：</p><ul><li>占用了一部分线程（或者说 CPU 资源），默认回收线程数是 “CPU 数 + 3 / 4” 而导致应用程序变慢，总吞吐量会降低；</li><li>CMS 收集器无法处理浮动垃圾（ Floating Garbage 并发清理阶段产生的垃圾），可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生；</li></ul><blockquote><p>也是因为垃圾收集阶段用户线程还是运行的，也就需要预留内存空间给用户进程：</p><ul><li>在 Jdk1.5 默认下，老年代使用了 68% 就会激活 CMS 收集器，可以使用 -XX:CMSInitatingOccupancyFraction 值来提高触发百分比；</li><li>在 Jdk1.6 下，CMS 收集器的启动阈值被提升到了 92% ，如果运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败；于是临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数 -XX:CMSInitiatingOccupancyFraction 设置得太高很容易导致大量 “Concurrent Mode Failure” 失败，性能反而降低。</li></ul></blockquote><ul><li>CMS 是基于“标记—清除”算法，会产生大量空间碎片。<strong>往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象</strong>，不得不提前触发一次 Full GC 。</li></ul><blockquote><p>为了解决这个问题，CMS 收集器提供了一个 -XX:+UseCMSCompactAtFullCollection 开关参数（默认就是开启的），用于在CMS收集器顶不住要进行 Full GC 时开启内存碎片的<strong>合并整理过程</strong>，内存整理的过程是无法并发的。</p><p>空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction ，这个参数是用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p></blockquote><h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114171003.png" alt></p><p>Garbage-First 是当今收集器技术发展的前沿成果之一。从 Jdk 7u4 开始移除了 Experimental 的标识。<strong>它是一款面向服务端应用的垃圾收集器</strong>。目的是替换 CMS 收集器。特点如下：</p><ul><li>并行与并发：G1 能充分利用多 CPU 、多核环境下的硬件优势，使用多个 CPU 来缩减 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 继续执行。</li><li>分代收集：与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 <strong>G1 可以不需要其他收集器配合就能独立管理整个 GC 堆</strong>，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。</li><li>空间整合：与 CMS 的“标记—清理”算法不同，<strong>G1 从整体来看是基于“标记—整理”算法实现的收集器</strong>，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 <strong>G1 运作期间不会产生内存空间碎片</strong>，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC 。</li><li>可预测的停顿：这是 G1 相对于 CMS 的另一大优势，<strong>降低停顿时间是 G1 和 CMS 共同的关注点</strong>，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。</li></ul><p><strong>在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代</strong>，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，<strong>它将整个 Java 堆划分为多个大小相等的独立区域（Region）</strong>，虽然还保留有<strong>新生代和老年代</strong>的概念，但新生代和老年代不再是物理隔离的了，它们<strong>都是一部分 Region（不需要连续）的集合</strong>。</p><p>G1 收集器之所以能建立可预测的停顿时间模型，<strong>是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集</strong>。G1 <strong>跟踪各个 Region 里面的垃圾堆积的价值大小</strong>（回收所获得的空间大小以及回收所需时间的经验值），在<strong>后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>在 G1 收集器中，Region 之间的对象引用包括其他收集器中新生代和老年代之间的对象引用，都是使用 <strong>Remembered Set 来避免全 Heap 扫描的</strong>。每个 Region 都有一个 Remembered Set 来对应，JVM 在对 Reference 类型的数据进行写操作的时候，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否在不同的 Region 中(<strong>比如新生代引用老年代</strong>)。</p><p>如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remember Set 之中，当进行内存回收的时候，在 GC 根节点的枚举范围中加入 Remember Set 即可保证不对全堆进行扫描也不会遗漏。</p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>￼初始标记（Initial Marking）</li><li>￼并发标记（Concurrent Marking）</li><li>￼最终标记（Final Marking）</li><li>￼筛选回收（Live Data Counting and Evacuation）</li></ul><p>对 CMS 收集器运作过程熟悉的读者，一定已经发现 G1 的前几个步骤的运作过程和CMS有很多相似之处。</p><p><strong>初始标记阶段</strong>仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。</p><p><strong>并发标记阶段</strong>是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</p><p>而<strong>最终标记阶段</strong>则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。</p><p>最后在<strong>筛选回收阶段</strong>首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，从 Sun 公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region ，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</p><blockquote><p>G1 与 CMS 相比，虽然它们都立足于低停顿时间，CMS 仍然是我现在的选择，但是随着 Oracle 对 G1 的持续改进，我相信 G1 会是最终的胜利者。如果你现在采用的收集器没有出现问题，那就没有任何理由现在去选择 G1 ，如果你的应用追求低停顿，那 G1 现在已经可以作为一个可尝试的选择，如果你的应用追求吞吐量，那 G1 并不会为你带来什么特别的好处。</p></blockquote><h3 id="4-8-阅读-GC-日志"><a href="#4-8-阅读-GC-日志" class="headerlink" title="4.8 阅读 GC 日志"></a>4.8 阅读 GC 日志</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114200914.png" alt></p><p>最前面的数字是 GC 发生的时间，这个数字的含义是从 JVM 启动以来的时间。</p><p>然后是 GC 和 Full GC 说明了垃圾回收的类型，如果是 <strong>Full</strong>  字样的，代表发生了 Stop-The-World 。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190114201126.png" alt></p><p>上面的 ParNew 新生代收集器的日志有 Full 标识，这一般是因为分配担保失败之类的问题，所以导致了 STW ，如果是调用 System.gc() 方法那么显示的将是 Full GC (System) 。</p><p>接着说第一张图，后面的 [DefNew 、 [Tenured 、 [Perm 标识了 GC 发生的位置，这里显示的区域名称与使用的 GC 收集器密切相关，上面样例所使用的 Serial 收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。如果是 ParNew 收集器，新生代名称就会变为“[ParNew”，意为“Parallel New Generation”。如果采用 Parallel Scavenge 收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。</p><p><strong>3324K -&gt; 152K(3712K)</strong> 含义是 <strong>GC 前该区域已使用容量 -&gt; GC 后该内存区域已使用容量(该区域总容量)</strong>，方括号之外的 <strong>3324K-&gt;152K(11904K)</strong> 表示 <strong>GC 前堆使用量 -&gt; GC 后堆使用量（堆总容量）</strong>。</p><p>再后面， 0.0025925 secs 表示该区域所占用的时间，单位是秒。有的收集器会给出具体时间，分别给出用户态和内核态时间。</p><h3 id="4-9-常用参数总结"><a href="#4-9-常用参数总结" class="headerlink" title="4.9 常用参数总结"></a>4.9 常用参数总结</h3><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/6D1A982174E7D6BFB08BF7530D5F483D.jpg" alt></p><h2 id="5-内存分配和回收策略"><a href="#5-内存分配和回收策略" class="headerlink" title="5. 内存分配和回收策略"></a>5. 内存分配和回收策略</h2><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：<strong>给对象分配内存</strong>以及<strong>回收分配给对象的内存</strong>。现在我们再一起来探讨一下<strong>给对象分配内存</strong>的那点事儿。</p><h3 id="5-1-对象优先分配在-Eden-分配"><a href="#5-1-对象优先分配在-Eden-分配" class="headerlink" title="5.1 对象优先分配在 Eden 分配"></a>5.1 对象优先分配在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配。<strong>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC</strong>。</p><p>虚拟机提供了 <strong>-XX:+PrintGCDetails</strong> 这个收集日志参数，告诉虚拟机在发生来收集行为时打印内存回收日志。</p><p>下面是一个小例子：<strong>-Xms20M、-Xmx20M、-Xmn10M</strong>这3个参数限制了 Java 堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。-XX:SurvivorRatio=8 决定了新生代中 Eden 区与一个 Survivor 区的空间比例是8∶1，从输出的结果也可以清晰地看到 <strong>“eden space 8192K、from space 1024K、to space 1024K”</strong> 的信息，新生代总可用空间为9216KB（Eden 区 + 1个 Survivor 区的总容量）。</p><blockquote><p>第一个参数 -Xms 指定 jvm 初始内存，第二个参数 -Xmx 指定 jvm 最大可用内存，第三个参数 -Xmn 指定新生代大小。<br>我们可以推算出 eden 8m、 survivor 1m (一个)</p></blockquote><p>一个非常重要的点：关于<strong>什么是 Minor GC 和 Full GC</strong>？</p><blockquote><p>新生代 GC （Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</p><p>老年代 GC （Major GC / Full GC）：指发生在老年代的 GC ，出现了 Major GC ，经常会伴随至少一次的 Minor GC （但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢10倍以上。</p></blockquote><p>比如我们执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> ＊ <span class="number">1024</span>;￼</span><br><span class="line">/＊＊￼</span><br><span class="line">＊ VM 参 数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails-XX:SurvivorRatio=<span class="number">8</span>￼   ＊/￼</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;￼</span><br><span class="line">  <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;￼</span><br><span class="line">  allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> ＊ _1MB];￼</span><br><span class="line">  allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> ＊ _1MB];￼</span><br><span class="line">  allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> ＊ _1MB];￼</span><br><span class="line">  allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> ＊ _1MB]; <span class="comment">//出现一次 Minor GC￼</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解读一下，我们首先分配给 allocation123 各2m的空间，最后给 allocation4 剩下的4m空间，我们知道我们的新生区可用空间只有9m，所以现在我们会发生 Minor GC ，并且执行的是<strong>分配担保机制</strong>，提前转移到老年代中。</p></blockquote><h3 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a>5.2 大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的 byte[] 数组就是典型的大对象）。</p><blockquote><p>大对象，不仅仅在于占用空间大，还要是连续空间。</p></blockquote><p>虚拟机提供一个 <strong>-XX:PretenureSizeThreshold</strong> 参数，令大于这个值的对象直接在老年代分配，这样避免了新生区的大量内存复制。</p><blockquote><p>这个参数仅仅对 Serial 和 ParNew 收集器有效，Parallel Scavenge 收集器不认识这个参数。如果遇到必须使用此参数的场景，可以考虑使用 ParNew 和 CMS 的组合。</p></blockquote><h3 id="5-3-长期存活的对象将进入老年代"><a href="#5-3-长期存活的对象将进入老年代" class="headerlink" title="5.3 长期存活的对象将进入老年代"></a>5.3 长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为1。<strong>对象在 Survivor 区中每“熬过”一次 Minor GC ，年龄就增加1岁</strong>，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <strong>-XX:MaxTenuringThreshold</strong> 设置。</p><h3 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a>5.4 动态对象年龄判定</h3><p><strong>不是永远必须达到指定年龄才能晋升到老年代。</strong> 如果在 Survivor 空间中相同年龄所有对象大小的总和大于Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p><blockquote><p>有点拗口，也就是年龄为 N 的所有对象占用空间超过一半，则年龄大于等于 N 的对象将直接进入老年代。</p><p>什么对象进入老年代：</p><ol><li>天生的老年代，即定一个需要连续的内存空间的大对象（数组）；</li><li>上年纪的老人，即 jvm 设置的参数 MaxTenuringThreshold 的阈值，超过该阈值则进入老年代；</li><li>普遍低龄化，当survivor to 和survivor from中有某一个年龄占有该内存总量的一半或者更多，该年龄就作为进入老年代的年龄阈值。</li></ol></blockquote><h3 id="5-5-空间分配担保"><a href="#5-5-空间分配担保" class="headerlink" title="5.5 空间分配担保"></a>5.5 空间分配担保</h3><p>在发生 Minor GC 之前，<strong>虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC ，尽管这次 Minor GC 是有<strong>风险</strong>的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC 。</p><blockquote><p>关于冒险的解释：</p><p>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，<strong>所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值</strong>，与老年代的剩余空间进行比较，决定是否进行 Full GC 来让老年代腾出更多空间。</p><p><strong>换句话说，如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败，如果出现，只好重新发起一个 Full GC 。</strong></p><p>即使这样兜兜转转，我们还是将 HandlePromotionFailure 开关打开，避免 Full GC 次数过于频繁。</p><p>Jdk1.6 Update24 后，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会发生 Minor GC，否则进行 Full GC 。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 深入理解 JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存区域与内存溢出</title>
      <link href="/technology/2018-12-08-jvm-understanding-chapter1/"/>
      <url>/technology/2018-12-08-jvm-understanding-chapter1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h2><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/运行时数据区.jpg" alt></p><h3 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h3><p>Program Counter Register 是一块较小的<strong>内存空间</strong>，它可以看作是当前线程所执行的<strong>字节码的行号指示器</strong>。</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖于这个计数器来完成。</p><blockquote><p>线程的中断以及中断优先级，就是 Java 中线程由 wait 状态到 running 状态恢复过程，程序计数器的线程独有的，它能记住上次执行到哪儿，下次继续执行。</p></blockquote><p>在任何一个确定的时刻，一个处理器都只会执行一条线程中指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储</strong>。</p><p>如果线程执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；</p><p>如果正在执行的是一个 Native 方法，这个计数器的值为 Undefined。</p><blockquote><p>Native method is a java method which implemented by non java code.</p></blockquote><p>这里是 Java 虚拟机中<strong>唯一一个没有规定任何 <code>OutOfMemoryError</code> 情况</strong>的区域。</p><h3 id="1-2-Java-虚拟机栈"><a href="#1-2-Java-虚拟机栈" class="headerlink" title="1.2 Java 虚拟机栈"></a>1.2 Java 虚拟机栈</h3><p>Java Virtual Machine Stacks 也是线程私有的，它的生命周期和线程相同。</p><p>它描述了 Java 方法执行的内存模型：<strong>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。</p><p>每个方法从调用直至执行完成的过程，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p><p>人们经常说的堆栈中的栈，在 Java 里就是这里的虚拟机栈，或者更加准确一点，是虚拟机中中的<strong>局部变量表</strong>。</p><blockquote><p>所以说有多少个线程就有多少个栈，所有栈指向同一个堆里的对象，当多个线程想同时改变堆内存中的一个引用时，就会出现线程同步的问题。</p></blockquote><p>局部变量表存放了编译期可知的基本数据类型（八种）、引用类型、returnAddress 类型（指向了一条字节码指令的地址）。其中 64 位长度的 long 和 double 类型的数据占用两个局部变量空间，其余都是一个。</p><p><strong>局部变量表所需的内存空间在编译器就分配完成</strong>，进入一个方法这个方法需要在栈中分配多大的局部变量空间是完全确定的，<strong>在方法运行期间不会改变局部变量表的大小</strong>。</p><blockquote><p>编译生成 .class 文件时就会把这个方法所需要的内存空间定义好，所以 Java 是一门静态语言。</p></blockquote><p>该区域有两种异常状况：如果线程请求的栈深度大于与你及所允许的深度，将抛出 <code>StackOverFlowError</code> 异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，将会抛出 <code>OutOfMemoryError</code> 异常。</p><blockquote><p>局部变量表长度是在编译期确定的，不会发生内存溢出，而虚拟机栈会溢出。</p></blockquote><h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><p>Native Method Stack 与虚拟机栈发挥的作用是相似的，它们之间的区别在于虚拟机栈为执行 Java 方法（字节码）服务，而本地方法栈则为虚拟机使用 Native 方法服务。</p><blockquote><p>Native 方法其实现为非 Java 语言，编写的规则遵循 Java 本地接口的规范（ JNI ）。</p></blockquote><p>虚拟机规范没有强制对该区域规范，具体的虚拟机可以自由实现它，譬如 Sun HotSpot 虚拟机将本地方法栈和虚拟机栈合二为一。</p><p>这里也有虚拟机栈栈提及的两种异常。</p><h3 id="1-4-Java-堆"><a href="#1-4-Java-堆" class="headerlink" title="1.4 Java 堆"></a>1.4 Java 堆</h3><p>在大多数应用中，Java Heap 是虚拟机所管理的内存中最大的一块。内存共享。</p><blockquote><p>Java 堆是所有线程共享的，物理上不一定连续，而逻辑上连续。</p></blockquote><p>此区域的唯一目的是<strong>存放对象实例</strong>，几乎所有对象实例都在这里分配内存。</p><blockquote><p>随着 JIT 的发展，栈上分配内存，标量替换等优化技术，让对象都在堆上创建变得不再绝对。</p></blockquote><p>所有对象实例以及数据都在堆上分配，堆分为新生代和老年代，新生代又细分为 eden 区和两个 survivor 区。</p><blockquote><p>新生代占有 1/3 ，老年代占有 2/3 。</p></blockquote><p>从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个<strong>线程私有的分配缓冲区</strong>，Thread Local Allocation Buffer ， TLAB 。</p><p>Java 堆可以控制内存大小。</p><blockquote><p>Xmx — 堆最大值</p><p>Xms — 堆最小值/初始化堆大小</p><p>Xmn — 年轻代堆大小</p><p>Xss 每个线程的栈大小</p><p>-XX:MaxTenuringThreshould — 来设定到达某个年龄可以成为老年代，默认是 15 。</p><p>-XX:NewRatio — 指定新生代和老年代的比例，默认是 1:2 。</p></blockquote><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 <code>OutOfMemoryError</code> 异常。</p><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h3><p>Method Area 也是线程共享的。它用于存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器（ JIT ）编译后的代码等数据。</p><blockquote><p>之所以叫方法区，而不是常量、静态变量、热点代码区，是因为这一块是各个方法共享的区域，不属于某个方法，所有方法都可以访问这个区域。</p></blockquote><p>它还有一个名字， Non-Heap ，与堆进行区分。</p><p>HotSpot 虚拟机早期把这里称为 Permanenet Generation ，把 GC 分代扩展到了方法区，或者说使用永久代来实现方法区而已。这样 HotSpot 的 GC 就可以像管理 Java 堆一样管理这部分内存。其它虚拟机不存在永久代概念。</p><blockquote><p>因为 <code>String.intern()</code> 这样的方法存在，会产生内存溢出问题，在 jdk1.7 的时候，HotSpot 已经将原本放在永久代的字符串常量池移出，而这个该方法的实现在 jdk1.7 也改变了。</p><p>永久代在 jdk1.8 中完全移除，使用 metaspace 代替，元空间可以在本地内存之外分配，所以其最大可利用空间是整个系统可用的内存空间。</p></blockquote><p>垃圾收集在这个区域很小出现，因为这个区域的回收条件非常苛刻，但是却是必要的。</p><blockquote><p>这里可以回收：废弃常量，无用的类。苛刻的应该说是无用的类：</p><ol><li>该类所有的实例都已经被回收，即 Java 堆中不存在该类的任何实例；</li><li>加载该类的 ClassLoader 已经被回收；</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>满足上面三个条件也仅仅是“可以”删除，而不是必然回收。</p></blockquote><p>当方法区无法满足内存分配要求的时候，将抛出 <code>OutOfMemoryError</code> 异常。</p><h3 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h3><p>Runtime Constant Pool 是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的<strong>运行时常量池</strong>中存放。</p><blockquote><p>字面量就比如： int a = 1; 这里的 1 就是字面量。再比如： String a = “abc”; 这里的 abc 就是字面量。</p><p>符号引用包括：</p><ol><li>类和接口的全限定名 </li><li>字段名字和描述符</li><li>方法名称和描述符</li></ol><p>符号引用和直接引用：直接引用存的是地址值，而符号引用存放的是一个路径，包路径。两者替换发生在类解析的时候。</p><p>运行时常量池：</p><ol><li><p>全局常量池在每个 VM 中只有一个，存放常量的引用值。</p></li><li><p>class 常量池是在编译的时候每个 class 都有的，在编译阶段，存放的是常量的符号引用。</p></li><li><p>运行时常量池是在类加载完成后，将每个 class 常量池中的符号引用值转存到运行时常量池中，也就是说，每个 class 都有一个运行时常量池，类在解析后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</p></li><li>运行时也可能将新的常量放入池中。</li></ol></blockquote><p>一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储到运行时常量池中。</p><p>关于运行时将常量放入池中，书上说 String 的 intern() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>); <span class="comment">// 此时 new 关键字在堆中创建了 abc 字符串对象。</span></span><br><span class="line">String str = str1.intern(); <span class="comment">// 从池中返回字符串对象，如果没有则先添加到池中再返回。</span></span><br><span class="line"><span class="comment">// jdk1.6 的做法是直接在常量池中生成一个 abc 对象。</span></span><br><span class="line"><span class="comment">// jdk1.7 及以上版本不再存储一个对象了，可以直接存储堆中的引用。</span></span><br><span class="line">String str2 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 因此，str == str2 的结果是 true</span></span><br><span class="line"><span class="comment">// 所以，我们反复调用这个方法也不会出现 OutOfMemoryError 异常！</span></span><br></pre></td></tr></table></figure><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法申请内存时，将抛出 <code>OutOfMemoryError</code> 异常。</p><h3 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h3><p><strong>Direct Memory 并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域</strong>。但是这部分的内存也被频繁使用，而且可能导致 <code>OutOfMemoryError</code> 异常，值得探讨。</p><p>Jdk1.4 引入的 NIO 类，引入了基于 Channel 和 Buffer 的 I/O 方式，然后通过存储在 Java 堆上的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样可以在一些场景中显著提高性能，避免了在 Java 堆和 Native 堆中来回复制数据。</p><p>显然，本地的直接内存的分配不会受 Java 堆的大小而限制，但是会收到本机总内存大小和处理器寻址空间的限制。<strong>服务器管理员在配置时，可能忽略直接内存，使得各内存区域综合大于物理内存限制，产生异常</strong>。</p><h2 id="2-HotSpot-虚拟机对象"><a href="#2-HotSpot-虚拟机对象" class="headerlink" title="2. HotSpot 虚拟机对象"></a>2. HotSpot 虚拟机对象</h2><h3 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h3><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。</p><blockquote><p>为什么要去常量池寻找该指令的参数？因为前面提到过一个类的符号引用将在运行时放入到常量池中。</p><p>如果没有加载进来，将使用类加载器，使用双亲委派机制进行类加载。</p></blockquote><p>在类加载检查通过后，接下来虚拟机将<strong>为新生对象分配内存</strong>，对象需要的内存的大小在类加载完成后便完全确定了，分配内存的方式有两种，<strong>选择哪一种分配方式取决于 Java Heap 是否规整，而是否规整，取决于垃圾回收器是否具有压缩整理功能。</strong>：</p><ol><li>垃圾回收器使用 <code>Serial</code> 、 <code>ParNew</code> 等带有 Compact 过程的垃圾回收器将使用<strong>指针碰撞</strong>的方式分配内存；<blockquote><p>Java Heap 绝对规整，一边是空闲的内存，一边是用过的内存，我们使用一个指针作为分界，挪动指针来分配内存。</p></blockquote></li><li>使用 <code>CMS</code> 这种基于 <code>Mark-Sweep</code> 算法的收集器将使用<strong>空闲列表</strong>的方式分配内存。<blockquote><p>Java Heap 并不是规整的，使用和没有使用的内存交错，我们维护一个列表，记录哪些块可用，实时更新这张表。</p></blockquote></li></ol><p>除了划分空间，<strong>我们还需要考虑的一点是线程安全</strong>。为了保证线程安全，我们有两种方案：</p><ol><li>对分配内存空间的操作进行同步处理——实际虚拟机中使用 CAS 配上失败重试的方式来保证更新操作的原子性。<blockquote><p>Compare And Swap 通过版本号，先比较，再提交。假如版本号不是最新的则认定本次 CAS  操作失败。</p></blockquote></li><li>前面我们也提起过 TLAB Thread Local Allocation Buffer ，每个线程在 Heap 中预先分配一小块内存，称为本地线程分配缓存。只有在 TLAB 分配完，才进行同步锁定，分配新的 TLAB 。</li></ol><p>现在内存分配完成了，<strong>虚拟机将分配到的内存空间都初始化为零值</strong>，甚至 TLAB 可以将这一步提前到 TLAB 分配时进行，因此保证了 Java 代码可以不赋初始值直接使用。</p><blockquote><p>解释了为什么对象的属性可以不初始化就可以访问，而局部变量需要初始化，因为需要看栈帧的初始化方式。</p></blockquote><p>然后虚拟机对对象进行必要的设置，<strong>将一些必要的信息放到对象头中</strong>。</p><p>现在对于虚拟机而言一个对象已经产生了，而对我们而言，才刚刚开始。</p><blockquote><p>虚拟机创建对象：</p><ol><li>检查 new 参数是否在常量池中有一个类的引用，检查类是否被加载解析过。</li><li>没有则加载，通过后，虚拟机为新对象分配内存，在类加载完成就决定了内存大小，根据 GC 方式，看是否具有压缩整理功能，于是有<strong>指针碰撞</strong>和<strong>空闲列表</strong>两种分配方式。</li><li>分配可能出错，我们需要使用 <strong>CAS+错误重试</strong> 和 <strong>TLAB</strong> 两种方式保证线程安全。</li><li>内存分配完成，虚拟机将分配到的内存空间都初始化零值。</li><li>配置对象头，存放类的元数据信息、对象的哈希码、对象的 GC 年龄等信息。</li><li>从虚拟机角度看，现在，一个新的对象已经创建完成。</li><li>从我们的角度看，对象的创建刚刚开始， <code>init</code> 方法还没有执行，执行 <code>new</code> 以后执行 <code>init</code> 方法，这样一个真正的对新创建完成。</li></ol></blockquote><h3 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h3><p><strong>对象内存布局包括</strong>：</p><ol><li>对象头——保存状态信息以及类型信息</li><li>实例数据——保存对象中定义的变量信息</li><li>对齐填充——在对象有用信息不到八字节整数倍的时候进行对其</li></ol><p><strong>对象头中包括</strong>：</p><ul><li>a. 运行时数据<ul><li>哈希值</li><li>GC 信息</li><li>锁信息</li><li>线程 id</li><li>时间戳</li></ul></li><li>b. 类型指针</li></ul><p>官方称对象头为<strong>Mark Word</strong>，对象需要存储的运行时数据很多，其实已经超过了32位、64位 Bitmap 结构能记录的限度，但是<strong>对象头信息是与对象自身定义的数据无关的额外存储成本</strong>。</p><blockquote><p>所以一个对象所占有的空间大小，是比这个对象所存储的大小要大一点。</p></blockquote><p>如在 32bit 的虚拟机中，对象未被锁定，Mark Word 的 32bit 中有 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为0。其他状态（轻量级锁、重量级锁、GC 标记、可偏向）下的对象的内容见表：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190112135842.png" alt></p><p><strong>对象的另外一部分信息是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><blockquote><p>所谓元数据类型，即方法区中加载的类信息。</p></blockquote><p>查找对象的元数据信息并不一定要通过对象本身，因为我们可以用<strong>直接指针</strong>和<strong>句柄</strong>，直接指针需要根据对象头的类型指针来定位该对象的具体类型，但是通过句柄的时候，句柄池中存储了实例指针和类型指针，就不需要对象头中设置类型指针了。</p><p>值得注意的是，如果对象是 Java 数组，那么对象头中还必须有一块专门记录数组长度的数据，因为普通的 Java 对象的元数据信息中确定了 Java 对象的大小，而数组的元数据中却无法确定数组的大小。</p><blockquote><p>我们可以通过 .length 属性来直接获取长度，其他对象则是 length() 方法。</p></blockquote><p><strong>实例数据</strong>是对象真正存储的有效信息，也是对象代码中所定义的各种类型的字段内容，无论是父类继承的还是子类中定义的，都要记录，HotSpot 虚拟机默认分配策略为——longs/doubles, ints, shorts/chars, bytes/booleans, oops（普通对象指针 Ordinary Object Pointers），可以看出<strong>相同宽度的字段总被分配到一起</strong>，满足这个前提下，父类中定义的变量出现在子类之前，如果 CompactFields 参数值为 true（默认为 true），子类中较窄的遍历也可能插入到父类变量的空隙中。</p><p><strong>对齐填充</strong>并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 Hotspot VM的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h3><p>建立对象是为了使用对象，我们的程序需要通过栈上的 reference 数据来操作操作栈上的具体对象。由于 reference 类型在虚拟机中只规定了一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位，访问堆中对象的具体位置，访问方式由 JVM 实现而决定。</p><p>我们可以使用<strong>句柄</strong>和<strong>直接指针</strong>两种方式。</p><blockquote><p>句柄是一个指向对象实例数据的指针，Reference 是指向句柄的指针。</p></blockquote><p>如果我们使用句柄访问，那么 Heap 中将有一块内存来作为句柄池，Reference 将存储的是对象的句柄地址，句柄中包含了对象的<strong>实例数据</strong>和<strong>类型数据</strong>各自具体的地址信息。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190112142245.png" alt></p><p>如果使用直接指针访问，那么 Heap 堆对象的布局就必须考虑如何防止访问类型数据的相关信息，而 Reference 中存储的直接就是对象地址。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/20190112142423.png" alt></p><blockquote><p>这两种方式各有优势，Reference 存储就是稳定的句柄地址，对象对移动时改变句柄中的实例数据指针，而 Reference 本身不需要修改。<br>使用直接指针最大的好处就是速度更快，它节省了一次指针定位的时间开销，Sun HotSpot 使用的是第二种方式。</p></blockquote><h2 id="3-OOM-实战"><a href="#3-OOM-实战" class="headerlink" title="3. OOM 实战"></a>3. OOM 实战</h2><p>确定内存对象很有必要，分析是内存泄露还是内存溢出：</p><ol><li>内存泄露：本该释放内存的实例没有释放，根据引用链来确定位置。<strong>内存泄露不一定会内存溢出，但是极少成多，达到上限就会出现内存溢出。</strong></li><li>内存溢出：超出了 Heap 限制，堆内存增大或者分析对象声明周期是否过长。</li></ol><h3 id="3-1-Java-堆溢出"><a href="#3-1-Java-堆溢出" class="headerlink" title="3.1 Java 堆溢出"></a>3.1 Java 堆溢出</h3><p>Java Heap 用于存储对象实例，只要不断创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么对象在到达最大堆容量的时候就会产生内存溢出。</p><p>可以将 <code>-Xms</code>（堆最小值）和 <code>-Xmx</code>（堆最大值）设为一样，来避免堆自动扩展。</p><p>通过参数 <code>-XX:+HeapDumpOnOutputMemroyError</code> 可在出现内存溢出异常时 Dump 当前的内存堆转存储快照以便事后分析。</p><p>如果是内存泄露，找到泄露对象是通过怎样的路径与 GC Roots 关联导致无法回收，掌握泄露对象的类型信息以及引用链的信息，就可以找到泄露位置。</p><p>如果不存在泄露，就是对象都需要存活，那么就查看虚拟机的堆参数，查看是否可以调大，并检查某些对象生命周期是否过长，尝试减少程序运行期的内存消耗。</p><h3 id="3-2-虚拟机栈和本地方法栈溢出"><a href="#3-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="3.2 虚拟机栈和本地方法栈溢出"></a>3.2 虚拟机栈和本地方法栈溢出</h3><p>由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此对于 HotSpot 而言，虽然 <code>Xoss</code> 参数存在，用以设置方法栈大小，但是是无效的，栈容量只和 <code>-Xss</code> 有关。</p><p>我们还记得 JVM 中描述的两种异常：</p><ol><li>如果线程请求的栈深度大于虚拟机允许的最大深度，就会有 <code>StackOverFlowError</code> 异常；</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，将会抛出 <code>OutOfMemoryError</code> 异常。</li></ol><blockquote><p>第一种异常，在一个线程中不断调用新的方法压栈帧进去；<br>第二种异常，线程分配 jvm 栈，不断 new Thread();</p></blockquote><p>这里有两种异常，看似严谨，但是有重叠的地方：当栈空间无法分配时，到底是内存太小还是已使用的栈空间太大？</p><p>在单线程下，无论栈帧太大还是虚拟机容量太小都是抛出 <code>StackOverFlowError</code> ；</p><p>如果不限于单线程，不断简历线程可以产生 OOM ，但是这样产生内存溢出和栈空间没有任何联系，为每个线程的栈分配的内存越大，反而越容易产生 OOM 。</p><blockquote><p>在多线程的情况下，每个线程分配到的栈容量越大，可以建立的线程数量自然越少，建立线程时就越容易把剩下的内存耗尽。</p></blockquote><p>JVM 提供了参数来控制 Java Heap 和方法区这两部分的最大值，剩余的内存是进程内存上限减去线程共有的 Xmx (最大堆容量)，再减去 MaxPermSize (最大方法区容量)，然后是线程私有的，程序计数器内存消耗很小，可以忽略，剩下的内存就是虚拟机栈和本地方法栈瓜分了。</p><p>如果是建立过多线程导致的内存溢出，在不能减少线程数或替换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来换取更多的线程。</p><h3 id="3-3-方法区和运行时常量池溢出"><a href="#3-3-方法区和运行时常量池溢出" class="headerlink" title="3.3 方法区和运行时常量池溢出"></a>3.3 方法区和运行时常量池溢出</h3><p>线程公有的方法区，<code>String.intern()</code> 是个 Native 方法：如果字符串常量池中包括一个等于此 String 对象的字符串，则返回代表这个字符串的 String 对象，否则，将此 String 对象包含的字符添加到常量池中，并返回此 String 对象的引用。</p><blockquote><p>在 Jdk1.7 前， <code>String.intern()</code> 方法单纯将首次遇到的字符串实例复制到永久代中，返回的也是永久带中这个字符串实例的引用。</p></blockquote><p>在 Jdk1.6 前，由于常量池在永久代里，现在已经不是这样了，现在在元空间里，如果是以前，我们可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区方法，间接控制常量池。</p><p>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。</p><p>我们可以借助 CGLib 直接操作字节码运行时生成大量的动态类，当前很多主流的框架，比如 Spring 、 Hibernate 在对类进行增强的时候，都会用到这个技术。</p><p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量 Class 的应用中，需要特别注意类的回收状况。<strong>这类场景除了上面提到的程序使用了 CGLib 字节码增强和动态语言之外</strong>，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（ JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p><blockquote><p>在 Jdk1.8 前，本地部署 Tomcat 经常会 OOM ，可能就是因为项目中存在大量的 JSP 文件编译后加载的 JVM 中方法区内存溢出了。</p></blockquote><h3 id="3-4-本机直接内存溢出"><a href="#3-4-本机直接内存溢出" class="headerlink" title="3.4 本机直接内存溢出"></a>3.4 本机直接内存溢出</h3><p>DirectMemory 容量可以通过 <code>-XX:MaxDirectMemorySize</code> 指定，默认和 Java Heap 最大值一样。</p><p>由 DirectMemory 导致的内存溢出，一个明显的特征是 Heap Dump 文件不会看见明显的异常，如果我们发现 OOM 之后 Dump 文件很小，而且程序中又直接或间接使用了 NIO ，那么可以考虑这方面的问题。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 深入理解 JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探访问者模式</title>
      <link href="/design-pattern/2018-11-29-visitor/"/>
      <url>/design-pattern/2018-11-29-visitor/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/visitor" target="_blank" rel="noopener">koonchen/design-patterns/visitor</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></blockquote><p>例如，一个不使用访问者的编译器可能会通过在它的抽象语法树上调用 <code>TypeCheck</code> 操作对一个过程进行类型检查。每一个结点将对调用它的成员的 <code>TypeCheck</code> 以实现自身的 <code>TypeCheck</code> 。</p><p>每一个结点在实现 <code>Accept</code> 时将会回调访问者：一个赋值结点调用访问者的 <code>VisitAssignment</code> 操作，而一个变量引用将调用 <code>VisitVariableReference</code> ，以前类 <code>AssignmentNode</code> 的 <code>TypeCheck</code> 操作现在成为 <code>TypeCheckingVisitor</code> 的 <code>VisitAssignment</code> 操作。</p><p>为使访问者不仅仅只做类型检查，我们需要所有抽象语法树的访问者有一个抽象的父类 <code>NodeVisitor</code> 。<code>Visitor</code> 模式将每一个编译步骤的操作封装在一个与该步骤相关的 <code>Visitor</code> 中。</p><p>使用 <code>Visitor</code> 模式，必须定义两个类层次：一个对应于接受操作的元素，另一个对应于定义对元素的操作的访问者。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/visitor-1.jpg" alt="cover"></p><p>访问者模式的适用性：</p><blockquote><ul><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作污染这些对象的类。</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。</li></ul></blockquote><p>访问者模式的参与者：</p><blockquote><ul><li>Visitor — 为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作。</li><li>ConcreteVistor — 实现每一个由 Visitor 声明的操作。</li><li>Element — 定义一个 Accept 操作，它以一个访问者为参数。</li><li>ConcreteElement — 实现 Accept 操作。</li><li>ObjectStructure — 能枚举它的元素。</li></ul></blockquote><p>访问者模式的结构：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/visitor-2.jpg" alt="cover"></p><p>访问者模式的效果：</p><blockquote><ul><li>访问者模式使得易于增加新的操作。</li><li>访问者集中相关的操作而分离无关的操作。</li><li>增加新的 ConcreteElement 类很困难。</li><li>通过类层次进行访问。</li><li>累计状态 — 当访问者访问对象结构中的每一个元素时，它可能会累计状态。</li><li>破坏封装 — 访问者方法假定 ConcreteElement 接口的功能足够强，足以让访问者进行它的工作。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visitConcreteElement</span><span class="params">(Element element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitConcreteElement</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">    element.doSth();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">    visitor.visitConcreteElement(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"the method has been used"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略存储全部的 element</span></span><br><span class="line">    Element element = <span class="keyword">new</span> ConcreteElement();</span><br><span class="line">    Visitor visitor = <span class="keyword">new</span> ConcreteVisitor();</span><br><span class="line">    element.accept(visitor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关模式：</p><blockquote><p>Composite : 访问者可以用于对一个由 Composite 模式定义的对象结构进行操作。</p><p>Interpreter : 范文者可以用于解释。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 访问者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探观察者模式</title>
      <link href="/design-pattern/2018-11-28-observer/"/>
      <url>/design-pattern/2018-11-28-observer/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/observer" target="_blank" rel="noopener">koonchen/design-patterns/observer</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>定义对象的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动改变。</p></blockquote><p>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。这一模式的关键对象是目标和观察者，一旦目标的状态发生变化，所有的观察者都得到通知，每个观察者都将查询目标以使其状态与目标同步。</p><p>观察者模式的适用性：</p><blockquote><ul><li>当一个抽象模型有两个方面，其中一个方面依赖于另外一个方面，将这两者封装在独立的对象中使得他们可以独自改变和复用。</li><li>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。</li><li>当一个对象必须通知其他对象，而它又不能假定其他对象是谁。</li></ul></blockquote><p>观察者模式的参与者：</p><blockquote><ul><li>Subject — 目标知道它的观察者。可以有任意多个观察者观察同一个对象。</li><li>Observer — 为那些在目标发生改变时需获得通知的独享定义一个更新接口。</li><li>ConcreteSubject — 将有关状态存入各 ConcreteObserver 对象。</li><li>ConcreteObserver — 维护一个指向 ConcreteSubject 对象的引用。</li></ul></blockquote><p>观察者模式的结构如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/observer-1.jpg" alt="cover"></p><p>观察者模式的效果：</p><blockquote><ul><li>目标和观察者间的抽象耦合：一个目标所知道的仅仅是一个它有一系列的观察者，每一个都符合抽象的 Observer 类的简单接口。目标不知道任何一个观察者属于哪一个具体的类。</li><li>支持广播的通信：不像通常的请求，目标发送的通知不需要指定它的接收者，通知被自动地广播给所有已向该目标对象登记的有关对象。</li><li>意外的更新：因为一个观察者并不知道其他观察者的存在，它可能对改变目标的最终代价一无所知。在目标上一个看似无害的操作可能会引起一些列对观察者以及依赖于这些观察者的那些对象的更新。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  List&lt;Observer&gt; list;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">    list.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">    list.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">subjectNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Observer observer: list) &#123;</span><br><span class="line">      observer.update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getState</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String subjectState;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subjectState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(String subjectState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subjectState = subjectState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  String observerState;</span><br><span class="line">  Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subject = subject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    observerState = subject.getState();</span><br><span class="line">    System.out.println(observerState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先要有一个目标</span></span><br><span class="line">    Subject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">    subject.setState(<span class="string">"ConcreteSubject instance has been created"</span>);</span><br><span class="line">    Observer observer = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">    ((ConcreteObserver) observer).setSubject(subject);</span><br><span class="line">    subject.attach(observer);</span><br><span class="line">    subject.subjectNotify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关模式：</p><blockquote><ul><li>Mediator : 通过封装复杂的更新定义，ChangeManager 充当目标和观察者之间的中介者。</li><li>Singleton : ChangeManager 可使用 Singleton 模式来保证它是唯一的并且是可全局访问的。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观察者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探状态模式</title>
      <link href="/design-pattern/2018-11-28-state/"/>
      <url>/design-pattern/2018-11-28-state/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/state" target="_blank" rel="noopener">koonchen/design-patterns/state</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p></blockquote><p>一个 <code>TCPConnection</code> 对象的状态处于若干不同状态之一：连接已建立、正在监听、连接已关闭。当一个 <code>TCPConnection</code> 对象收到其他对象的请求时，它根据自身的当前状态做出不同的反应。例如，一个 <code>Open</code> 请求的结果依赖于该连接是否是连接已关闭还是已建立状态。<code>State</code> 模式描述了 <code>TCPConnection</code> 如何在每一种状态下表现出不同的行为。</p><p>这一模式的关键思想是引入一个抽象类来表示网络的连接状态。不同的状态子类声明了一个公共接口。其子类实现与特定状态相关。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/state-1.jpg" alt="cover"></p><p>从图中可以看出具体的使用细节。</p><p>状态模式的适用性：</p><blockquote><ul><li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。</li></ul></blockquote><p>状态模式的参与者：</p><blockquote><ul><li>Context : 定义客户感兴趣的接口。</li><li>State : 定义一个接口以封装与 Context 的一个特定状态相关的行为。</li><li>ConcreteState : 每一子类实现一个与 Context 的一个状态相关的行为。</li></ul></blockquote><p>状态模式的结构如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/state-2.jpg" alt="cover"></p><p>状态模式的效果：</p><blockquote><ul><li>它与特定状态相关的行为局部化，并且将不同状态的行为分割开来，State 模式将所有与一个特定的状态相关的行为都放到一个对象中。</li><li>它使得状态转换显式话，当一个对象仅以内部数据值来定义当前状态时，其状态仅表现为对一些变量的赋值。</li><li>State 对象可被共享，如果对象没有实力变量，它们表现的状态以它们的类型来编码，那么 Context 对象可以共享一个 State 对象。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ConcreteState instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">  State state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    State state = <span class="keyword">new</span> ConcreteState();</span><br><span class="line">    Context context = <span class="keyword">new</span> Context();</span><br><span class="line">    context.setState(state);</span><br><span class="line">    context.request();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关模式：</p><blockquote><ul><li>Flyweight 模式：何时以怎样共享状态对象。</li><li>状态对象通常是 Singleton 的。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探模板方法模式</title>
      <link href="/design-pattern/2018-11-28-template-method/"/>
      <url>/design-pattern/2018-11-28-template-method/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/template-method" target="_blank" rel="noopener">koonchen/design-patterns/template-method</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote><p>如下面类图所示：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/template-method-1.jpg" alt="cover"></p><p>上面的类图中，<code>OpenDocument</code> 定义了打开一个文档的每一个主要步骤，它检查该文档是否能被打开，创建与应用相关的 <code>Document</code> 对象，将它加到文档集合中，并且从一个文件中读取该 <code>Document</code> 。</p><p>我们称 <code>OpenDocument</code> 为一个模板方法，一个模板方法用一些抽象的操作定义一个算法，而子类将重定义这些操作以提供具体的行为。<code>Application</code> 的子类将定义检查一个文档是否能够被打开和创建文档的具体算法步骤。</p><p>模板方法的适用性：</p><blockquote><ul><li>一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li><li>控制子类扩展，模板方法强调 <code>hook</code> 操作，这样就只允许在这些点进行扩展。</li></ul></blockquote><p>模板方法的参与者：</p><blockquote><ul><li>AbstractClass : 定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤。</li><li>ConcreteClass : 实现原语操作以完成算法中与特定子类相关的步骤。</li></ul></blockquote><p>模板方法的结构：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/template-method-2.jpg" alt="cover"></p><p>模板方法的效果：</p><blockquote><ul><li>钩子操作，它提供了缺省的行为，子类可以在必要时进行扩展，一个钩子操作在缺省操作时通常是一个空操作。</li><li>Factory Method</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    primitiveOperation1();</span><br><span class="line">    primitiveOperation2();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">primitiveOperation1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">primitiveOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"primitiveOperation1 method has been used"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">primitiveOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"primitiveOperation2 method has been used"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractClass abstractClass = <span class="keyword">new</span> ConcreteClass();</span><br><span class="line">    abstractClass.templateMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关实现：</p><blockquote><ul><li>Factory Method : 常常被模板方法调用，上面的 <code>DoCreateDocument</code> 就是一个 Factory Method 。</li><li>Strategy : 模板方法使用继承来改变算法的一部分。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探备忘录模式</title>
      <link href="/design-pattern/2018-11-26-memento/"/>
      <url>/design-pattern/2018-11-26-memento/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/memento" target="_blank" rel="noopener">koonchen/design-patterns/memento</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态。</p></blockquote><p>有时有必要记录一个对象的内部状态，但是对象通常封装了其部分或所有的状态信息，使得其状态不能被其他对象访问，也就就不可能在该对象之外保存其状态；而暴露内部状态又将违反封装的原则。</p><p>备忘录是一个对象，它存储另一个对象在某个瞬间的内部状态；而另一者被称为备忘录的原发器，当需要设置原发器的检查点时，取消操作机制会向原发器请求一个备忘录。</p><p>原发器用描述当前状态的信息来初始化该备忘录，只有原发器可以向备忘录中存取信息，备忘录对其他的对象是不可见的。</p><p><code>ConstraintSolver</code> 作为一个原发器，发生以下的事件序列：</p><blockquote><ol><li>作为移动操作的一个副作用，编辑器向 <code>ConstraintSolver</code> 请求一个备忘录。</li><li><code>ConstraintSolver</code> 创建并返回一个备忘录，在这个例子中该备忘录是 <code>SolverState</code> 类的一个实例。</li><li>此后，当用户取消移动操作，编辑器将 <code>SolverState</code> 备忘录送回给 <code>ConstraintSolver</code> 。</li><li>根据 <code>SolverState</code> 备忘录的信息，<code>ConstraintSolver</code> 改变它的内部结构以精确地讲它的等式和变量返回给它们各自当前的状态。</li></ol></blockquote><p>备忘录模式的适用性：</p><blockquote><ul><li>必须保存一个对象在某个时刻的状态，这样以后需要时它才能恢复到指定的状态。</li><li>如果一个用接口让其他对象直接得到这些状态，将会暴露对象的细节并破坏对象的封装。</li></ul></blockquote><p>备忘录模式的参与者：</p><blockquote><ul><li>Memento — 备忘录存储原发器对象的内部结构。</li><li>Originator — 原发器创建一个备忘录，用以记录当前时刻它的内部状态。</li><li>Caretaker — 负责保存好备忘录。</li></ul></blockquote><p>备忘录模式的结构：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/memento-1.jpg" alt="cover"></p><p>备忘录模式有以下效果：</p><blockquote><ul><li>保持封装边界：使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发器之外的信息。</li><li>它简化了原发器：在其他的保持封装性的设计中，原发器负责保持客户请求过的内部状态版本。</li><li>使用备忘录可能代价很高：如果原发器在生成备忘录时必须存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销。</li><li>定义窄接口和宽接口：在一些语言中可能难以保证只有原发器可访问备忘录的状态。</li><li>维护备忘录潜在的代价：管理器负责删除它维护的备忘录。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String state;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String state = <span class="string">"before"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">    state = memento.getState();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Memento&gt; list;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Caretaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">    list.add(memento);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Memento&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MementoClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">    Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">    caretaker.add(originator.createMemento());</span><br><span class="line">    List&lt;Memento&gt; list = caretaker.getList();</span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>).getState());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关模式：</p><blockquote><p>Command : 命令模式可以使用备忘录来为可撤销的操作维护状态。</p><p>Iterator : 如先前所述备忘录可用于迭代。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探迭代器模式</title>
      <link href="/design-pattern/2018-11-23-iterator/"/>
      <url>/design-pattern/2018-11-23-iterator/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/iterator" target="_blank" rel="noopener">koonchen/design-patterns/iterator</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。</p></blockquote><p>一个聚合对象，如列表我们需要一个方法来让别人可以访问它的元素，关键在于列表的访问和遍历从中分离出一个迭代器对象。</p><p>下面是一个列表和一个列表迭代器，他们是耦合在一起的：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/iterator-1.jpg" alt="cover"></p><p>客户对象必须知道遍历的是一个列表而不是其他聚合结构，最好有一种方法能使得不改变客户代码即改变该聚合类。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/iterator-2.jpg" alt="cover"></p><p>现在我们分离操作列表的公共接口，以及公共迭代接口，令迭代机制和聚合类无关。</p><p>迭代器模式的适用性：</p><blockquote><ul><li>访问一个聚合对象的内容而无需暴露它的内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一的接口</li></ul></blockquote><p>迭代器模式的参与者：</p><blockquote><ul><li>Iterator — 迭代器定义访问和遍历元素的接口</li><li>ConcreteIterator — 具体迭代器实现迭代器接口</li><li>Aggregate — 聚合定义创建相应迭代器对象的接口</li><li>ConcreteAggregate — 具体聚合实现创建相应迭代器的接口</li></ul></blockquote><p>现在迭代器模式的结构已经显而易见了：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/iterator-3.jpg" alt="cover"></p><p>迭代器有三个重要的作用：</p><blockquote><ul><li>它支持以不同的方式遍历一个聚合：复杂的聚合可用多种方式进行遍历。</li><li>迭代器简化了聚合的接口：有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了。</li><li>在同一个聚合上可以有多个遍历：每个迭代器保持它自己的遍历状态。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现迭代器模式常常需要一些权衡：</p><blockquote><ul><li>谁控制该迭代：一个基本的问题是决定由哪一方来控制该迭代，是迭代器是还使用该迭代器的客户。客户决定称为外部迭代器，由该迭代器决定称为内部迭代器。</li><li>谁定义遍历算法：迭代器不是唯一可定义遍历算法的地方。聚合本身也可以遍历算法，并在遍历的过程中用迭代器来存储当前迭代的状态。</li><li>迭代器健壮程度如何：在遍历一个聚合的同事更改这个聚合是危险的。</li><li>附加的迭代器操作：迭代器的最小接口由各种操作组成其他一些操作可能也很有用。</li><li>迭代器可有特权访问：迭代器可被看为创建它的聚合的一个扩展。</li><li>用于复合对象的迭代器：在组合模式中的那些递归聚合结构上，外部迭代器可能难以实现，因为该结构中不同对象处于嵌套聚合的多个不同层次，因此一个外部迭代器为跟踪当前的对象必须存储一条纵贯该组合的路径。</li><li>空迭代器：一个空迭代器是一个退化的迭代器，它有助于边界处理。</li></ul></blockquote><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">  <span class="function">ConcreteIteraor <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// add</span></span><br><span class="line">  <span class="function">List <span class="title">getList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">T <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIteraor</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Aggregate aggregate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIteraor</span><span class="params">(Aggregate aggregate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.aggregate = aggregate;</span><br><span class="line">    <span class="keyword">this</span>.idx = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">this</span>.aggregate.getList();</span><br><span class="line">    <span class="keyword">return</span> (Integer) list.get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">this</span>.aggregate.getList();</span><br><span class="line">    <span class="keyword">return</span> (Integer) list.get(++idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"the method has been used"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">currentItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">this</span>.aggregate.getList();</span><br><span class="line">    <span class="keyword">return</span> (Integer) list.get(idx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚合类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteAggregate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.add(<span class="number">10</span>);</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConcreteIteraor <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIteraor(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ConcreteAggregate aggregate = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">    Iterator iterator = aggregate.createIterator();</span><br><span class="line">    Integer item = (Integer) iterator.next();</span><br><span class="line">    System.out.println(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关模式：</p><blockquote><p>Composite: 迭代器通常被应用到复合这样的递归结构上</p><p>Factory Method: 多态迭代器靠 Factory Method 来实例化适当的迭代器子类</p><p>Memento: 常与迭代器模式一起使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探中介者模式</title>
      <link href="/design-pattern/2018-11-24-mediator/"/>
      <url>/design-pattern/2018-11-24-mediator/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/mediator" target="_blank" rel="noopener">koonchen/design-patterns/mediator</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>用一个中介对象来封装一系列的对象交互。中介者使兑现不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></blockquote><p>面向对象设计鼓励将行为分布到各个对象中，这种分布可能会造成许多连接，最坏的情况下，每个对象都知道其他所有对象。</p><p>大量的相互连接使得一个对象那个不能在没有其他对象的支持下工作——系统表现为一个不可分割的对象。我们不得不定义很多子类以定制系统的行为。</p><p>可以通过将集体行为封装在一个单独的中介者对象中来避免这个问题，中介者负责控制和协调一组对象间的交互。中介者充当一个中介使得组中的对象不再相互显式引用，这些对象仅知道中介者，从而减少了相互连接的数目。</p><p>下面我们用 <code>FontDialogDirector</code> 来作为一个对话框组件间的中介者。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/mediator-1.jpg" alt="cover"></p><p>下面的交互图说明了各对象如何协作处理一个列表框中选项的变化。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/mediator-2.jpg" alt="cover"></p><blockquote><ol><li>列表框告诉它的操作者它被改变了。</li><li>导控者从列表框中得到选中的选择项。</li><li>导控者将选择项传递给入口域。</li><li>现在入口域中已有正文，导控者使得用于发起一个动作的某个按钮可用。</li></ol></blockquote><p>导控者是如何在对话框和入口域之间进行中介中。窗口组件之间的通信都是通过导控者间接地进行。它们不必互相知道，它们仅需要知道导控者。<strong>所以只要扩展或替换这个类，就可以改变和替换这些行为。</strong></p><p>下面是 <code>FontDialogDirector</code> 抽象被集成到一个类库中：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/mediator-3.jpg" alt="cover"></p><p>中介者模式的适用性：</p><blockquote><ul><li>一组对象以定义良好但是复杂的方式进行通信。</li><li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。</li><li>想定制一个分布在很多类中的行为，而又不想生成太多的子类。</li></ul></blockquote><p>中介者模式的参与者：</p><blockquote><p>Mediator — 中介者定义一个接口用于与各同事对象通信。</p><p>ConcreteMediator — 具体中介者通过协调各同事对象实现协作行为。</p><p>Colleague Class — 每一个同事类都知道它的中介者对象。</p></blockquote><p>中介者模式的结构：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/mediator-4.jpg" alt="cover"></p><blockquote><p>协作的过程中，同事向一个中介者对象发送和接收请求，中介者在各同事间适当地转发请求以实现协作行为。</p></blockquote><p>中介者模式有以下优点与缺点：</p><blockquote><ul><li>减少了子类的生成：它将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成中介者的子类即可。</li><li>它将各 Colleague 解耦：我们可以独立改变和复用各 Colleague 类和 Mediator 类。</li><li>它简化了对象协议：用 Mediator 和各 Colleague 间的一对多的交互来代替多对多的交互。</li><li>它对对象如何协作进行了抽象：将中介作为一个独立的概念并将其封装在一个对象中，使你讲注意力从对象各自本身的行为转移到它们之间的交互上来。</li><li>它使控制集中化：中介者模式将交互的复杂性变为中介者的复杂性。这可能使得中介者自身成为一个难于维护的庞然大物。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现过程中有以下需要考虑的问题：</p><blockquote><ul><li>忽略抽象的 Mediator 类：当各 Colleague 仅与一个 Mediator 一起工作，没有必要定义一个抽象的 Mediator 类。</li><li>Colleague — Mediator 通信：当一个感兴趣的事件发生的时候，Colleague 必须与其 Mediator 通信。</li></ul></blockquote><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改变的组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  Mediator mediator;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mediator.widgetChanged(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreateColleague</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">  ConcreateColleague colleague;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ConcreateColleague instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDialog</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createWidgets</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">widgetChanged</span><span class="params">(Colleague colleague)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">widgetChanged</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">    colleague.doSth();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Colleague colleague = <span class="keyword">new</span> ConcreateColleague();</span><br><span class="line">    Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">    mediator.widgetChanged(colleague);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关模式：</p><blockquote><ul><li>Facade 模式与中介者欧氏的不同之处在于 Facade 是对一个子系统进行抽象，从而提供了一个更为方便的接口，它的协议是单向的，即 Facade 对象对这个子系统提出请求，反之则不行。</li><li>Colleague 可以使用 Observer 模式和 Mediator 通信。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中介者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探解释器模式</title>
      <link href="/design-pattern/2018-11-20-interpreter/"/>
      <url>/design-pattern/2018-11-20-interpreter/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/interpreter" target="_blank" rel="noopener">koonchen/design-patterns/interpreter</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></blockquote><p>例如现在有一个正则表达式，其中有以下各个符号：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/interpreter-1.jpg" alt="cover"></p><p>其中，符号 <code>expression</code> 是开始符号，<code>literal</code> 是字的终结符。</p><p>解释器使用类来表示每一条文法，它的右边的符号是实例，看上图，根据这些，我们需要五个语法类：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/interpreter-2.jpg" alt="cover"></p><p>假设现在有一个正则表达：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raining &amp; (dogs | cats) *</span><br></pre></td></tr></table></figure><p>它对应的抽象语法树是：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/interpreter-3.jpg" alt="cover"></p><p>解释器模式的适用性：</p><blockquote><ul><li>文法的类层次庞大而且无法管理时。</li><li>效率不是一个关键问题，最搞笑的解释器通常不是通过直接解释语法分析树实现的，而是转换成另一个形式，这种情况下，解释器仍可以用解释器模式来实现。</li></ul></blockquote><p>解释器模式的参与者：</p><blockquote><ul><li>AbstractExpression — 声明一个抽象的解释操作，这个接口为抽象语法树中所有节点所共享</li><li>TerminalExpression — 实现与文法中的终结符相关联的解释操作</li><li>NonterminalExpresson — 对每一条规则进行解释操作，一般用递归表示</li><li>Context — 包含解释器之外的一些全局信息</li><li>Client — 调用解释操作</li></ul></blockquote><p>解释器模式的结构：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/interpreter-4.jpg" alt="cover"></p><p>解释器模式的优缺点：</p><blockquote><ul><li>易于改变和扩展文法</li><li>易于实现文法</li><li>增加新的解释器表达的方式</li><li>复杂的文法难以维护</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现前有一些需要考虑的问题：</p><blockquote><ul><li>抽象语法树：解释器模式并未监视如何创建一个抽象的语法树</li><li>定义解释操作：并不一定要在表达式中定义解释操作</li><li>与 <code>Flyweight</code> 模式共享终结符：一个句子中可能出现多次同一个终结符，最好共享这个符号的单个拷贝，这个节点通常不存储关于它在语法树中的位置信息，任何它们需要的信息都是父节点传递的，存在内部状态和外部状态，所以需要使用 <code>Flyweight</code> 。</li></ul></blockquote><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 存一些全局信息</span></span><br><span class="line">  <span class="keyword">private</span> String name = <span class="string">"Context"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"TerminalExpression instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;AbstractExpression&gt; list = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NonterminalExpression</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;AbstractExpression&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (AbstractExpression expression: list) &#123;</span><br><span class="line">      <span class="keyword">this</span>.list.add(expression);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (AbstractExpression expression: <span class="keyword">this</span>.list) &#123;</span><br><span class="line">        expression.interpret(context);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.name + <span class="string">" instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Context context = <span class="keyword">new</span> Context();</span><br><span class="line">    AbstractExpression aRepetition = <span class="keyword">new</span> NonterminalExpression(<span class="string">"repetition"</span>);</span><br><span class="line">    AbstractExpression dogsLiteral = <span class="keyword">new</span> NonterminalExpression(<span class="string">"dogs"</span>);</span><br><span class="line">    AbstractExpression catsLiteral = <span class="keyword">new</span> NonterminalExpression(<span class="string">"cats"</span>);</span><br><span class="line">    List&lt;AbstractExpression&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(dogsLiteral);</span><br><span class="line">    list.add(catsLiteral);</span><br><span class="line">    ((NonterminalExpression) aRepetition).setList(list);</span><br><span class="line">    aRepetition.interpret(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>NonterminalExpression</code> 实现一个重复表达式的操作，而 <code>Context</code> 和 <code>TerminalExpression</code> 并没有实际作用，但还是能看出这个模式的合理性。</p><p>相关模式</p><blockquote><ul><li>Composite 模式：抽象语法树是一个复合模式的实例</li><li>Flyweight 模式：说明了如何在抽象语法树中共享终结符</li><li>Iterator 模式：解释器可用一个迭代器遍历该结构</li><li>Visitor 模式：可用来在一个类中维护抽象语法树中各个节点的行为</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解释器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探命令模式</title>
      <link href="/design-pattern/2018-11-19-command/"/>
      <url>/design-pattern/2018-11-19-command/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/command" target="_blank" rel="noopener">koonchen/design-patterns/command</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。</p></blockquote><p>这个模式很有意思，直接给一张图先：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/command-1.jpg" alt="cover"></p><p>假设，我们现在有一个工具箱，其中有一些按钮，我们不知道被请求的操作或请求的接收者的信息。</p><p>命令模式通过将请求本身变成一个对象那个来使工具箱对象可向未指定的应用对象提出请求。<strong>这里没有标明的 <code>Command</code> 具体子类中有目标接收者</strong> 。</p><p>比如下面的一个实现：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/command-2.jpg" alt="cover"></p><p>这个例子就比较明显了，<strong>接收者是 <code>document</code> ，这里指定了接收者采取的动作，接收者内部具有执行这个请求的具体信息。</strong></p><p>比较特殊的有打开一个新的文档：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/command-3.jpg" alt="cover"></p><p>它的接收者是 <code>Application</code> ，需要使用的是 <code>Application</code> 的操作。</p><p>还有一种是多个命名的执行：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/command-4.jpg" alt="cover"></p><p>它没有指定接收者，但是每一个指令中都有其具体的接收者。</p><p>指令模式的适用性：</p><blockquote><ul><li>像上面的 <code>MenuItem</code> 那样，抽象出待执行的动作以参数化某对象。有点类似于 <strong>回调</strong> 。</li><li>在不同的时刻指定、排序、执行请求。</li><li>支持取消操作。我们可以在 <code>Command</code> 接口中添加一个 <code>Unexecute</code> 操作，取消上一个 <code>Execute</code> 调用的影响。</li><li>支持修改日志。当系统崩溃的时候，可以将这些修改重做。</li><li>用构建在原语操作上的高层操作系统构造一个系统。一个事务封装了对数据的一组变化，我们可以用同一种方式调用所有的事务，同时该模式也易于添加事务以扩展系统。</li></ul></blockquote><p>指令模式的参与者：</p><blockquote><ul><li>Command — 声明执行操作的接口</li><li>ConcreteCommand — 将一个接收者绑定于一个动作</li><li>Client (Application) — 创建一个具体命名对象并设定它的接收者</li><li>Invoker — 要求改命令执行这个请求</li><li>Receiver — 知道如何实施或执行一个请求相关的操作</li></ul></blockquote><p>指令模式的结构：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/command-5.jpg" alt="cover"></p><p>协作方式：</p><blockquote><ol><li><code>Client</code> 创建爱你一个 <code>ConcreteCommand</code> 对象并指定它的 <code>Receiver</code> 对象</li><li>某 <code>Invoker</code> 对象存储该 <code>ConcreteCommand</code> 对象。</li><li>这里的 <code>Invoker</code> 调用 <code>Command</code> 对象的 <code>execute()</code> 操作来提交一个请求。</li><li>而 <code>ConcreteCommand</code> 通过 <code>Receiver</code> 的操作执行这个请求。</li></ol></blockquote><p>效果：</p><blockquote><ol><li>接收者对象，它真正执行处理该请求的各操作</li><li>接收者上执行操作的参数</li><li>如果处理请求的操作会改变接收者对象的某些值，那么这些值应该先存储起来。</li><li>避免取消操作过程中的错误积累</li></ol></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  Command command = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = command;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"action method has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Receiver receiver = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver.action();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Command command = <span class="keyword">new</span> ConcreteCommand();</span><br><span class="line">    ((ConcreteCommand) command).setReceiver(<span class="keyword">new</span> Receiver());</span><br><span class="line"></span><br><span class="line">    Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">    invoker.setCommand(command);</span><br><span class="line"></span><br><span class="line">    invoker.doSth();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关模式：</p><blockquote><p>Memento 模式可被保持某个状态，命令用这一状态来消除它的效果</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探策略模式</title>
      <link href="/design-pattern/2018-11-11-strategy/"/>
      <url>/design-pattern/2018-11-11-strategy/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/strategy" target="_blank" rel="noopener">koonchen/design-patterns/strategy</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。该模式使得算法可以独立于使用它的客户而变化。</p></blockquote><p>假设我们现在需要对一个正文流进行分行，我们不会把算法硬编码到它们使用的类中，因为：</p><ul><li><p>其一这会使得客户程序变得复杂，变得庞大并且难以维护；</p></li><li><p>其二不同的时候需要使用不同的算法，不使用的代码不需要写进程序里；</p></li><li><p>其三当某个算法是不可分割的一部分的时候，增加新的算法或者改变已有代码是非常困难的。</p></li></ul><p>我们现在可以定义一些类来封装不同的换行算法，从而避免这些问题。一个以这种方法封装的算法称为一个策略：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/strategy-1.jpg" alt="cover"></p><p>思想很简单，实现也很简单，但组合在一起就变成了策略模式。</p><p>策略模式的适用性：</p><blockquote><ul><li>许多相关的类仅仅是行为有异。策略提供了一种用多个行为中的一个行为来配置一个类的方法。</li><li>需要使用一个算法的不同变体。例如，我们可能会定义一些反映不同的空间 / 时间权衡的算法。</li><li>算法使用客户不应该知道的数据。使用策略模式可以避免暴露复杂的、与算法相关的数据结构。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。</li></ul></blockquote><p>策略模式的参与者：</p><blockquote><ul><li>Strategy — 定义所有支持的算法的公共接口。</li><li>ConcreteStrategy — 以 Strategy 实现的具体算法。</li><li>Context — 维护一个对 Strategy 对象的引用，可以定义一个接口来让 Strategy 来访问它的数据。</li></ul></blockquote><p>该模式的结构：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/strategy-2.jpg" alt="cover"></p><p>我们通过 <code>Context</code> 和 <code>Strategy</code> 的相互作用以实现选定的算法，当算法被调用， <code>Context</code> 可以将该算法所需要的所有数据都传递给该 <code>Strategy</code> ，或者， <code>Context</code> 可以将自身作为一个参数传递给 <code>Strategy</code> 操作。这就让 <code>Strategy</code> 在需要的时候可以回调 <code>Context</code> 。</p><p><code>Context</code> 将它的客户的请求转发给它的 <code>Stratege</code> 。客户通常创建并传递一个 <code>ConcreteStrategy</code> 对象给该 <code>Context</code> ，这样客户仅与 <code>Context</code> 进行交互。</p><p>策略模式的优缺点：</p><blockquote><ul><li>该模式提供了相关算法系列的模式。 <code>Strategy</code> 类层次为 <code>Context</code> 定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。</li><li>这是一个替代继承的方法。继承提供了另外一种支持多种算法或行为的方法。我们可以直接生成一个 <code>Context</code> 类的子类，从而给它以不同的行为。但是继承是一种硬编码行为，这将使得 <code>Context</code> 变得难以理解、难以维护，最后我们会得到一堆相关的类，它们唯一的差别仅仅是它们所使用的算法或行为。</li><li>消除了一些条件语句。 <code>Strategy</code> 模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一起的时候，很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的 <code>Strategy</code> 类中消除了这些条件语句。</li><li>对实现提供选择。该模式可以提供相同行为的不同实现，客户可以根据不同时间 / 空间的抉择来选择不同的策略。</li><li>缺点也有，比如客户必须了解不同的策略。客户选择一个合适的策略就必须要知道这些策略到底有何不同，此时可能不得不向客户暴露具体的实现。</li><li>通信开销。无论是各个 <code>ConcreteStrategy</code> 实现的算法是简单还是复杂，它们都共享 <code>Strategy</code> 定义的接口，因此可能某些 <code>ConcreteStrategy</code> 不会都用到所有通过这个接口传递给它们的信息，简单的实现可能不要使用到其中的任何信息，这就意味着有些通信是浪费的，耦合度还是略高。</li><li>增加了对象的数目。策略模式增加了一个应用中的对象的数目，有时候你可以将 <code>Strategy</code> 实现为可供各个 <code>Context</code> 共享的无状态的对象来减少这一开销。任何其余的状态都由 <code>Context</code> 来维护。因为共享的 <code>Strategy</code> 不应该在各名词调用之间维护状态。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Compositor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">compose</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCompositor</span> <span class="keyword">implements</span> <span class="title">Compositor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"SimpleCompositor instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeXCompositor</span> <span class="keyword">implements</span> <span class="title">Compositor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"TeXCompositor instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayCompositor</span> <span class="keyword">implements</span> <span class="title">Compositor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ArrayCompositor instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Compositor compositor;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Composition</span><span class="params">(Compositor compositor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.compositor = compositor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    compositor.compose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Composition composition = <span class="keyword">new</span> Composition(<span class="keyword">new</span> SimpleCompositor());</span><br><span class="line">    composition.repair();</span><br><span class="line">    composition = <span class="keyword">new</span> Composition(<span class="keyword">new</span> TeXCompositor());</span><br><span class="line">    composition.repair();</span><br><span class="line">    composition = <span class="keyword">new</span> Composition(<span class="keyword">new</span> ArrayCompositor());</span><br><span class="line">    composition.repair();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把专业的事情交给专业的人，可能就是策略模式想告诉我们的。</p><p>相关模式</p><ul><li>Flyweight — 策略对象经常是很好的轻量级对象。</li></ul><blockquote><p>一看，确实享元模式和策略上是大同小异的，该书推荐我们用策略模式的对象到享元模式中，可以说它们是相辅相成的，享元模式就是在策略模式外面包一层对象，更好地处理策略对象。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tiny spring 笔记</title>
      <link href="/note/2018-11-08-tiny-spring-notes/"/>
      <url>/note/2018-11-08-tiny-spring-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="tiny-spring-ioc"><a href="#tiny-spring-ioc" class="headerlink" title="tiny spring ioc"></a>tiny spring ioc</h1><p>看到这个项目的第一反应仅仅是好玩，所以看看它到底能不能让我搞懂 spring …</p><p>该项目中共包含以下 10 个标签。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">step-1-container-register-and-get</span><br><span class="line">step-2-abstract-beanfactory-and-do-bean-initilizing-in-it</span><br><span class="line">step-3-inject-bean-with-property</span><br><span class="line">step-4-config-beanfactory-with-xml</span><br><span class="line">step-5-inject-bean-to-bean</span><br><span class="line">step-6-invite-application-context</span><br><span class="line">step-7-method-interceptor-by-jdk-dynamic-proxy</span><br><span class="line">step-8-invite-pointcut-and-aspectj</span><br><span class="line">step-9-auto-create-aop-proxy</span><br><span class="line">step-10-invite-cglib-and-aopproxy-factory</span><br></pre></td></tr></table></figure><h2 id="step-1-container-register-and-get"><a href="#step-1-container-register-and-get" class="headerlink" title="step-1-container-register-and-get"></a>step-1-container-register-and-get</h2><p>从名字知道大概是说容器、注册机，从 <code>Bean</code> 开始，我们创建一个初始的 <code>Bean</code> 对象 ( <code>BeanDefinition</code> )：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinition</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 spring 中，我们需要一个 IoC 容器，我们创建一个工厂来保存 Bean ，这里命名 <code>BeanFactory</code>  :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.get(name).getBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是一个比较普通的工厂方法模式，我比较关注的反而是 <code>ConcurrentHashMap</code> ，这个对象在原子性上是线程安全的，但是如果是复合操作的话，可能导致线程不安全，当我们简单对方法加上 <code>synchronized</code> 关键字，这也会出现问题。</p><p>因为 <code>synchronized</code> 关键字其本质都是锁定某一个对象，修饰方法的时候，锁上的是调用这个方法的对象，即 this ；修饰代码块的时候，锁上的是代码块里的对象。</p><p>但是如果我们对 <code>Map</code> 对象加上锁的话， <code>ConcurrentHashMap</code> 对象的作用就大了。</p><p>PS: 最后特别补充的是， <code>synchronized</code> 关键字判断对象是否是它属于锁定的对象，本质上是通过 == 运算符来判断的。换句话说，上面的代码中，可以采用任何一个常量，或者每个线程都共享的变量，或者类的静态变量，来代替 <code>Map</code> 。只要该变量与 <code>synchronized</code> 锁定的目标变量相同（==），就可以使 <code>synchronized</code> 生效。</p></blockquote><p>值得注意的是，这里的 <code>BeanDefinition</code> 的构造器中使用的是 <code>Object</code> 对象，这方便我们创建真正的 <code>Bean</code> 对象的时候不用在意它的类型，这里我们创建一个需要使用的 <code>Service</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体测试这个 <code>Service</code> 的时候我们创建一个响应的 <code>Test</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始化beanfactory</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> BeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.注入bean</span></span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition(<span class="keyword">new</span> HelloWorldService());</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">"helloWorldService"</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取bean</span></span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个测试程序发生了什么呢？</p><blockquote><p>首先初始化一个 <code>Bean</code> 工厂；初始化一个具体的 <code>Bean</code> ，这里面包装一个需要工作的具体 <code>Service</code> ；把这个 <code>Service</code> 放到工厂里，比如用一个 <code>Map</code> 来存放，使用的使用，可以直接通过 <code>key</code> 取出这个具体的 <code>Bean</code> ，取出具体的 <code>Service</code> ，然后执行具体的 <code>Service</code> 方法。</p></blockquote><h2 id="step-2-abstract-beanfactory-and-do-bean-initilizing-in-it"><a href="#step-2-abstract-beanfactory-and-do-bean-initilizing-in-it" class="headerlink" title="step-2-abstract-beanfactory-and-do-bean-initilizing-in-it"></a>step-2-abstract-beanfactory-and-do-bean-initilizing-in-it</h2><p>题目取名叫做抽象工厂和 <code>Bean</code> 的初始化，回忆一下，工厂方法模式是为了创造一个系列，而抽象工厂模式是为了创造多个系列，这也是这里分层出一个具体 <code>Factory</code> 原因。</p><p>首先我们还是先创造一个 <code>Bean</code> 的外壳：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class beanClass;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String beanClassName;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bean = bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class <span class="title">getBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanClass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClass</span><span class="params">(Class beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getBeanClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanClassName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanClassName = beanClassName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanClass = Class.forName(beanClassName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的区别在于，这里增加了对内部 <code>Bean</code> 的实例化。</p><p>最外层是一个工厂接口 <code>BeanFactory</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是一个基础的实现 <code>AbstractBeanFactory</code> ，这里是基本方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitionMap.get(name).getBean();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        Object bean = doCreateBean(beanDefinition);</span><br><span class="line">        beanDefinition.setBean(bean);</span><br><span class="line">        beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是之前的工厂，它增加一个未实行的方法，用来具体产生 <code>Bean</code> ，最外层我们再包装一层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object bean = beanDefinition.getBeanClass().newInstance();</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的时候，创建一个具体的 <code>Service</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体测试的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始化beanfactory</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> AutowireCapableBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.注入bean</span></span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClassName(<span class="string">"cool.koon.step2.HelloWorldService"</span>);</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">"helloWorldService"</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取bean</span></span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的差别在于，不再是我们手动创建具体的 <code>Bean</code> 对象，而是在外层对象中根据反射实例化对象。</p><h2 id="step-3-inject-bean-with-property"><a href="#step-3-inject-bean-with-property" class="headerlink" title="step-3-inject-bean-with-property"></a>step-3-inject-bean-with-property</h2><p>这一章中是将属性注入到 <code>Bean</code> 中，此前我们仅仅是创建一个 <code>Bean</code> ，现在我们可以将具体的属性也实例化。</p><p>从属性对象开始创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及属性对象的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValueList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValues</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPropertyValue</span><span class="params">(PropertyValue pv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span>这里可以对于重复propertyName进行判断，直接用list没法做到</span></span><br><span class="line">        <span class="keyword">this</span>.propertyValueList.add(pv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PropertyValue&gt; <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertyValueList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的 <code>Bean</code> 需要包含属性对象的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class beanClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String beanClassName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClass</span><span class="params">(Class beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClassName = beanClassName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanClass = Class.forName(beanClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues propertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValues = propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bean</code> 工厂还是使用抽象工厂模式创建，首先是最外层的工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是创建抽象类，完成一部分的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.get(name).getBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object bean = doCreateBean(beanDefinition);</span><br><span class="line">        beanDefinition.setBean(bean);</span><br><span class="line">        beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是具体的工厂类，除了实现上面我们定义的 <code>doCreateBean</code> 方法，我们还需要指定属性对象的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 先创建一个对象</span></span><br><span class="line">        Object bean = createBeanInstance(beanDefinition);</span><br><span class="line">        <span class="comment">// 然后加入其中的属性</span></span><br><span class="line">        applyPropertyValues(bean, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createBeanInstance</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 之前这是直接写进 doCreateBean 里的</span></span><br><span class="line">        <span class="comment">// 没有差别，只是写成了一个方法</span></span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getBeanClass().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition mbd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : mbd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">            Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">            declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            declaredField.set(bean, propertyValue.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的时候先指定确定的 <code>Service</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们开始测试我们现在的抽象工厂，这里我们还需要创建属性的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.初始化beanfactory</span></span><br><span class="line">    BeanFactory beanFactory = <span class="keyword">new</span> AutowireCapableBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.bean定义</span></span><br><span class="line">    BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">    beanDefinition.setBeanClassName(<span class="string">"cool.koon.step3.HelloWorldService"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置属性</span></span><br><span class="line">    PropertyValues propertyValues = <span class="keyword">new</span> PropertyValues();</span><br><span class="line">    propertyValues.addPropertyValue(<span class="keyword">new</span> PropertyValue(<span class="string">"text"</span>, <span class="string">"Hello World!"</span>));</span><br><span class="line">        beanDefinition.setPropertyValues(propertyValues);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.生成bean</span></span><br><span class="line">    beanFactory.registerBeanDefinition(<span class="string">"helloWorldService"</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.获取bean</span></span><br><span class="line">    HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">    helloWorldService.helloWorld();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体基调还是一个抽象工厂。</p><blockquote><p>这里使用 <code>Field</code> 来设置属性，实际中我们都会使用 setter 等方法。</p><p><code>Field</code> 对象就代替了属性的地位，直接对它设置值就可以进行属性赋值。</p></blockquote><h2 id="step-4-config-beanfactory-with-xml"><a href="#step-4-config-beanfactory-with-xml" class="headerlink" title="step-4-config-beanfactory-with-xml"></a>step-4-config-beanfactory-with-xml</h2><p>根据题目的意思我们开始使用 <code>xml</code> 来配置工厂，来看一看吧。</p><p>首先老样子，我们创建一个 <code>Bean</code> 的包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class beanClass;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String beanClassName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> PropertyValues propertyValues = <span class="keyword">new</span> PropertyValues();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bean = bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class <span class="title">getBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanClass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClass</span><span class="params">(Class beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getBeanClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanClassName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanClassName = beanClassName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanClass = Class.forName(beanClassName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> propertyValues;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues propertyValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.propertyValues = propertyValues;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还需要创建属性类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有属性列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValues</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValueList = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPropertyValue</span><span class="params">(PropertyValue pv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span>这里可以对于重复propertyName进行判断，直接用list没法做到</span></span><br><span class="line">    <span class="keyword">this</span>.propertyValueList.add(pv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;PropertyValue&gt; <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertyValueList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来到 <code>io</code> 包，首先创建一个 <code>Resource</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对它继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlResource</span> <span class="keyword">implements</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrlResource</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URLConnection urlConnection = url.openConnection();</span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        <span class="keyword">return</span> urlConnection.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较直接，开启一个 <code>url</code> ，连接后获得一个字节流。</p><p>再来一个类来获得这个 <code>UrlResource</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span></span>&#123;</span><br><span class="line">        URL resource = <span class="keyword">this</span>.getClass().getClassLoader().getResource(location);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在使用抽象工厂的形式，我们创建一个接口，以及一个部分实现的阅读器，最后是一个 <code>xml</code> 的读取器。首先是一个 <code>Bean</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,BeanDefinition&gt; registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registry = <span class="keyword">new</span> HashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, BeanDefinition&gt; <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后 <code>xml</code> 包里实现一个 <code>XmlBeanDefinitionReader</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream inputStream = getResourceLoader().getResource(location).getInputStream();</span><br><span class="line">        doLoadBeanDefinitions(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder docBuilder = factory.newDocumentBuilder();</span><br><span class="line">        Document doc = docBuilder.parse(inputStream);</span><br><span class="line">        <span class="comment">// 解析bean</span></span><br><span class="line">        registerBeanDefinitions(doc);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从根节点开始解析</span></span><br><span class="line">        Element root = doc.getDocumentElement();</span><br><span class="line">        parseBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不需要太了解它是怎么解析这个 <code>xml</code> 的，只要知道它达到的效果是从中取出属性并赋值。</p><p>下面是工厂的搭建，从工厂的接口开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个抽象类来部分实现这个工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.get(name).getBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object bean = doCreateBean(beanDefinition);</span><br><span class="line">        beanDefinition.setBean(bean);</span><br><span class="line">        beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老样子，最后创建一个具体的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object bean = createBeanInstance(beanDefinition);</span><br><span class="line">        applyPropertyValues(bean, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createBeanInstance</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getBeanClass().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition mbd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : mbd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">            Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">            declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            declaredField.set(bean, propertyValue.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始实现测试类。</p><p>老样子创建一个 <code>Service</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们创建一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.读取配置</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">        xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.初始化BeanFactory并注册bean</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> AutowireCapableBeanFactory();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取bean</span></span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要以为这里用了两个抽象工厂，这个方式就变复杂了，仅仅看似复杂，实际上非常普通，仅仅是从手动输入各个属性到现在从 <code>xml</code> 中读取属性。</p><h2 id="step-5-inject-bean-to-bean"><a href="#step-5-inject-bean-to-bean" class="headerlink" title="step-5-inject-bean-to-bean"></a>step-5-inject-bean-to-bean</h2><p>这一章节使用的是指在 <code>Bean</code> 中注入 <code>Bean</code> ，我们来看看它的实现。</p><p>这里，我们连接上一个项目，在其上直接进行修改。</p><p>首先，我们需要定义一个类作为 <code>Bean</code> 的注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanReference</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它作为另外一个 <code>Bean</code> 被注入到一个 <code>Bean</code> 中，具体操作在 <code>XmlBeanDefinitionReader</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream inputStream = getResourceLoader().getResource(location).getInputStream();</span><br><span class="line">        doLoadBeanDefinitions(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder docBuilder = factory.newDocumentBuilder();</span><br><span class="line">        Document doc = docBuilder.parse(inputStream);</span><br><span class="line">        <span class="comment">// 解析bean</span></span><br><span class="line">        registerBeanDefinitions(doc);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从根节点开始解析</span></span><br><span class="line">        Element root = doc.getDocumentElement();</span><br><span class="line">        parseBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                processBeanDefinition(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        String name = ele.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">        String className = ele.getAttribute(<span class="string">"class"</span>);</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        processProperty(ele,beanDefinition);</span><br><span class="line">        beanDefinition.setBeanClassName(className);</span><br><span class="line">        getRegistry().put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processProperty</span><span class="params">(Element ele,BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        NodeList propertyNode = ele.getElementsByTagName(<span class="string">"property"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i++) &#123;</span><br><span class="line">            Node node = propertyNode.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element propertyEle = (Element) node;</span><br><span class="line">                String name = propertyEle.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">                String value = propertyEle.getAttribute(<span class="string">"value"</span>);</span><br><span class="line">                <span class="comment">// step5 add</span></span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = propertyEle.getAttribute(<span class="string">"ref"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Configuration problem: &lt;property&gt; element for property '"</span> + name + <span class="string">"' must specify a ref or value"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// step5 add end</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是将 <code>xml</code> 的内容读取，在 <code>Bean</code> 工厂中，我们具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object bean = createBeanInstance(beanDefinition);</span><br><span class="line">        applyPropertyValues(bean, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createBeanInstance</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getBeanClass().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition mbd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : mbd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">            Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">            declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// step5 add</span></span><br><span class="line">            Object value = propertyValue.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanReference) &#123;</span><br><span class="line">                BeanReference beanReference = (BeanReference) value;</span><br><span class="line">                value = getBean(beanReference.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// step5 add end</span></span><br><span class="line">            declaredField.set(bean, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是主要修改的地方，另外因为现在我们的 <code>Bean</code> 包装中不止一种类了，所以还有一些小细节需要修改，比如每次手动确认 <code>Bean</code> 里的内容，如果 <code>Bean</code> 没有创建，我们需要再创建。</p><p>我们现在在 <code>AbstractBeanFactory</code> 中创建一个方法 <code>getBean</code> 用来实例化 <code>Bean</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 现在我们的 BeanFactory 不仅仅包装一个 Service 可以包装多种</span></span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitionMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No bean named "</span> + name + <span class="string">" is defined"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = beanDefinition.getBean();</span><br><span class="line">        <span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bean = doCreateBean(beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">        beanDefinitionNames.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator it = <span class="keyword">this</span>.beanDefinitionNames.iterator(); it.hasNext();) &#123;</span><br><span class="line">            String beanName = (String) it.next();</span><br><span class="line">            getBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们进入测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLazy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.读取配置</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">        xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.初始化BeanFactory并注册bean</span></span><br><span class="line">        AbstractBeanFactory beanFactory = <span class="keyword">new</span> AutowireCapableBeanFactory();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 现在我们不在注册的地方进行实例化，而是在 getBean 方法里实例化，完成懒加载</span></span><br><span class="line">            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取bean</span></span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPreInstantiate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.读取配置</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">        xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.初始化BeanFactory并注册bean</span></span><br><span class="line">        AbstractBeanFactory beanFactory = <span class="keyword">new</span> AutowireCapableBeanFactory();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.初始化bean</span></span><br><span class="line">        beanFactory.preInstantiateSingletons();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.获取bean</span></span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>OutputService</code> 是另外一个 <code>Bean</code> 也是被注入的 <code>Bean</code> ，实现的时候需要注意哪个 <code>Bean</code> 属于哪个即可。</p><h2 id="step-6-invite-application-context"><a href="#step-6-invite-application-context" class="headerlink" title="step-6-invite-application-context"></a>step-6-invite-application-context</h2><p>终于来到了 <code>IoC</code> 实现的最后一章，这里 <code>ApplicationContext</code> 终于登场了。</p><p>我们把上面这些 <code>xml</code> 读取到属性插入的代码进行封装，这些组成代码现在是 <code>Application</code> 的部分，它也采用一个抽象工厂模式，分别是一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个接口继承自抽象工厂的接口，它这样写也是为了更好地传入参数，然后我们对它进行部分实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> AbstractBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(AbstractBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是一个具体的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String configLocation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(configLocation, <span class="keyword">new</span> AutowireCapableBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation, AbstractBeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.configLocation = configLocation;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">        xmlBeanDefinitionReader.loadBeanDefinitions(configLocation);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry: xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>refresh</code> 方法中进行具体的实现，这里我们进行配置的读取，属性的注册等操作，等于在复现之前的测试方法。</p><p>现在测试方法就极端简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的 <code>IoC</code> 通过几个简单的抽象工厂就完成了。</p><h1 id="tiny-spring-aop"><a href="#tiny-spring-aop" class="headerlink" title="tiny spring aop"></a>tiny spring aop</h1><h2 id="step-7-method-interceptor-by-jdk-dynamic-proxy"><a href="#step-7-method-interceptor-by-jdk-dynamic-proxy" class="headerlink" title="step-7-method-interceptor-by-jdk-dynamic-proxy"></a>step-7-method-interceptor-by-jdk-dynamic-proxy</h2><p>这么快我们 <code>IoC</code> 就看完了，非常有意思，下面开始了 <code>AOP</code> 的学习，我们知道在 <code>AOP</code> 中分为配置和织入两部分，当然还有一部分是将 <code>AOP</code> 整合到整个容器的生命周期中。</p><p>三个点，一个被代理对象，一个拦截器，一个代理者，被代理对象被包装成一个 <code>AdvisedSupport</code> 其中包含我们具体的拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含拦截器的具体对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应拦截器</span></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TargetSource <span class="title">getTargetSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> targetSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截器里包裹了具体的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetSource</span><span class="params">(TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetSource = targetSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getMethodInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodInterceptor</span><span class="params">(MethodInterceptor methodInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们实现一个具体拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拦截后调用方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"Invocation of Method "</span> + methodInvocation.getMethod().getName() + <span class="string">" start!"</span>);</span><br><span class="line"></span><br><span class="line">        Object proceed = methodInvocation.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Invocation of Method "</span> + methodInvocation.getMethod().getName() + <span class="string">" end! takes "</span> + (System.nanoTime() - time) + <span class="string">" nanoseconds"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着，是一个代理者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = advised;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(getClass().getClassLoader(), <span class="keyword">new</span> Class[] &#123; advised.getTargetSource().getTargetClass() &#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 拦截器进行拦截</span></span><br><span class="line">        MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">        <span class="comment">// 调用器开始调用方法</span></span><br><span class="line">        <span class="comment">// 从这里调用具体的拦截器方法</span></span><br><span class="line">        <span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">new</span> ReflectiveMethodInvocation(advised.getTargetSource().getTarget(), method, args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是比较好理解的一个 <code>AOP</code> 小例子。</p><h2 id="step-8-invite-pointcut-and-aspectj"><a href="#step-8-invite-pointcut-and-aspectj" class="headerlink" title="step-8-invite-pointcut-and-aspectj"></a>step-8-invite-pointcut-and-aspectj</h2><p>来到第 8 章，我们开始考虑一个问题，那就是什么时候进行 <code>AOP</code> ？对于这个问题，我们叫做 <code>Pointcut</code> ，在 <code>Spring</code> 的 <code>Pointcut</code> 中包含两个角色： <code>ClassFilter</code> 和 <code>MethodMatcher</code> ，分别是对类和方法做匹配，比较通用的方式是使用 <code>AspectJ</code> 表达式，但是为此我们需要学习一门语言又得不偿失，我们怎么做呢？</p><p>首先从两个接口开始，分别用来匹配类和方法，多实现在一个类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJExpressionPointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span>, <span class="title">ClassFilter</span>, <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PointcutParser pointcutParser;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String expression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PointcutExpression pointcutExpression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;PointcutPrimitive&gt; DEFAULT_SUPPORTED_PRIMITIVES = <span class="keyword">new</span> HashSet&lt;PointcutPrimitive&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.EXECUTION);</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.ARGS);</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.REFERENCE);</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.THIS);</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.TARGET);</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.WITHIN);</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ANNOTATION);</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_WITHIN);</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ARGS);</span><br><span class="line">        DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_TARGET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AspectJExpressionPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SUPPORTED_PRIMITIVES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AspectJExpressionPointcut</span><span class="params">(Set&lt;PointcutPrimitive&gt; supportedPrimitives)</span> </span>&#123;</span><br><span class="line">        pointcutParser = PointcutParser</span><br><span class="line">                .getPointcutParserSupportingSpecifiedPrimitivesAndUsingContextClassloaderForResolution(supportedPrimitives);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkReadyToMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pointcutExpression == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pointcutExpression = buildPointcutExpression();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PointcutExpression <span class="title">buildPointcutExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pointcutParser.parsePointcutExpression(expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExpression</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expression = expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">        checkReadyToMatch();</span><br><span class="line">        <span class="keyword">return</span> pointcutExpression.couldMatchJoinPointsInType(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;</span><br><span class="line">        checkReadyToMatch();</span><br><span class="line">        ShadowMatch shadowMatch = pointcutExpression.matchesMethodExecution(method);</span><br><span class="line">        <span class="keyword">if</span> (shadowMatch.alwaysMatches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shadowMatch.neverMatches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>其他情况不判断了！见org.springframework.aop.aspectj.RuntimeTestWalker</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中用匹配的方式来切：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJExpressPointcutTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类的切入</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String expression = <span class="string">"execution(* cool.koon.step4to6.*.*(..))"</span>;</span><br><span class="line">        AspectJExpressionPointcut aspectJExpressionPointcut = <span class="keyword">new</span> AspectJExpressionPointcut();</span><br><span class="line">        aspectJExpressionPointcut.setExpression(expression);</span><br><span class="line">        <span class="keyword">boolean</span> matches = aspectJExpressionPointcut.getClassFilter().matches(HelloWorldService.class);</span><br><span class="line">        Assert.assertTrue(matches);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法的切入</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodInterceptor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String expression = <span class="string">"execution(* cool.koon.step4to6.*.*(..))"</span>;</span><br><span class="line">        AspectJExpressionPointcut aspectJExpressionPointcut = <span class="keyword">new</span> AspectJExpressionPointcut();</span><br><span class="line">        aspectJExpressionPointcut.setExpression(expression);</span><br><span class="line">        <span class="keyword">boolean</span> matches = aspectJExpressionPointcut.getMethodMatcher().matches(HelloWorldServiceImpl.class.getDeclaredMethod(<span class="string">"helloWorld"</span>),HelloWorldServiceImpl.class);</span><br><span class="line">        Assert.assertTrue(matches);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单讲，这一章给我们一个便捷切面的方式，使用正则，指定类或者方法来进行 <code>AOP</code> 。</p><h2 id="step-9-auto-create-aop-proxy"><a href="#step-9-auto-create-aop-proxy" class="headerlink" title="step-9-auto-create-aop-proxy"></a>step-9-auto-create-aop-proxy</h2><p>这里，我们已经拥有了 <code>Pointcut</code> 一个 <code>AOP</code> 已经完成，但是我们还没有结合到 <code>Spring</code> 中，现在我们给出一个答案 <code>BeanPostProcessor</code> ，它是 <code>BeanFactory</code> 提供的，在 <code>Bean</code> 继续初始化的过程中进行扩展。</p><p>核心点在于 <code>AspectJAwareAdvisorAutoProxyCreator</code> 这个类的 <code>Spring</code> 初始化的时候，会优先找到它们，并且在 <code>Bean</code> 初始化的过程中，调用这个接口，从而实现对 <code>Spring</code> 工厂的无侵入的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AbstractBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> AspectJExpressionPointcutAdvisor) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    List&lt;AspectJExpressionPointcutAdvisor&gt; advisors = beanFactory</span><br><span class="line">        .getBeansForType(AspectJExpressionPointcutAdvisor.class);</span><br><span class="line">    <span class="keyword">for</span> (AspectJExpressionPointcutAdvisor advisor : advisors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (advisor.getPointcut().getClassFilter().matches(bean.getClass())) &#123;</span><br><span class="line">        AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">        advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());</span><br><span class="line">        advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());</span><br><span class="line"></span><br><span class="line">        TargetSource targetSource = <span class="keyword">new</span> TargetSource(bean, bean.getClass().getInterfaces());</span><br><span class="line">        advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(advisedSupport).getProxy();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = (AbstractBeanFactory) beanFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种说法是 —— <code>BeanPostProcessor</code> ：在 <code>postProcessorAfterInitialization</code> 方法中，使用动态代理的方式，返回一个对象的代理对象。解决了在 <code>IoC</code> 容器的何处植入 <code>AOP</code> 的问题。</p><p><code>BeanFactoryAware</code> ：这个接口提供了对 <code>BeanFactory</code> 的感知，这样，尽管它是容器中的一个 <code>Bean</code> ，却可以获取容器的引用，进而获取容器中所有的切点对象，决定对哪些对象的哪些方法进行代理。解决了为哪些对象提供 <code>AOP</code> 的植入的问题。</p><p>但是只能说有一定的道理。</p><h2 id="step-10-invite-cglib-and-aopproxy-factory"><a href="#step-10-invite-cglib-and-aopproxy-factory" class="headerlink" title="step-10-invite-cglib-and-aopproxy-factory"></a>step-10-invite-cglib-and-aopproxy-factory</h2><p>最后了，我们现在只能对接口进行代理，对于类却无能为力，这里我们需要一些字节码的操作，使用 <code>CGLib</code> ，或者应该说是 <code>jvm</code> 动态擦除的历史遗留问题。</p><hr><p>这个项目像是介绍性质地给我们看了看 <code>IoC</code> 和 <code>AOP</code> 的部分妙用，果然受益良多，最后实在不想重复劳作了，把 step4 到 step10 写到了一起。</p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
            <tag> ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础常见问题</title>
      <link href="/technology/2018-11-01-java-basic/"/>
      <url>/technology/2018-11-01-java-basic/</url>
      
        <content type="html"><![CDATA[<p>这里我简单记录我认为比较重要的点。</p><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-“Java-语言中的方法属于类中的成员”-为什么不对？"><a href="#1-1-“Java-语言中的方法属于类中的成员”-为什么不对？" class="headerlink" title="1.1 “Java 语言中的方法属于类中的成员” 为什么不对？"></a>1.1 “<code>Java</code> 语言中的方法属于类中的成员” 为什么不对？</h3><p>类成员需要是静态的，而方法可能是静态方法，也可能是非静态方法。静态方法是类成员，非静态方法是实例成员。</p><h3 id="1-2-什么是反射机制？"><a href="#1-2-什么是反射机制？" class="headerlink" title="1.2 什么是反射机制？"></a>1.2 什么是反射机制？</h3><p>反射机制允许程序在运行时进行自我检查，同时也允许对其内部的成员进行操作，反射的主要功能有：得到一个对象所属的类；获取一个类的所有成员变量和方法；在运行时创建对象；在运行时创建对象的方法。</p><h3 id="1-3-Java-如何实现函数指针？"><a href="#1-3-Java-如何实现函数指针？" class="headerlink" title="1.3 Java 如何实现函数指针？"></a>1.3 <code>Java</code> 如何实现函数指针？</h3><p><code>Java</code> 没有指针的概念，如何能让 <code>Java</code> 实现类似函数指针的功能？用接口作为函数的参数，把参数实现传进去进行调用即可。</p><h2 id="2-面向对象技术"><a href="#2-面向对象技术" class="headerlink" title="2. 面向对象技术"></a>2. 面向对象技术</h2><h3 id="2-1-面向对象与面向过程的区别？"><a href="#2-1-面向对象与面向过程的区别？" class="headerlink" title="2.1 面向对象与面向过程的区别？"></a>2.1 面向对象与面向过程的区别？</h3><ul><li>出发点不同，面向对象方法是用符合常规思维的方式来处理客观世界的问题，强调把问题域的要领直接映射到对象及对象之间的接口上；面向对象强调是过程的抽象化和模块化。</li><li>层级逻辑关系不同，面向对象方法则是用计算机逻辑来模拟客观世界的物理存在，以对象的集合类作为处理问题的基本单元；而面向过程的基本单元是能清晰表达过程的模块，用模块的层次结构概括模块或模块间的关系或功能。</li><li>数据处理方式与控制程序方式不同，面向对象将数据和对应的代码封装成一个整体，是“事件驱动”来激活和运行程序的；而面向过程是直接通过程序来处理数据，处理完毕即可显示处理结果，各个模块之间可能存在控制、被控制，调用、被调用的关系。</li><li>分析代码与编码转换的方式不同，面向对象贯穿软件声明周期的分析、设计、编码，是一种平滑的过程，是一种无缝连接；面向过程强调分析、设计、编码之间按规则进行转换，是一种有缝的连接。</li></ul><h3 id="2-2-面向对象的特征？"><a href="#2-2-面向对象的特征？" class="headerlink" title="2.2 面向对象的特征？"></a>2.2 面向对象的特征？</h3><p>这是一个老生常谈的问题：抽象、继承、封装、多态。</p><ul><li>抽象：忽略一个主题中与当前目标无关的部分。最直接的就是 <code>abstract</code> 类。</li><li>继承：联结类的一种层次模型，允许和鼓励类的重用，它提供了一种明确的表述共性的方法。</li><li>封装：将客观事物抽象成类，每个类对自身的数据和方法实行保护。</li><li><p>多态：允许不同类的对象那个对同一消息进行响应。</p><h3 id="2-3-多态的两种实现机制？"><a href="#2-3-多态的两种实现机制？" class="headerlink" title="2.3 多态的两种实现机制？"></a>2.3 多态的两种实现机制？</h3></li></ul><p>多态是面向对象中一个重要机制，它表示当同一个操作在不同的类的对象中具有不同的语义，主要有两种不同的表现方式：</p><ul><li>重载 <code>overload</code> ：同一个类中有多个同名的方法。 <strong>不能通过访问权限来区分，这样会报错，如果基类是 <code>private</code> 那么派生类中的同名方法不是重载，而是一个新的方法。</strong></li><li>覆盖 <code>override</code> ：子类覆盖父类中的方法。 <strong>覆盖的方法不能是 <code>private</code> ，异常抛出也要是一致的，同时如果要覆盖的方法被定义为 <code>final</code> 与 <code>native</code> 那么也是不能覆盖的。</strong></li></ul><h3 id="2-4-抽象类和接口的区别？"><a href="#2-4-抽象类和接口的区别？" class="headerlink" title="2.4 抽象类和接口的区别？"></a>2.4 抽象类和接口的区别？</h3><ul><li>它们都不能被实例化。</li><li>接口的实现类和抽象类的子类都只有实现了方法后才能被实例化。</li><li>接口中只有定义，其方法不能在接口中实现，抽象类有定义与实现。</li><li>接口被实现 <code>implements</code> ，抽象类被继承 <code>extends</code> 。</li><li>接口强调特定功能的实现，理念是 “has - a” 关系；抽象类强调所属广西，理念是 “is - a” 关系。</li><li>接口中默认的成员变量是 <code>public static final</code> ，其所有成员变量都是 <code>public</code> 、 <code>abstract</code> 的，并且只能被这两个关键字修饰；而抽象类中可以有自己的数据成员变量。 <strong>当功能需要累计时，用抽象类；不需要累计时，用接口。</strong></li><li>接口被运用到实际中比较偏向常用的功能；抽象类更倾向于充当公共类的角色。</li></ul><h3 id="2-5-内部类有哪些？"><a href="#2-5-内部类有哪些？" class="headerlink" title="2.5 内部类有哪些？"></a>2.5 内部类有哪些？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">outerClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">innerClass</span></span>&#123;&#125; <span class="comment">// 静态内部类</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">innerClass2</span></span>&#123;&#125; <span class="comment">// 成员内部类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">innerClass</span></span>&#123;&#125; <span class="comment">// 局部内部类</span></span><br><span class="line">    addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123; <span class="comment">// 匿名内部类</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态内部类：带有 <code>static</code> 的内部类，<strong>它可以不依赖于外部类实例而被实例化</strong>，静态内部类不能与外部类有相同的名字，<strong>不能访问外部类的普通成员变量，只能访问外部类中的静态成员和静态方法（包括私有类型）</strong>。</li><li>成员内部类：去掉 <code>static</code> 关键字的静态内部类，<strong>它可以自由地引用外部类的属性和方法，它与一个实例绑定在一起，不可以定义静态的属性和方法</strong>。</li><li>局部内部类：作用域是这个代码块，不能是 <code>public</code> 、 <code>protected</code> 、 <code>private</code> 、 <code>static</code> 的，<strong>只能访问方法中定义为 <code>final</code> 类型的局部变量</strong>。把静态内部类的 <code>static</code> 去掉，将其定义放入外部类的静态方法或静态初始化代码段就成为了<strong>局部静态内部类</strong>，特性和静态内部类相似；把成员内部类的定义放入外部类的实例方法或实例初始化代码段中就成为了<strong>局部内部类</strong>，特性和成员内部类相似。</li><li>匿名内部类：它必须继承其他类或者其他接口，不能有构造函数，不能有静态成员、方法、类，不能是 <code>public</code> 、 <code>protected</code> 、 <code>private</code> 、 <code>static</code> 的，只能创建匿名内部类的一个实例。</li></ul><h3 id="2-6-如何获取父类的类名？"><a href="#2-6-如何获取父类的类名？" class="headerlink" title="2.6 如何获取父类的类名？"></a>2.6 如何获取父类的类名？</h3><p>这个问题之所以提出来是因为我们前面说过覆盖的要求， <code>Object</code> 的 <code>getClass</code> 方法是 <code>final</code> 与 <code>native</code> 的，它返回的是运行时态，所以下面的结果是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">super</span>.getClass().getName()); <span class="comment">// 与下面的结果相同</span></span><br><span class="line">    System.out.println(<span class="keyword">this</span>.getClass().getName()); <span class="comment">// 结果相同，都是输出 Test</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3. 关键字"></a>3. 关键字</h2><h3 id="3-1-final-、-finally-、-finalize-的区别？"><a href="#3-1-final-、-finally-、-finalize-的区别？" class="headerlink" title="3.1 final 、 finally 、 finalize 的区别？"></a>3.1 <code>final</code> 、 <code>finally</code> 、 <code>finalize</code> 的区别？</h3><ul><li><code>final</code> : 它指的是不可变性，即它只能指向初始化时指向的那个对象，而不关心指向对象内容的变化。<strong>当 <code>final</code> 是方法的时候，不允许任何子类重写这个方法，但可以使用</strong>。<strong>当 <code>final</code> 是参数的时候，不允许修改</strong>。<strong>当 <code>final</code> 是类的时候，不能被继承，所有方法都不能被重写</strong>。<strong>一个方法不能既被定义为 <code>abstract</code>  ，又被定义成 <code>final</code></strong> 。</li><li><code>finally</code> : 作为异常处理的一部分，表示最终一定被执行。</li><li><code>finalize</code> : 是 <code>Object</code> 的一个方法，在垃圾回收器执行时调用被回收对象的 <code>finalize</code> 方法，可以覆盖该方法实现对其他资源的回收，比如关闭文件等。</li></ul><blockquote><p><code>java</code> 中不能被集成的类是那些被 <code>final</code> 关键字修饰的类，比如 <code>String</code> 、 <code>StringBuffer</code> 等。</p></blockquote><h3 id="3-2-static-有什么作用？"><a href="#3-2-static-有什么作用？" class="headerlink" title="3.2 static 有什么作用？"></a>3.2 <code>static</code> 有什么作用？</h3><p>为某特定数据类型或对象分配单一的存储空间；实现某个方法或属性与类相关联，而不是对象。</p><ul><li><code>static</code> 成员变量： <code>static</code> 变量在内存中只有一个复制，所有实例都指向同一个内存地址，静态变量可以通过 <code>类.静态变量</code> 和 <code>对象.静态变量</code> 的方式引用。</li><li><code>static</code> 成员方法： <code>static</code> 方法是类的方法，只能访问所属类的静态成员变量和成员方法，不能使用 <code>this</code> 和 <code>super</code> 关键字，不能调用非 <code>static</code> 方法以及变量，<strong>一个很重要的用途是实现单例模式</strong>。</li><li><code>static</code> 代码块：独立于成员变量和成员函数的代码块，它不在任何一个方法体内， <code>JVM</code> 在加载类时会执行 <code>static</code> 代码块，<strong>如果有多个代码块，会顺序执行，它们只执行一次</strong>。</li><li><code>static</code> 内部类：就是静态内部类，它可以不依赖于外部类实例对象而被实例化，<strong>不能访问外部类的普通成员变量，只能访问外部类的静态成员和静态方法</strong>。</li></ul><h3 id="3-3-volatile-有什么作用？"><a href="#3-3-volatile-有什么作用？" class="headerlink" title="3.3 volatile 有什么作用？"></a>3.3 <code>volatile</code> 有什么作用？</h3><p>在使用 <code>volatile</code> 修饰成员变量以后，所有线程在任何时候看到的变量的值都是相同的。 <code>volatile</code> 不能保证操作的原子性，一般情况下，不能替代 <code>sychronized</code> ，另外，它会阻止编译器对代码的优化，因此会降低程序的执行效率，除非迫不得已，不要使用 <code>volatile</code> 。</p><h3 id="3-4-strictfp-有什么作用？"><a href="#3-4-strictfp-有什么作用？" class="headerlink" title="3.4 strictfp 有什么作用？"></a>3.4 <code>strictfp</code> 有什么作用？</h3><p>精确计算浮点数运算，当一个类被 <code>strictfp</code> 修饰，所有方法都被被动地加上 <code>strictfp</code> ，并且在不同的硬件上会有一致的运行结果。</p><h2 id="4-基本类型与运算"><a href="#4-基本类型与运算" class="headerlink" title="4. 基本类型与运算"></a>4. 基本类型与运算</h2><h3 id="4-1-什么是不可变类？"><a href="#4-1-什么是不可变类？" class="headerlink" title="4.1 什么是不可变类？"></a>4.1 什么是不可变类？</h3><p>这指的是当创建了这个类的实例以后，我们不能修改它的值，也就是说，一旦对象创建，它的成员变量不能被修改，只允许别的程序来读，但是不能进行修改。</p><p>如果一个类成员不是不可变量，那么在成员初始化或者使用 <code>get</code> 方法获取该成员变量的时候，可以通过 <code>clone</code> 方法来确保类的不可变性。</p><p>比如下面的赋值一个是正确的，一个是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutableClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Date d;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ImmutableClass</span> <span class="params">(Date d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.d = d; <span class="comment">// 这是不正确的，现在的 d 是一个引用，外部修改它也会修改</span></span><br><span class="line">    <span class="keyword">this</span>.d = d.clone(); <span class="comment">// 这是正确的，现在已经取消了引用的关系</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-强制转换的注意事项？"><a href="#4-2-强制转换的注意事项？" class="headerlink" title="4.2 强制转换的注意事项？"></a>4.2 强制转换的注意事项？</h3><p><code>Java</code> 语言在涉及 <code>byte</code> 、 <code>short</code> 、 <code>char</code> 运算的时候，首先会先将这些变量强制转换为 <code>int</code> ，然后对 <code>int</code> 进行运算，最后会的值也是 <code>int</code> 类型。</p><p>所以两个 <code>short</code> 相加、两个 <code>byte</code> 相加，最后得到的都是一个 <code>int</code> 类型的值。下面的代码会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>正确的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">s1 = (<span class="keyword">short</span>)(s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>值得注意的是，有些符号 <code>Java</code> 编译器会进行特殊处理，下面是正确的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="5-字符串与数组"><a href="#5-字符串与数组" class="headerlink" title="5. 字符串与数组"></a>5. 字符串与数组</h2><h3 id="5-1-字符串创建与存储的机制是什么？"><a href="#5-1-字符串创建与存储的机制是什么？" class="headerlink" title="5.1 字符串创建与存储的机制是什么？"></a>5.1 字符串创建与存储的机制是什么？</h3><p>对于下面的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String t1 = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure><p>这段语句是将字符串<code>s1</code> 赋值， <code>abc</code> 放到常量区中，如果这个时候创建一个新的字符串 <code>t1</code> 也是这样 <code>abc</code> ，那么 <code>s1</code> 和 <code>t1</code> 都将指向常量区中的 <code>abc</code> ，同一块内存地址。</p><p>对于下面的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>它的操作等价于两个部分： <code>abc</code> 和 <code>new String()</code> 。这两个操作，若在字符串池中没有 <code>abc</code> ，那么先创建一个 <code>abc</code> ，然后进行 <code>new String()</code> 在<strong>堆内存</strong>中创建一个新的对象，注意一点这里的 <code>s1</code> 、 <code>t1</code> 、 <code>s2</code> 都是栈空间里的内容。</p><h3 id="5-2-String-、-StringBuffer-、-StringBuilder-、-StringTokenizer-有什么区别？"><a href="#5-2-String-、-StringBuffer-、-StringBuilder-、-StringTokenizer-有什么区别？" class="headerlink" title="5.2 String 、 StringBuffer 、 StringBuilder 、 StringTokenizer 有什么区别？"></a>5.2 <code>String</code> 、 <code>StringBuffer</code> 、 <code>StringBuilder</code> 、 <code>StringTokenizer</code> 有什么区别？</h3><p>这个问题非常好，我确实不知道。</p><p><code>String</code> 和 <code>StringBuffer</code> 的区别在于当实例化 <code>String</code> 的时候，可以利用构造函数或者赋值的方式来进行初始化，但是 <code>StringBuffer</code> 只能使用构造函数的方式来进行初始化。</p><p><code>String</code> 的初始化其实是有中间步骤的，比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">s += <span class="string">"World"</span>;</span><br></pre></td></tr></table></figure><p>它等价于以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="comment">// 下面是等价代码</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line">s.append(<span class="string">"world"</span>);</span><br><span class="line">s = sb.toString();</span><br></pre></td></tr></table></figure><p>所以说修改多的话，建议使用 <code>StringBuffer</code> 。</p><p>而 <code>StringBuilder</code> 是单线程的，线程不安全，如果操作的数据量小，应优先使用 <code>String</code> ，如果单线程大量数据，应该使用 <code>StringBuilder</code> ，当多个线程访问，应该使用 <code>StringBuilder</code> 。</p><p>而最后的 <code>StringTokenizer</code> 是用来分割字符串的工具。</p><h3 id="5-3-Java-中数组是不是对象？"><a href="#5-3-Java-中数组是不是对象？" class="headerlink" title="5.3 Java 中数组是不是对象？"></a>5.3 <code>Java</code> 中数组是不是对象？</h3><p>在 <code>Java</code> 中数据不仅有自己的属性，还拥有一些方法可以被调用，对象的特点是封装了一些数据，同时提供了一些属性和方法，从这个角度看，数组是对象。</p><h3 id="5-4-数组的初始化方式？"><a href="#5-4-数组的初始化方式？" class="headerlink" title="5.4 数组的初始化方式？"></a>5.4 数组的初始化方式？</h3><p>这个问题还是很重要的，确实五花八门！</p><p>与 <code>C++</code> 不同在于， <code>Java</code> 在创建数组的时候回根据数据类型进行初始化，并且不会给数组元素分配存储空间，因此我们需要为其设置长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> type[arraySize];</span><br></pre></td></tr></table></figure><p>二维数组的创建有三种声明方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[][];</span><br><span class="line">type[][] arrayName;</span><br><span class="line">type[] arrayName[];</span><br></pre></td></tr></table></figure><p><strong>在 <code>Java</code> 中二维数组的第二维的长度可以不同</strong>。</p><p><strong>数组是对象不是原生类</strong>。</p><h3 id="5-5-length-、-length-、-size-的使用？"><a href="#5-5-length-、-length-、-size-的使用？" class="headerlink" title="5.5 length 、 length() 、 size() 的使用？"></a>5.5 <code>length</code> 、 <code>length()</code> 、 <code>size()</code> 的使用？</h3><p>数组提供了 <code>length</code> 属性来获取数组的长度。</p><p>字符串提供了 <code>length()</code> 方法来计算字符串的长度。</p><p><code>size()</code> 方法是针对泛型集合而言的，用于查看泛型中有多少个元素。</p><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h2><h3 id="6-1-finally-块里的代码什么时候执行？"><a href="#6-1-finally-块里的代码什么时候执行？" class="headerlink" title="6.1 finally 块里的代码什么时候执行？"></a>6.1 <code>finally</code> 块里的代码什么时候执行？</h3><p>如果 <code>try</code> 里面有 <code>return</code> 我们的 <code>finally</code> 还执行吗？什么时候执行？</p><p>任何代码都要在 <code>return</code> 前执行，因此 <code>finally</code> 里的代码也会在 <code>return</code> 前执行，如果说现在 <code>try-finally</code> 和 <code>catch-finally</code> 里都有 <code>return</code> 那么 <code>finally</code> 里的 <code>return</code> 会覆盖别处的 <code>return</code> 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"execute finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = testFinally();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute finally</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>可以发现，我们的执行是先进行了 <code>finally</code> 里的操作，然后执行 <code>try</code> 里的 <code>return</code> 操作。</strong></p><p>而如果说我们在 <code>finally</code> 里设置了 <code>return</code> 那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"execute finally"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = testFinally();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute finally</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>可以发现，现在，<code>finally</code> 里的 <code>return</code> 替换了之前的 <code>return</code> 。</strong></p><p>而事实上，它做的操作是什么顺序呢？先 <code>finally</code> 再 <code>try</code> ？</p><p><strong>事实上，程序在执行 <code>try</code> 里的 <code>return</code> 时，会先将返回值存储到一个指定的地址，然后执行 <code>finally</code> ，最后再返回结果。因此，如果返回值是基本类型，那么再在 <code>finally</code> 修改已经没用了，而如果返回是引用类型，那么再在 <code>finally</code> 里修改是可以直接修改到目标内容的。</strong></p><p>什么情况下不会执行 <code>finally</code> 带代码：</p><ol><li>在 <code>try</code> 以前就报错了，嗨呀大兄弟，长点心吧。</li><li>使用 <code>System.exit(0)</code> 强制退出。</li></ol><h3 id="6-2-运行时异常和普通异常的区别？"><a href="#6-2-运行时异常和普通异常的区别？" class="headerlink" title="6.2 运行时异常和普通异常的区别？"></a>6.2 运行时异常和普通异常的区别？</h3><p><code>Java</code> 有两种错误的异常类： <code>Error</code> 和 <code>Exception</code> 。他们有共同的父类：<code>Throwable</code> 。</p><p><code>Error</code> 是严重的错误，多是由于逻辑错误导致的，编译器不会检查，一旦发生，<code>JVM</code> 会终止线程。</p><p><code>Exception</code> 是可以恢复的异常，是编译器可以捕捉的，它有两种类型：<strong>检查异常</strong>和<strong>运行异常</strong>。</p><p>检查异常：<strong>编译器强制对其进行捕捉并处理。</strong>所有继承自 <code>Exception</code> 且不是运行时异常的异常都是检查异常，最常见的有 IO 异常和 SQL 异常，这些异常都发生在便一阶段，只需要放到 <code>try</code> 中，异常处理放到 <code>catch</code> 中即可。</p><p>运行时异常：<strong>编译器没有强制对其进行捕捉并处理。</strong>如果出现，会由 <code>JVM</code> 来处理，出现会向上层抛出，直到遇到处理代码，多线程会直到 <code>Thread.run()</code> 单线程直到 <code>main()</code> ，到了这里，线程退出或者主线程退出。</p><p>PS: <code>Java</code> 的异常捕获有多态的概念，是应该先捕获子类，然后捕获基类，否则，子类捕获不会执行。</p><h2 id="7-输入输出流"><a href="#7-输入输出流" class="headerlink" title="7. 输入输出流"></a>7. 输入输出流</h2><h3 id="7-1-Java-Socket-是什么？"><a href="#7-1-Java-Socket-是什么？" class="headerlink" title="7.1 Java Socket 是什么？"></a>7.1 <code>Java Socket</code> 是什么？</h3><p>基于 <code>TCP</code> 的通信过程如下：</p><ol><li>首先，<code>Server</code> 端监听指定的某个端口是否有连接请求；</li><li>其次，<code>Client</code> 端向 <code>Server</code> 端发送 <code>Connect</code> 请求；</li><li>最后，<code>Server</code> 端向 <code>Client</code> 发送 <code>Accept</code> 消息，一个连接就建立起来了。</li></ol><h3 id="7-2-NIO-是什么？"><a href="#7-2-NIO-是什么？" class="headerlink" title="7.2 NIO 是什么？"></a>7.2 <code>NIO</code> 是什么？</h3><p>非阻塞 <code>IO</code> 通过 <code>Selector</code> 、 <code>Channel</code> 、 <code>Buffer</code> 来实现非阻塞的 <code>IO</code> 操作，具体使用一个线程来管理多个通道，轮询处理多线程的请求，保存的是 <code>SelectionKey</code> 和 <code>Channel</code> 之间的关系，这种轮询在处理多线程请求的时候不需要上下文切换。</p><p>在处理大量并发请求的时候，使用 <code>NIO</code> 比使用 <code>Socket</code> 效率要高很多。</p><h3 id="7-3-什么是-Java-序列化？"><a href="#7-3-什么是-Java-序列化？" class="headerlink" title="7.3 什么是 Java 序列化？"></a>7.3 什么是 <code>Java</code> 序列化？</h3><p>对象持久化有的方式分为序列化和外部序列化。</p><ul><li>序列化</li></ul><p>将对象以一连串的字节描述的过程，用于解决在对对象流进行读写操作时所引发的问题。所有要实现序列化的类都必须实现 <code>Serializable</code> 接口，它没有包含任何方法，使用一个输出流来构造一个 <code>ObjectOutputStream</code> 对象，紧接着，使用该对象的 <code>writeObject</code> 方法将对象写出，要恢复可以使用其对应的输入流。</p><p>值得注意的有两点：</p><blockquote><ol><li>如果一个类能被序列化，那么它的子类也可以被序列化。</li><li><code>static</code> 和 <code>transient</code> 这两种类型的数据成员不能被序列化。</li></ol></blockquote><p>序列化会影响系统的性能，什么情况下需要使用序列化？</p><blockquote><ol><li>需要通过网络来发送对象，或对象的状态需要被持久化到数据库或者文件中。</li><li>序列化能实现深赋值，即可以复制引用的对象。</li></ol></blockquote><p>与序列化相对的是反序列化，它将流转换成对象。每个类都有一个特定的 <code>serialVersionUID</code> ，在反序列化的过程中，通过 <code>serialVersionUID</code> 来判定类的兼容性，而显式声明 <code>serialVersionUID</code> 有以下 3 个优点：</p><ol><li>提高程序的运行效率。省去了计算的过程。</li><li>提高程序在不同平台上的兼容性。因为大家的计算方式不同。</li><li>增强各个版本的兼容性。因为后期该 <code>ID</code> 可能会出现变化。</li></ol><ul><li>外部序列化</li></ul><p>外部序列化与序列化主要叙别在于序列化是内置的 <code>API</code> ，而外部序列化需要继承 <code>Serializable</code> 接口，其中的读写方法需要自己实现。</p><p>如果我们想对一个类中的部分属性进行序列化，可以这么做：</p><ol><li>实现继承自 <code>Serializable</code> 的接口的新的接口的方法，根据实际情况来控制需要序列化的属性。</li><li>使用关键字 <code>transient</code> 来控制序列化的属性，被该关键字修饰的属性是临时的，不会被序列化。</li></ol><h2 id="8-内存管理"><a href="#8-内存管理" class="headerlink" title="8. 内存管理"></a>8. 内存管理</h2><h3 id="8-1-JVM-是怎么加载-class-的？"><a href="#8-1-JVM-是怎么加载-class-的？" class="headerlink" title="8.1 JVM 是怎么加载 class 的？"></a>8.1 <code>JVM</code> 是怎么加载 <code>class</code> 的？</h3><p>类 <code>class</code> 被加载到 <code>JVM</code> 中才能运行，<code>JVM</code> 会将编译成的 <code>.class</code> 文件按照需求和一定的规则加载到内存中。组织成为一个完整的 <code>Java</code> 应用。<strong>这个过程是使用类加载器来完成的，它本身也是一个类。实质就是从硬盘读取到内存中。</strong></p><p>类的加载分为隐式和显式，其中隐式是 <code>new</code> ；显式是 <code>class.forName()</code> 。</p><p>类的加载是动态的，它不会一次加载全部的类，只有在需要的时候进行加载。同理，只有部分类被修改的时候，只会重新编译变化的类，而不会重新编译所有文件，加快了编译速度。</p><p><code>Java</code> 中 3 种不同的类的加载器，对应：系统类、扩展类、自定义类。它们使用委托的方式实现类的加载。当一个类在父类加载器中无法搜索，那么就用它的子类（加载器的子类）来加载。</p><p>类的加载：</p><blockquote><ol><li>装载。根据路径查询到相应的 <code>class</code> 文件，然后导入。</li><li>链接：</li></ol><blockquote><ol><li>检查。检查加载 <code>class</code> 的正确性。</li><li>准备。给类中的静态变量分配空间。</li><li>解析。符号引用转换成直接引用。</li></ol></blockquote><ol><li>初始化。对静态变量和静态代码块执行初始化工作。</li></ol></blockquote><h3 id="8-2-什么是-GC-？"><a href="#8-2-什么是-GC-？" class="headerlink" title="8.2 什么是 GC ？"></a>8.2 什么是 <code>GC</code> ？</h3><p>垃圾回收。回收程序中不再使用的内存。主要有以下三个任务：</p><ol><li>分配内存。</li><li>确保被引用对象的内存不被错误地回收。</li><li>回收不再被引用的对象的内存空间。</li></ol><p>但是垃圾回收有以下缺点：</p><ol><li>跟踪内存的使用情况。</li><li>释放没用的对象。</li><li>处理堆里的碎片。</li></ol><p>垃圾回收可以用有向图来表示，如果一个节点（对象）是不可达的，那么就是可以回收的。 <strong>追踪回收</strong></p><p>把堆中活动的对象放到堆的一端中，这样堆的另外一端就留出了一块空闲，相当于对堆中的碎片进行了处理，但是这样会有性能损失。<strong>压缩回收</strong></p><p>把堆分成两份，只在一份存放内容，如果满了，将活动的部分放到另外一份中。<strong>复制回收</strong></p><p>把堆分成两个或多个子堆，每一堆都是一代，经过多次复制回收以后依然存活的对象升到高一级的堆中。<strong>按代回收</strong></p><h3 id="8-3-Java-中是否存在内存泄露？"><a href="#8-3-Java-中是否存在内存泄露？" class="headerlink" title="8.3 Java 中是否存在内存泄露？"></a>8.3 <code>Java</code> 中是否存在内存泄露？</h3><p>首先我们需要知道的是，垃圾回收器帮我们做了什么，它回收有两个标准：</p><ol><li>对象赋予了 <code>null</code> ，以后再没有使用了。</li><li>对象赋予了新值，重新分配了内存空间。</li></ol><p>内存泄露指下面两种情况：</p><ol><li>堆中申请的空间没有释放掉。</li><li>对象已不再使用，但是仍然存在在内存中。</li></ol><p>我们可以发现这里内存泄露的第一种情况已经被 <code>GC</code> 的第二条解决了，剩下的是对象已经不再使用，但是仍然在内存中。</p><p>内存泄露的情况：</p><ol><li>静态集合类。它们如果不释放，那么内部对象也无法释放。</li><li>各种连接。不 <code>close()</code> 那么内部对象无法释放。</li><li>监听器。同理，需要删除监听器。</li><li>变量不合理的作用域。方法变量写到类中的情况。</li><li>单例。或者说 <code>static</code> 对象对于类而言是一直存在的。</li></ol><h3 id="8-4-Java-中的堆和栈有什么区别？"><a href="#8-4-Java-中的堆和栈有什么区别？" class="headerlink" title="8.4 Java 中的堆和栈有什么区别？"></a>8.4 <code>Java</code> 中的堆和栈有什么区别？</h3><p>基本数据类型和引用变量在栈中。</p><p>引用类型在堆中。</p><p>堆空间的变量有 <code>GC</code> 来帮我们处理。</p><h2 id="9-容器"><a href="#9-容器" class="headerlink" title="9. 容器"></a>9. 容器</h2><h3 id="9-1-什么是迭代器？"><a href="#9-1-什么是迭代器？" class="headerlink" title="9.1 什么是迭代器？"></a>9.1 什么是迭代器？</h3><p>迭代器是一个对象，它的工作是遍历并选择序列中的对象。</p><ol><li>使用 <code>iterator()</code> 将返回一个 <code>Iterator</code> ，然后通过使用 <code>next()</code> 来返回第一个元素。</li><li>使用 <code>Iterator</code> 的 <code>hasNext()</code> 方法判断容器中是否还有元素，如果有，继续使用 <code>next()</code> 获取下一个元素。</li><li>使用 <code>remove()</code> 来删除迭代器中的对象。</li></ol><p><code>ListIterator</code> 只存在在 <code>List</code> 中，支持在迭代过程中向 <code>List</code> 中添加或删除元素，并且可以在 <code>List</code> 中双向滚动。</p><p>如果我们遇到 <code>ConcurrentModificationException</code> 异常，这通常是因为使用 <code>Iterator</code> 遍历容器的同时，对容器进行了修改，或者在多线程中，一个线程对容器进行了遍历，另外一个线程对容器进行了修改。</p><p>我们在使用 <code>next()</code> 的时候，会比较变量 <code>expectedModCount</code> 和容器中的实际对象的个数 <code>modCount</code> 的值是否相等，如果不相等，就会出现 <code>ConcurrentModificationException</code> 异常。</p><p>正确的做法应该是：</p><blockquote><p> 在遍历中把删除的对象放到一个集合中，等遍历结束以后调用 <code>removeAll()</code> 方法来删除，或者使用 <code>iter.remove()</code> 方法。</p></blockquote><p>在多线线程中，我们可以使用一些线程安全的容器：<code>ConcurrentHashMap</code> 和 <code>CopyOnWriteArrayList</code> ，或者使用 <code>synchronized</code> 代码块来存放容器的遍历操作。</p><h3 id="9-2-ArrayList-、Vector-、LinkedList-有什么区别？"><a href="#9-2-ArrayList-、Vector-、LinkedList-有什么区别？" class="headerlink" title="9.2 ArrayList 、Vector 、LinkedList 有什么区别？"></a>9.2 <code>ArrayList</code> 、<code>Vector</code> 、<code>LinkedList</code> 有什么区别？</h3><p>它们都在 <code>java.util</code> 包下。</p><p>其中 <code>ArrayList</code> 和 <code>Vector</code> 都适合访问，内存地址是连续的，但是前者默认扩充是原来的 1.5 倍，后者扩充是原来的 2 倍；前者是线程不安全的，后者是线程安全的。</p><p>而 <code>LinkedList</code> 采用了双向链表来实现，适合修改。</p><h3 id="9-3-HashMap-、HashTable-、TreeMap-、WeakHashMap-有什么区别？"><a href="#9-3-HashMap-、HashTable-、TreeMap-、WeakHashMap-有什么区别？" class="headerlink" title="9.3 HashMap 、HashTable 、TreeMap 、WeakHashMap 有什么区别？"></a>9.3 <code>HashMap</code> 、<code>HashTable</code> 、<code>TreeMap</code> 、<code>WeakHashMap</code> 有什么区别？</h3><ol><li><code>HashMap</code> 是 <code>HashTable</code> 的轻量级实现，非线程安全的实现，<code>HashMap</code> 允许一条记录的 <code>key</code> 是 <code>null</code> 。</li><li><code>HashTable</code> 是线程安全的，就效率而言，<code>HashMap</code> 要优于 <code>HashTable</code> 。</li><li><code>HashTable</code> 使用 <code>Enumeration</code> ，<code>HashMap</code> 使用 <code>Iterator</code> 。</li><li><code>HashMap</code> 的默认大小是 16，每次增加是原来的两倍加一；<code>HashTable</code> 的默认大小是 11，每次增加是原来的两倍。</li><li><code>TreeMap</code> 实现了 <code>SortMap</code> 接口，保证记录根据键值排序。</li><li><code>WeakHashMap</code> 是弱引用类型，如果其中的 <code>map</code> 没有外部引用，那么将会自动删除。</li></ol><p>下面的代码实现了一个线程安全的 <code>HashMap</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure><h3 id="9-4-把自定义的类作为-HashMap-的-key-需要注意什么？"><a href="#9-4-把自定义的类作为-HashMap-的-key-需要注意什么？" class="headerlink" title="9.4 把自定义的类作为 HashMap 的 key 需要注意什么？"></a>9.4 把自定义的类作为 <code>HashMap</code> 的 <code>key</code> 需要注意什么？</h3><p>当一个新的元素到 <code>HashMap</code> ，它会先比较 <code>hashCode()</code> ，如果不相等，则添加这个元素，如果相等，则需要用 <code>equals()</code> 方法比较 <code>key</code> ，如果 <code>key</code> 相等，则覆盖 <code>value</code> ，如果不相等，则说明出现了冲突。</p><p><code>HashMap</code> 中使用链地址法来解决冲突，比如我们现在通过 <code>key</code> 来找到 <code>value</code> ，它是怎么办到的？</p><ol><li>首先通过 <code>key</code> 进行 <code>hashCode()</code> 方法找到值存储的首地址</li><li>发现存在多个 <code>key</code> 满足组成的 <code>keyList</code></li><li>遍历每个 <code>key</code> ，用 <code>equals()</code> 来找到 <code>key</code> 相同的键值对，这里的 <code>value</code> 就是返回结果</li></ol><p>默认的 <code>hashCode()</code> 返回对象存储的内存地址，默认的 <code>equals()</code> 比较对象是否是同一个对象。</p><p>这告诉我们，在使用自定义类实现 <code>key</code> 的时候，我们需要重写 <code>equals()</code> 和 <code>hashCode()</code> 。</p><h2 id="10-多线程"><a href="#10-多线程" class="headerlink" title="10. 多线程"></a>10. 多线程</h2><h3 id="10-1-如果实现-Java-的多线程？"><a href="#10-1-如果实现-Java-的多线程？" class="headerlink" title="10.1 如果实现 Java 的多线程？"></a>10.1 如果实现 <code>Java</code> 的多线程？</h3><ul><li>继承 <code>Thread</code> 类，重写 <code>run()</code> 方法：注意 <code>Thread</code> 类实际上是实现了 <code>Runnable</code> 接口的一个实例，启动线程唯一的方法是 <code>Thread</code> 类的 <code>start()</code> 方法，该方法将启动一个新线程，并执行 <code>run()</code> 方法。</li><li>实现 <code>Runnable</code> 接口，实现 <code>run()</code> 方法：也是通过 <code>Thread</code> 类的 <code>start()</code> 方法来启动新的线程。</li><li>实现 <code>Callable</code> 接口，重写 <code>call()</code> 方法。</li></ul><p>关于 <code>Callable</code> 接口和 <code>Runnable</code> 接口的不同点：</p><ol><li><code>Callable</code> 可以在任务结束后提供一个返回值</li><li><code>Callable</code> 的 <code>call()</code> 方法可以抛出异常</li><li>运行 <code>Callable</code> 可以获取一个 <code>Future</code> 对象，表示异步计算的结果，由于线程输入异步计算模型，因此无法从别的线程中得到函数的返回值，这时，可以使用 <code>Future</code> 来监控目标线程调用 <code>call()</code> 方法的情况，当调用 <code>Future</code> 的 <code>get()</code> 可以获取结果，同时当前线程将阻塞，直到 <code>call()</code> 方法返回结果。</li></ol><p>推荐使用 <code>Runnable</code> 接口，这比较轻量。</p><h3 id="10-2-run-方法和-start-方法有什么区别？"><a href="#10-2-run-方法和-start-方法有什么区别？" class="headerlink" title="10.2 run() 方法和 start() 方法有什么区别？"></a>10.2 <code>run()</code> 方法和 <code>start()</code> 方法有什么区别？</h3><p>通常，系统通过调用线程类的 <code>start()</code> 方法来启动一个线程，此时线程处于就绪态，可以被 <code>JVM</code> 调用。在调度过程中，<code>start()</code> 方法异步调用线程类的 <code>run()</code> 方法来完成实际的操作，当 <code>run()</code> 方法结束了，此线程也结束了。</p><p>如果直接调用 <code>run()</code> ，那么仅仅是一个同步的方法。</p><h3 id="10-3-多线程同步的实现方法有哪些？"><a href="#10-3-多线程同步的实现方法有哪些？" class="headerlink" title="10.3 多线程同步的实现方法有哪些？"></a>10.3 多线程同步的实现方法有哪些？</h3><p><strong><code>sychronized</code> 关键字</strong></p><ul><li><code>synchronized</code> 方法：放到方法中的关键字，但是会大大影响程序的效率。</li><li><code>sychronized</code> 块：锁定对象，有非常高的灵活性。</li></ul><p><strong><code>wait()</code> 方法和 <code>notify()</code> 方法</strong> (这个使用基本在使用 <code>sychronized</code> 关键字基础上)</p><ul><li><code>wait()</code> 方法释放对象锁，进入等待状态，并且可以调用 <code>notify()</code> 方法通知正在等待的其他线程。</li><li><code>notifyAll()</code> 允许其他进程去竞争。</li></ul><p><strong><code>Lock</code></strong></p><ul><li><code>lock()</code> 方法以阻塞的方式获取锁，如果获得了锁，立即返回，如果别的线程持有锁，当前线程等待。</li><li><code>tryLock()</code> 方法以非阻塞的方式获取锁，尝试性获取锁，如果得到立即返回 <code>true</code> ，否则 <code>false</code> 。</li><li><code>lockInterruptibly()</code> 如果获取了锁，立即返回，如果没有获取锁，当前线程进入休眠状态，直到获取锁或者<strong>被中断</strong>，和 <code>lock()</code> 最大的不同在于，如果 <code>lock()</code> 获取不到锁，会一直处于阻塞状态，并且会忽略 <code>interrupt()</code> 方法。</li></ul><h3 id="10-4-sleep-和-wait-有什么区别？"><a href="#10-4-sleep-和-wait-有什么区别？" class="headerlink" title="10.4 sleep() 和 wait() 有什么区别？"></a>10.4 <code>sleep()</code> 和 <code>wait()</code> 有什么区别？</h3><ul><li>原理不同：<code>sleep()</code> 是 <code>Thread</code> 的静态方法，是线程用来控制自身流程的，令线程暂停一段时间，像是一个闹钟；<code>wait()</code> 是 <code>Object</code> 的方法，用于线程通信，使当前拥有该对象锁的进程等待，可以设定时间自动醒来或者其他线程调用 <code>notify()</code>。</li><li>对锁的处理机制不同：调用 <code>sleep()</code> 不会释放锁，而 <code>wait()</code> 会释放它占用的锁。</li><li>使用区域不同：<code>wait()</code> 具有特殊意义，使用在同步控制语句中，而 <code>sleep()</code> 则可以随时随地。</li></ul><p><code>sleep()</code> 和 <code>yield()</code> 的区别：</p><ul><li><code>sleep()</code> 给其他线程机会不考虑优先级；<code>yield()</code> 给其他线程机会只会给比自己相同等级或等级高的线程。</li><li><code>sleep()</code> 会进入阻塞态，在此期间，线程不会被执行；而 <code>yield()</code> 会使当前线程回到可执行状态很可能又马上被执行。</li></ul><h3 id="10-5-终止线程的方法有哪些？"><a href="#10-5-终止线程的方法有哪些？" class="headerlink" title="10.5 终止线程的方法有哪些？"></a>10.5 终止线程的方法有哪些？</h3><p><code>stop()</code> 会释放锁，但存在不一致的状态，所以是不安全的。</p><p><code>suspend()</code> 不释放锁，可能发生死锁，不安全。</p><p>有一个标志，在 <code>while</code> 里，终止就设置标志，但是可能是非运行态，所以有时候不可行。</p><p>我们可以通过捕获异常的方式，来安全结束进程，比如使用 <code>InterruptedException</code> 。</p><h3 id="10-6-sychronized-与-Lock-有什么异同？"><a href="#10-6-sychronized-与-Lock-有什么异同？" class="headerlink" title="10.6 sychronized 与 Lock 有什么异同？"></a>10.6 <code>sychronized</code> 与 <code>Lock</code> 有什么异同？</h3><ul><li>用法不一样：前者托管给 <code>JVM</code> ，后者需要我们通过代码实现。</li><li>性能不一样：在资源竞争不是很激烈的时候，<code>sychronized</code> 的性能比 <code>Lock</code> 好，但是在竞争激烈的情况下，<code>sychronized</code> 性能下降很快，而 <code>Lock</code> 基本不变。</li><li>锁的机制不一样：<code>sychronized</code> 是自动解锁，是相反顺序释放；<code>Lock</code> 需要手动释放，还必须在 <code>finally</code> 里。</li></ul><p>两种锁的机制不要一起使用！</p><p>当一个线程进入一个对象的一个 <code>synchronized</code> 方法后，其他线程能进入其他普通方法和带 <code>static</code> 标记的方法 (<code>static sychronized</code> 也包括)。</p><h3 id="10-7-什么是守护线程？"><a href="#10-7-什么是守护线程？" class="headerlink" title="10.7 什么是守护线程？"></a>10.7 什么是守护线程？</h3><p>设置 <code>setDaemon</code> 为 <code>true</code> 以后，表示是守护进程，当进程中只有守护进程，<code>JVM</code> 会自动退出。</p><h3 id="10-8-join-方法的作用是什么？"><a href="#10-8-join-方法的作用是什么？" class="headerlink" title="10.8 join() 方法的作用是什么？"></a>10.8 <code>join()</code> 方法的作用是什么？</h3><p><code>join()</code> 方法的作用是让调用该方法的进程在执行完 <code>run()</code> 以后再执行 <code>join()</code> 后的方法。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试宝典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探 MyBatis</title>
      <link href="/technology/2018-10-29-mybatis-summary/"/>
      <url>/technology/2018-10-29-mybatis-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="SqlSessionFactory-的生成"><a href="#SqlSessionFactory-的生成" class="headerlink" title="SqlSessionFactory 的生成"></a>SqlSessionFactory 的生成</h2><p>MyBatis 是一个基于 SqlSessionFactory 构建的框架，对于 SqlSessionFactory 而言，它的作用是生成 SqlSession 接口，但是它们对于业务而言是单一的，在 Spring Boot 中，对于它们的实现是非显示的，去掉框架，我们可以这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 声明 SSF</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建 SSF</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 读取 mybatis 配置</span></span><br><span class="line">  Reader reader = Resources.getResourceAsReader(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">  <span class="comment">// 创建我们需要的 SqlSessionFactory</span></span><br><span class="line">  sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">  reader.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ignore) &#123;</span><br><span class="line">  ignore.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建 SS</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  List&lt;Country&gt; countryList = sqlSession.selectList(<span class="string">"selectAll"</span>);</span><br><span class="line">  printCountryList(countryList);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Mapper-接口动态代理"><a href="#Mapper-接口动态代理" class="headerlink" title="Mapper 接口动态代理"></a>Mapper 接口动态代理</h2><p>在使用 MyBatis 时，我们仅仅定义接口 mapper 和与之对应的 xml ，但是并不需要做具体的 imp 类与方法，这是因为 MyBatis 在内部存在一个代理者，实现了 <code>InvocationHandler</code> 接口，当我们使用某个 pojo 类的方法的时候，它将获得这个 pojo 类的全限定名称（同时，也是 xml 中的 namespace ，两者相互关联），与调用的方法进行组合，这样一个方法就被唯一指定了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyMapperProxy</span><span class="params">(Class&lt;T&gt; mapperInterface, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// method.getName() 指向了将被调用的方法名，同时也是 xml 中的 namespace</span></span><br><span class="line">    <span class="comment">// mapperInterface.getCanonicalName 会找到具体的方法</span></span><br><span class="line">    List&lt;T&gt; list = sqlSession.selectList(</span><br><span class="line">        mapperInterface.getCanonicalName() + <span class="string">"."</span> + method.getName());</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="MyBatis-接口-sql-的实现"><a href="#MyBatis-接口-sql-的实现" class="headerlink" title="MyBatis 接口 sql 的实现"></a>MyBatis 接口 sql 的实现</h2><p>有三种方式可以实现接口中的 sql ，分别是 xml ，接口上注解，以及 provider 注解。</p><p>三种方式大同小异，为了代码一致性，推荐统一使用 xml 方式。</p><p>xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">  select * from sys_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(&#123;</span><br><span class="line">  <span class="string">"select id, role_name roleName, enabled,"</span> +</span><br><span class="line">  <span class="string">"create_by createBy,"</span> +</span><br><span class="line">  <span class="string">"create_time createTime "</span> +</span><br><span class="line">  <span class="string">"from sys_role "</span> +</span><br><span class="line">  <span class="string">"where id = #&#123;id&#125;"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">SysRole <span class="title">selectById</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><p>provider：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapper 接口</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">@SelectProvider</span>(type = PrivilegeProvider.class, method = <span class="string">"selectById"</span>)</span><br><span class="line"><span class="function">SysPrivilege <span class="title">selectById</span><span class="params">(Long id)</span></span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// provider 类</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">selectById</span><span class="params">(<span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SQL() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      SELECT(<span class="string">"id, privilege_name, privilege_url"</span>);</span><br><span class="line">      FROM(<span class="string">"sys_privilege"</span>);</span><br><span class="line">      WHERE(<span class="string">"id = #&#123;id&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.toString();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="MyBatis-generator-的使用"><a href="#MyBatis-generator-的使用" class="headerlink" title="MyBatis generator 的使用"></a>MyBatis generator 的使用</h2><p>通过 <code>org.mybatis.generator</code> 包可以在 xml 中进行设置来生成 model 对应的 sql 实现和 dao 接口，之后还要研究另一种实现方式，所以这里暂且不考虑内部实现，之后，我们可以使用对应 example 类来实现 sql ，这里也先不讨论。xml 主要的使用方式是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MySqlContext"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beginningDelimiter"</span> <span class="attr">value</span>=<span class="string">"'"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"endingDelimiter"</span> <span class="attr">value</span>=<span class="string">"'"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFileEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressDate"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"addRemarkComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"czp"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--实体类生成配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.koon.generator.model"</span> <span class="attr">targetProject</span>=<span class="string">"/Users/ronnie/work/GithubWorkspace/springboot-tourist/mybatis-started-to-master/chapter2/src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Mapper.xml生成配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"generator.mapper"</span> <span class="attr">targetProject</span>=<span class="string">"/Users/ronnie/work/GithubWorkspace/springboot-tourist/mybatis-started-to-master/chapter2/src/main/resources"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Mapper.java生成配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"com.koon.generator.mapper"</span> <span class="attr">targetProject</span>=<span class="string">"/Users/ronnie/work/GithubWorkspace/springboot-tourist/mybatis-started-to-master/chapter2/src/main/java"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"country"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">sqlStatement</span>=<span class="string">"MySQL"</span> <span class="attr">identity</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一对多中-resultMap-指定"><a href="#一对多中-resultMap-指定" class="headerlink" title="一对多中 resultMap 指定"></a>一对多中 resultMap 指定</h2><p>无论一对一、一对多中，我们都有可能要使用 resultMap ，其中可能是要在一个 xml 中使用另一个 xml 中的 resultMap ，那么，它的写法是先指向 mapper 接口文件，然后指向该接口文件对应 xml 中的 resultMap 的 id ，这也是 mapper 动态代理的一种应用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userRoleListMap"</span> <span class="attr">type</span>=<span class="string">"com.koon.model.SysUser"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_name"</span> <span class="attr">property</span>=<span class="string">"userName"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_password"</span> <span class="attr">property</span>=<span class="string">"userPassword"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_email"</span> <span class="attr">property</span>=<span class="string">"userEmail"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_info"</span> <span class="attr">property</span>=<span class="string">"userInfo"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"head_img"</span> <span class="attr">property</span>=<span class="string">"headImg"</span> <span class="attr">jdbcType</span>=<span class="string">"BLOB"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"create_time"</span> <span class="attr">property</span>=<span class="string">"createTime"</span> <span class="attr">jdbcType</span>=<span class="string">"TIMESTAMP"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--注意这里 resultMap 的指定方式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"roleList"</span> <span class="attr">columnPrefix</span>=<span class="string">"role_"</span> <span class="attr">ofType</span>=<span class="string">"com.koon.model.SysRole"</span> <span class="attr">resultMap</span>=<span class="string">"com.koon.mapper.RoleMapper.rolePrivilegeListMap"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MyBatis-缓存"><a href="#MyBatis-缓存" class="headerlink" title="MyBatis 缓存"></a>MyBatis 缓存</h2><p>MyBatis 中存在一级缓存和二级缓存，一级缓存是指在一个 SqlSession 生命周期下相同键值存入一个 Map 对象中，可以通过参数修改来破除一级缓存：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过 id 查询用户--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  select * from sys_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>二级缓存不止存在于 SqlSession 生命周期中，它存在于 SqlSessionFactory 生命周期中，在 mybatis-config.xml 中，可以对它进行设置，默认就是 true ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MyBaits 使用 <code>SeiralizedCache</code> 序列化缓存来实现可读写缓存类，并通过序列化和反序列化来保证通过缓存换取数据的时候，得到的是一个新的实例，所以我们常常对可序列化对象这样操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8280230645677496806L</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 xml 文件和对应 mapper 接口下，我们都可以进行 cache 配置，二级缓存和命名空间绑定，所以通常每一个 mapper 都拥有自己的二级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span>(</span><br><span class="line">  eviction = FifoCache.class,</span><br><span class="line">  flushInterval = <span class="number">60000</span>,</span><br><span class="line">  size = <span class="number">512</span>,</span><br><span class="line">  readWrite = <span class="keyword">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>通过参照缓存，来确保我们在同一个二级缓存中，将同一个事务的对象设置为一个二级缓存，可以有效避免脏数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespaceRef</span>(RoleMapper.class)</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"com.koon.mapper.RoleMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>后续将跟进通用 mapper 和分页插件</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boosting 推导</title>
      <link href="/machine-learning/2018-10-24-boosting/"/>
      <url>/machine-learning/2018-10-24-boosting/</url>
      
        <content type="html"><![CDATA[<p>&lt;&lt; python 机器学习基础教程&gt;&gt;：第二章——监督学习算法。介绍了梯度提升决策树（GBDT）。</p><p>&lt;&lt; sklearn 与 tf 机器学习实用指南&gt;&gt;：第七章——集成学习。介绍了适应性增强（Adaboost）和 GBDT。</p><p>&lt;&lt; python 机器学习经典实例&gt;&gt;：第一章——监督学习。介绍了 Adaboost。</p><p>&lt;&lt;统计学习方法&gt;&gt;：第八章——提升方法。介绍了 Adaboost 和 GBDT。</p><p>&lt;&lt;机器学习&gt;&gt;：第八章——集成学习。介绍了 Adaboost。</p><p>&lt;&lt;深度学习&gt;&gt;：第七章——深度学习中的正则化。介绍了 Dropout Boosting 的方法。</p><hr><h2 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h2><p>机器学习 -&gt; 统计学习方法 -&gt; 实践补充</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>集成学习：通过构建并结合多个学习器来完成学习任务。</p><p>同质 homogeneous：决策树集成中全是决策树，神经网络集成中全是神经网络。</p><p>基学习器 base learner：同质集成中的个体学习器。</p><p>基学习算法 base learning algorithm：基学习器所使用的学习算法。</p><p>异质 heterogenous：集成包含不同类型的个体学习器。</p><p>组件学习器 component learner：和基学习器对应，它们统称为个体学习器。</p><h3 id="集成学习的可行性证明"><a href="#集成学习的可行性证明" class="headerlink" title="集成学习的可行性证明"></a>集成学习的可行性证明</h3><p>假设二分类问题 $y \in \{ - 1 , + 1 \}$ 和真实函数 $f$ ，假定基分类器的错误率是 $\epsilon$ ，即对每个<strong>基分类器 $h_{i}$ </strong>有：</p><script type="math/tex; mode=display">P \left( h _ { i } ( \boldsymbol { x } ) \neq f ( \boldsymbol { x } ) \right) = \epsilon</script><p>假设集成通过投票结合 $T$ 个基分类器，若有超过半数的基分类器正确，则集成分类就正确：</p><script type="math/tex; mode=display">H ( \boldsymbol { x } ) = \operatorname { sign } \left( \sum _ { i = 1 } ^ { T } h _ { i } ( \boldsymbol { x } ) \right)</script><p>根据 Hoeffding 不等式，得到集成后的错误率：</p><script type="math/tex; mode=display">\left.\begin{aligned} P ( H ( \boldsymbol { x } ) \neq f ( \boldsymbol { x } ) ) & = \sum _ { k = 0 } ^ { \lfloor T / 2 \rfloor } \left( \begin{array} { l } { T } \\ { k } \end{array} \right) ( 1 - \epsilon ) ^ { k } \epsilon ^ { T - k } \\ & \leqslant \exp \left( - \frac { 1 } { 2 } T ( 1 - 2 \epsilon ) ^ { 2 } \right) \end{aligned} \right.</script><blockquote><p>$P ( H ( n ) \leqslant k )$ 是另一种写法，含义相同。</p><p>由这条表达式，我们有：</p><script type="math/tex; mode=display">h _ { i } ( x ) = \left\{ \begin{array} { c c } { 1 } & { C _ { n } ^ { x } p ^ { x } ( 1 - p ) ^ { n - x } > = 0.5 } \\ { - 1 } & { C _ { n } ^ { x } p ^ { x } ( 1 - p ) ^ { n - x } < 0.5 } \end{array} \right.</script></blockquote><p>第一个等号表示 $n$ 个基学习器中分类正确的个数小于 $k$ 的概率。若假定集成通过简单投票法结合 $n$ 个分类器，超过半数的基学习器正确，则集成分类就正确，即临界值 $k=0.5*n=(1−ϵ−\delta)n$ 。</p><p>第二个等号的 Hoeffding 不等式的定义，$δ &gt; 0$ ：</p><script type="math/tex; mode=display">P ( H ( n ) \leqslant ( p - \delta ) n ) \leqslant e ^ { - 2 \delta ^ { 2 } n }</script><p>其中 $\left( \begin{array} { l } { T } \\ { k } \end{array} \right)$ 表示 $C_{T} ^{k}$ ，$\delta = 0.5-\epsilon$ 。</p><blockquote><p>Ps: n 和 T 等价。</p></blockquote><p>当 $\epsilon &gt;=0.5$ 时，上式不成立。随着集成中个体分类器数目 $T$ 的增大，集成的错误率将指数级下降，最终趋向于零。</p><blockquote><p>在现实中，个体学习器是解决同一个问题训练出来的，它们不可能相互独立，如何生成不同的个体学习器，是集成学习研究的核心。</p></blockquote><p>根据个体学习器的生成方式，目前集成学习方法大致分为两大类：<strong>个体学习期之间存在强依赖关系、必须串行生成的序列化方法—— Boosting</strong>；<strong>个体学习器之间不能存在强依赖关系、可同时生成的并行化方法—— Bagging</strong>。</p><h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><blockquote><p>先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本进行调整，使得先前基学习器出错的训练样本在后续受到更多关注，然后基于调整后的样本分布来训练下一个基学习器。</p></blockquote><h3 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h3><p>只适用二分类任务，比较容易理解的是基于“加性模型” additive model ，即基学习器的线性组合：</p><script type="math/tex; mode=display">H ( \boldsymbol { x } ) = \sum _ { t = 1 } ^ { T } \alpha _ { t } h _ { t } ( \boldsymbol { x } )</script><p>最小化指数损失函数：</p><script type="math/tex; mode=display">\ell _ { \mathrm { exp } } ( H | \mathcal { D } ) = \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H ( \boldsymbol { x } ) } \right]</script><p>$f(x)$ 只有两个结果，1 或 -1 ：</p><script type="math/tex; mode=display">\ell _ { \mathrm { exp } } ( H | \mathcal { D } ) = e^{-H(x)}P(f(x)=1)+e^{H(x)}P(f(x)=-1)</script><p>若 $H(x)$ 可以将损失函数最小化，那么对它求偏导：</p><script type="math/tex; mode=display">\frac { \partial \ell _ { \operatorname { exp } } ( H | \mathcal { D } ) } { \partial H ( \boldsymbol { x } ) } = - e ^ { - H ( \boldsymbol { x } ) } P ( f ( \boldsymbol { x } ) = 1 | \boldsymbol { x } ) + e ^ { H ( \boldsymbol { x } ) } P ( f ( \boldsymbol { x } ) = - 1 | \boldsymbol { x } )</script><p>显然，令上式为0，可以解出：</p><script type="math/tex; mode=display">H ( \boldsymbol { x } ) = \frac { 1 } { 2 } \ln \frac { P ( f ( x ) = 1 | \boldsymbol { x } ) } { P ( f ( x ) = - 1 | \boldsymbol { x } ) }</script><p>因此：</p><script type="math/tex; mode=display">\begin{aligned}\operatorname { sign } ( H ( \boldsymbol { x } ) ) &= \operatorname { sign } \left( \frac { 1 } { 2 } \ln \frac { P ( f ( x ) = 1 | \boldsymbol { x } ) } { P ( f ( x ) = - 1 | \boldsymbol { x } ) } \right)\\&=\left\{ \begin{array} { l l } { 1 , } & { P ( f ( x ) = 1 | \boldsymbol { x } ) > P ( f ( x ) = - 1 | \boldsymbol { x } ) } \\ { - 1 , } & { P ( f ( x ) = 1 | \boldsymbol { x } ) < P ( f ( x ) = - 1 | \boldsymbol { x } ) } \end{array} \right.\\&=\underset { y \in \{ - 1,1 \} } { \arg \max } P ( f ( x ) = y | \boldsymbol { x } )\end{aligned}</script><p>我们发现，因为本身是二分类问题，特性非常优秀，指数损失函数最小化，则分类错误率也将最小，即达到了贝叶斯最优错误率。</p><p>因为我们的基分类器前面还有参数，当基分类器得到以后，该基分类器的权重 $a_{t}$ 应该使得 $a_{t}h_{t}$ 最小化指数损失函数:</p><script type="math/tex; mode=display">\begin{aligned}\ell _ { \exp } \left( \alpha _ { t } h _ { t } | \mathcal { D } _ { t } \right)&= \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } _ { t } } \left[ e ^ { - f ( \boldsymbol { x } ) \alpha _ { t } h _ { t } ( \boldsymbol { x } ) } \right] \\ &= \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } _ { t } } \left[ e ^ { - \alpha _ { t } } \mathbb { I } \left( f ( \boldsymbol { x } ) = h _ { t } ( \boldsymbol { x } ) \right) + e ^ { \alpha _ { t } } \mathbb { I } \left( f ( \boldsymbol { x } ) \neq h _ { t } ( \boldsymbol { x } ) \right) \right] \\ &= e ^ { - \alpha _ { i } } P _ { \boldsymbol { x } \sim \mathcal { D } _ { t } } \left( f ( \boldsymbol { x } ) = h _ { t } ( \boldsymbol { x } ) \right) + e ^ { \alpha _ { i } } P _ { \boldsymbol { x } \sim \mathcal { D } _ { t } } \left( f ( \boldsymbol { x } ) \neq h _ { t } ( \boldsymbol { x } ) \right) \\&=e ^ { - \alpha _ { t } } \left( 1 - \epsilon _ { t } \right) + e ^ { \alpha _ { t } } \epsilon _ { t }\end{aligned}</script><p>其中 $\epsilon _ { t } = P _ { x \sim \mathcal { D } _ { t } } \left( h _ { t } ( \boldsymbol { x } ) \neq f ( \boldsymbol { x } ) \right)$ ，考虑指数损失函数的导数：</p><script type="math/tex; mode=display">\frac { \partial \ell _ { \exp } \left( \alpha _ { t } h _ { t } | \mathcal { D } _ { t } \right) } { \partial \alpha _ { t } } = - e ^ { - \alpha _ { t } } \left( 1 - \epsilon _ { t } \right) + e ^ { \alpha _ { t } } \epsilon _ { t }</script><p>上式为0，可以得到<strong>权重更新公式</strong>：</p><script type="math/tex; mode=display">\alpha _ { t } = \frac { 1 } { 2 } \ln \left( \frac { 1 - \epsilon _ { t } } { \epsilon _ { t } } \right)</script><hr><p>AdaBoost 算法在下一轮基学习中纠正错误，那么：</p><script type="math/tex; mode=display">\begin{aligned}\ell _ { \exp } \left( H _ { t - 1 } + h _ { t } | \mathcal { D } \right) &= \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) \left( H _ { t - 1 } ( \boldsymbol { x } ) + h _ { t } ( \boldsymbol { x } ) \right) } \right]\\&=\mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } e ^ { - f ( \boldsymbol { x } ) h _ { t } ( \boldsymbol { x } ) } \right]\end{aligned}</script><p>它可以进行泰勒展开，同时注意到 $f ^ { 2 } ( x ) = h _ { t } ^ { 2 } ( x ) = 1$ ：</p><script type="math/tex; mode=display">\begin{aligned}\ell _ { \exp } \left( H _ { t - 1 } + h _ { t } | \mathcal { D } \right) &\simeq \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } \left( 1 - f ( \boldsymbol { x } ) h _ { t } ( \boldsymbol { x } ) + \frac { f ^ { 2 } ( \boldsymbol { x } ) h _ { t } ^ { 2 } ( \boldsymbol { x } ) } { 2 } \right) \right]\\&=\mathbb { E } _ { x \sim \mathcal { D } } \left[ e ^ { - f ( x ) H _ { t - 1 } ( x ) } \left( 1 - f ( x ) h _ { t } ( x ) + \frac { 1 } { 2 } \right) \right]\end{aligned}</script><p>理想的基学习器：</p><script type="math/tex; mode=display">\begin{aligned}h _ { t } ( \boldsymbol { x } ) &= \underset { \boldsymbol { h } } { \arg \min } \ell _ { \exp } \left( H _ { t - 1 } + h | \mathcal { D } \right)\\&=\underset { h } { \arg \min } \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } \left( 1 - f ( \boldsymbol { x } ) h ( \boldsymbol { x } ) + \frac { 1 } { 2 } \right) \right]\\&=\underset { h } { \arg \max } \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } f ( \boldsymbol { x } ) h ( \boldsymbol { x } ) \right]\\&=\underset { h } { \arg \max } \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } [ \frac { e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } } { \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } [ e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } )  }] } f ( \boldsymbol { x } ) h ( \boldsymbol { x } ) ]\end{aligned}</script><p>因为 $\mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } \right]$ 是一个常数，令 $\mathcal { D } _ { t }$ 表示一个分布：</p><script type="math/tex; mode=display">\mathcal { D } _ { t } ( \boldsymbol { x } ) = \frac { \mathcal { D } ( \boldsymbol { x } ) e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } } { \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { w } ) } \right] }</script><p>这等价于令：</p><script type="math/tex; mode=display">\left.\begin{aligned} h _ { t } ( \boldsymbol { x } ) & = \underset { \boldsymbol { h } } { \arg \max } \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ \frac { e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } } { \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } \right] } f ( \boldsymbol { x } ) h ( \boldsymbol { x } ) \right] \\ & = \underset { \boldsymbol { h } } { \arg \max } \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } _ { t } } [ f ( \boldsymbol { x } ) h ( \boldsymbol { x } ) ] \end{aligned} \right.</script><p>由于 $f ( x ) , h ( x ) \in \{ - 1 , + 1 \}$ ，有：</p><script type="math/tex; mode=display">f ( \boldsymbol { x } ) h ( \boldsymbol { x } ) = 1 - 2 \mathbb { I } ( f ( \boldsymbol { x } ) \neq h ( \boldsymbol { x } ) )</script><p>那么理想的基学习器：</p><script type="math/tex; mode=display">h _ { t } ( \boldsymbol { x } ) = \underset { h } { \arg \min } \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } _ { t } } [ \mathbb { I } ( f ( \boldsymbol { x } ) \neq h ( \boldsymbol { x } ) ) ]</script><p>在分布 $D_{t}$ 下最小化分类误差，<strong>样本分布更新公式</strong>：</p><script type="math/tex; mode=display">\begin{aligned}\mathcal { D } _ { t + 1 } ( \boldsymbol { x } ) &= \frac { \mathcal { D } ( \boldsymbol { x } ) e ^ { - f ( \boldsymbol { x } ) H _ { t } ( \boldsymbol { x } ) } } { \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t } ( \boldsymbol { x } ) } \right] }\\&= \frac { \mathcal { D } ( \boldsymbol { x } ) e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } e ^ { - f ( \boldsymbol { x } ) \alpha _ { t } h _ { t } ( \boldsymbol { x } ) } } { \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t } ( \boldsymbol { x } ) } \right] }\\&=\mathcal { D } _ { t } ( \boldsymbol { x } ) \cdot e ^ { - f ( \boldsymbol { x } ) \alpha _ { t } h _ { t } ( \boldsymbol { x } ) } \frac { \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t - 1 } ( \boldsymbol { x } ) } \right] } { \mathbb { E } _ { \boldsymbol { x } \sim \mathcal { D } } \left[ e ^ { - f ( \boldsymbol { x } ) H _ { t } ( \boldsymbol { x } ) } \right] }\end{aligned}</script><blockquote><p>重赋权法：根据样本分布为每个样本重新赋予一个权重。</p><p>重采样法：根据样本分布对训练集重新采样，再用采样样本集对基学习器进行训练。</p><p>Boosting 主要关注降低偏差，因此 Boosting 能基于泛化性能相当弱的学习器构建很强的集成。</p></blockquote><h3 id="AdaBoost-算法的误差分析"><a href="#AdaBoost-算法的误差分析" class="headerlink" title="AdaBoost 算法的误差分析"></a>AdaBoost 算法的误差分析</h3><p>AdaBoost 能够在学习过程中不断减少训练误差，即在训练数据集上的分类误差，所以，有以下定理，AdaBoost 算法最终分类器的训练误差界（<strong>定理1：AdaBoost 的训练误差界</strong>）为：</p><script type="math/tex; mode=display">\frac { 1 } { N } \sum _ { i = 1 } ^ { N } I \left( G \left( x _ { i } \right) \neq y _ { i } \right) \leqslant \frac { 1 } { N } \sum _ { i } \exp \left( - y _ { i } f \left( x _ { i } \right) \right) = \prod _ { m } Z _ { m }</script><p>这里的 $G(x)$ 就是我们的 $h_{i}(x)$ ，$f(x)$ 是正确结果，$Z_{m}$ 是规范化因子。</p><hr><p>首先，我们知道：</p><script type="math/tex; mode=display">w _ { m + 1 , i } = \frac { w _ { m i } } { Z _ { m } } \exp \left( - \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right) , \quad i = 1,2 , \cdots , N</script><p>我们使 $D_{m+1}$ 成为一个概率分布，通过：</p><script type="math/tex; mode=display">Z _ { m } = \sum _ { i = 1 } ^ { N } w _ { m i } \exp \left( - \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right)</script><p>所以可以推出：</p><script type="math/tex; mode=display">w _ { m i } \exp \left( - \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right) = Z _ { m } w _ { m + 1 , i }</script><hr><p>上面式子的前半部分是显然的，当 $G(x_{i}) ≠ y_{i}，y_{i}f(x_{i})&lt;0$ 所以后面的结果一定大于 1 。然后的等号推导如下：</p><script type="math/tex; mode=display">\left.\begin{aligned} \frac { 1 } { N } \sum _ { i } \exp \left( - y _ { i } f \left( x _ { i } \right) \right) & = \frac { 1 } { N } \sum _ { i } \exp \left( - \sum _ { m = 1 } ^ { M } \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right) \\ & = \sum _ { i } w _ { 1 i } \prod _ { m = 1 } ^ { M } \exp \left( - \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right) \\ & = Z _ { 1 } \sum _ { i } w _ { 2 i } \prod _ { m = 2 } ^ { M } \exp \left( - \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right) \\ & = Z _ { 1 } Z _ { 2 } \sum _ { i } w _ { 3 i } \prod _ { m = 3 } ^ { M } \exp \left( - \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right)\\ &=...\\ &=Z _ { 1 } Z _ { 2 } \cdots Z _ { M - 1 } \sum _ { i } w _ { M } \exp \left( - \alpha _ { M } y _ { i } G _ { M } \left( x _ { i } \right) \right)\\ &=\prod _ { m = 1 } ^ { N } z _ { m } \end{aligned} \right.</script><p>现在每一轮选取适当 $G_{m}$ 使得 $Z_{m}$ 最小，从而使训练误差下降最快，对二分类问题，有如下结果（<strong>定理2：二分类问题 AdaBoost 的训练误差界</strong>）：</p><script type="math/tex; mode=display">\prod _ { m = 1 } ^ { M } Z _ { m } = \prod _ { m = 1 } ^ { M } \left[ 2 \sqrt { e _ { m } \left( 1 - e _ { m } \right) } \right] = \prod _ { m = 1 } ^ { M } \sqrt { \left( 1 - 4 \gamma _ { m } ^ { 2 } \right) } \leqslant \exp \left( - 2 \sum _ { m = 1 } ^ { M } \gamma _ { m } ^ { 2 } \right)</script><p>这里，$\gamma _ { m } = \frac { 1 } { 2 } - e _ { m }$ 。</p><p>前两个等号：</p><script type="math/tex; mode=display">\left.\begin{aligned} Z _ { m } & = \sum _ { i = 1 } ^ { N } w _ { m i } \exp \left( - \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right) \\ & = \sum _ { y _ { i } = G _ { m } \left( x _ { i } \right) } w _ { m i } \mathrm { e } ^ { - \alpha _ { m } } + \sum _ { y _ { i } \neq G _ { m } \left( x _ { i } \right) } w _ { m i } \mathrm { e } ^ { \alpha _ { n } } \\ & = \left( 1 - e _ { m } \right) \mathrm { e } ^ { - \alpha _ { m } } + e _ { m } \mathrm { e } ^ { \alpha _ { m } } \\ & = 2 \sqrt { e _ { m } \left( \mathrm { 1 } - e _ { m } \right) } = \sqrt { 1 - 4 \gamma _ { m } ^ { 2 } } \end{aligned} \right.</script><p>然后，对于最后的不等号：</p><script type="math/tex; mode=display">\prod _ { m = 1 } ^ { M } \sqrt { \left( 1 - 4 \gamma _ { m } ^ { 2 } \right) } \leqslant \exp \left( - 2 \sum _ { m = 1 } ^ { M } \gamma _ { m } ^ { 2 } \right)</script><p>可以通过 $e^{x}$ 和 $\sqrt { 1 - x }$ 在点 $x=0$ 处泰勒展开得到。</p><p><strong>推论：</strong>如果存在 $ \gamma &gt; 0$ ，对所有 m 有 $\gamma _ { m } \geqslant \gamma$，则：</p><script type="math/tex; mode=display">\frac { 1 } { N } \sum _ { i = 1 } ^ { N } I \left( G \left( x _ { i } \right) \neq y _ { i } \right) \leqslant \exp \left( - 2 M \gamma ^ { 2 } \right)</script><p>AdaBoost 的训练误差以指数速率下降。</p><h3 id="AdaBoost-算法的解释"><a href="#AdaBoost-算法的解释" class="headerlink" title="AdaBoost 算法的解释"></a>AdaBoost 算法的解释</h3><p>考虑加法模型：</p><script type="math/tex; mode=display">f ( x ) = \sum _ { m = 1 } ^ { M } \beta _ { m } b \left( x ; \gamma _ { m } \right)</script><p>这里，$b(x;\gamma _{m})$ 是基函数， $\gamma_{m}$ 是基函数的参数，$\beta _{m}$ 是基函数的系数，显然，这是一个加法模型。</p><p>在给定训练数据和损失函数 $L(y,f(x))$ 的条件下，学习加法模型 $f(x)$ 成为经验风险极小化即损失函数极小化问题：</p><script type="math/tex; mode=display">\min _ { \beta , \gamma } \sum _ { i = 1 } ^ { N } L \left( y _ { i } , \beta b \left( x _ { i } ; \gamma \right) \right)</script><p>给定训练数据集 $T = \left\{ \left( x _ { 1 } , y _ { 1 } \right) , \left( x _ { 2 } , y _ { 2 } \right) , \cdots , \left( x _ { N } , y _ { N } \right) \right\}$ ，学习加法模型 $f(x)$ 的前向分布算法如下：</p><ol><li>初始化 $f _ { 0 } ( x ) = 0$ </li><li>循环开始 $m = 1… M$ </li><li>极小化损失函数：$\left( \beta _ { m } , \gamma _ { m } \right) = \arg \min _ { \beta , \gamma } \sum _ { i = 1 } ^ { N } L \left( y _ { i } , f _ { m - 1 } \left( x _ { i } \right) + \beta b \left( x _ { i } ; \gamma \right) \right)$ </li><li>得到参数 $\beta_{m}$ 和 $\gamma_{m}$ ，更新：$f _ { m } ( x ) = f _ { m - 1 } ( x ) + \beta _ { m } b \left( x ; \gamma _ { m } \right)$ </li><li>最终，得到加法模型： $f ( x ) = f _ { M } ( x ) = \sum _ { m = 1 } ^ { M } \beta _ { m } b \left( x ; \gamma _ { m } \right)$ </li></ol><p>现在，前向分布算法，将问题简化为逐次求解各个参数 $\beta_{m}$ 和 $\gamma_{m}$ 。</p><p><strong>定理</strong>：AdaBoost 算法是前向分布加法算法的特例，这时，模型是由基本分类器组成的加法模型，损失函数是指数函数。</p><h3 id="AdaBoost-小结"><a href="#AdaBoost-小结" class="headerlink" title="AdaBoost 小结"></a>AdaBoost 小结</h3><p>训练数据中每个样本赋予一个权重，这个权重构成了向量 D ，之后分对的样本权重降低，分错的样本权重增高，构成新的 D ，同时 AdaBoost 为每个分类器都分配一个权重值 alpha：</p><script type="math/tex; mode=display">\alpha = \frac { 1 } { 2 } \ln \left( \frac { 1 - \varepsilon } { \varepsilon } \right)</script><p>而分布 D :</p><script type="math/tex; mode=display">D _ { i } ^ { ( t + 1 ) } = \frac { D _ { i } ^ { ( t ) } \mathrm { e } ^ { \pm \alpha } } { \operatorname { Sum } ( D ) }</script><p>进行下一轮迭代。</p><h3 id="提升树"><a href="#提升树" class="headerlink" title="提升树"></a>提升树</h3><p>以决策树为基函数的提升方法被称为提升树，对分类问题决策树是二叉分类树，对回归问题决策树是二叉回归树。提升树可以表示为决策树的加法模型：</p><script type="math/tex; mode=display">f _ { M } ( x ) = \sum _ { m = 1 } ^ { M } T \left( x ; \Theta _ { m } \right)</script><p>其中 $T \left( x ; \Theta _ { n } \right)$ 表示决策树；$\Theta _ { n }$ 表示决策树的参数； $M$ 是树的个数。</p><p>提升树算法采用<strong>前向分步算法</strong>。首先确定初始提升树 $f_{0}(x)=0$ ，第 m 步的模型是：</p><script type="math/tex; mode=display">f _ { m } ( x ) = f _ { m - 1 } ( x ) + T \left( x ; \Theta _ { m } \right)</script><p>通过<strong>经验风险极小化</strong>确定下一棵决策树的参数：</p><script type="math/tex; mode=display">\hat { \Theta } _ { m } = \arg \min _ { \boldsymbol { \theta } _ { \boldsymbol { e } } } \sum _ { i = 1 } ^ { N } L \left( y _ { i } , f _ { m - 1 } \left( x _ { i } \right) + T \left( x _ { i } ; \Theta _ { m } \right) \right)</script><blockquote><p>这里的 $T$ 指的就是下一棵决策树。</p></blockquote><p>不同问题的提升树学习算法，主要区别在于使用的损失函数不同，平方误差损失函数的回归问题，指数损失函数的分类问题。下面叙述回归问题的提升树：</p><script type="math/tex; mode=display">T ( x ; \Theta ) = \sum _ { j = 1 } ^ { J } c _ { j } I \left( x \in R _ { j } \right)</script><p>x 是输入， y 是输出，c 是输出常量，J 是回归树的复杂度即叶节点的个数，$\Theta = \left\{ \left( R _ { 1 } , c _ { 1 } \right) , \left( R _ { 2 } , c _ { 2 } \right) , \cdots , \left( R _ { J } , c _ { J } \right) \right\}$ 表示树的区域划分和各区域上的常数。</p><p>回归问题提升树使用以下前向分布算法：</p><script type="math/tex; mode=display">\begin{aligned}f _ { 0 } ( x ) &= 0 \\  f _ { m } ( x ) &= f _ { m - 1 } ( x ) + T \left( x ; \Theta _ { m } \right) , \quad m = 1,2 , \cdots , M \\ f _ { M } ( x ) &= \sum _ { m = 1 } ^ { M } T \left( x ; \Theta _ { m } \right)\end{aligned}</script><p>在前向分布算法的第 m 步，给定当前模型 $f_{m-1}(x)$ ，需求解：</p><script type="math/tex; mode=display">\hat { \Theta } _ { m } = \arg \min _ { \Theta _ { m } } \sum _ { i = 1 } ^ { N } L \left( y _ { i } , f _ { m - 1 } \left( x _ { i } \right) + T \left( x _ { i } ; \Theta _ { m } \right) \right)</script><p>当使用平方误差损失函数时：</p><script type="math/tex; mode=display">L ( y , f ( x ) ) = ( y - f ( x ) ) ^ { 2 }</script><p>其损失变为：</p><script type="math/tex; mode=display">\left.\begin{aligned} L \left( y , f _ { m - 1 } ( x ) + T \left( x ; \Theta _ { m } \right) \right) & = \left[ y - f _ { m - 1 } ( x ) - T \left( x ; \Theta _ { m } \right) \right] ^ { 2 } \\ & = \left[ r - T \left( x ; \Theta _ { m } \right) \right] ^ { 2 } \end{aligned} \right.</script><p>这里， $r = y - f _ { m - 1 } ( x )$ ，是当前模型拟合数据的残差。</p><p>所以，对回归问题的提升树来说，只需要简单地拟合当前模型的残差，这样，算法就相当简单。</p><p><strong>回归问题的提升树算法</strong>：</p><p>输入：训练数据集 $T={(x1,y1),(x2,y2),…(xn,yn)}, xi, yi$ </p><p>输出：提升树 $f_{M}(x)$ </p><ol><li>初始化 $f_{0}(x)=0$ </li><li>开始循环 m = 1,2,…M</li><li>计算残差：$r _ { m i } = y _ { i } - f _ { m - 1 } \left( x _ { i } \right) , \quad i = 1,2 , \cdots , N$ </li><li>拟合残差 $r_{mi}$ 学习一个回归树，得到 $T \left( x ; \Theta _ { m } \right)$ </li><li>更新 $f _ { m } ( x ) = f _ { m - 1 } ( x ) + T \left( x ; \Theta _ { m } \right)$ </li><li>对第 3 步到第 5 步进行循环</li><li>得到回归问题提升树 $f _ { M } ( x ) = \sum _ { m = 1 } ^ { M } T \left( x ; \Theta _ { m } \right)$ </li></ol><h3 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h3><p>提升树利用加法模型和前向分布算法实现学习的优化过程，当损失函数是平方损失和指数损失的时候，每一步优化是很简单的，但一般损失函数而言，往往每一步优化并不容易，针对这一问题，出现了梯度提升。</p><p>这是利用最速下降法的近似方法，其关键是利用损失函数的负梯度在当前模型的值，主要不同就是残差的计算方式：</p><script type="math/tex; mode=display">- \left[ \frac { \partial L \left( y , f \left( x _ { i } \right) \right) } { \partial f \left( x _ { i } \right) } \right] _ { f ( x ) = f _ { m - 1 } ( x ) }</script><p>作为回归问题提升树算法中的残差的近似值。</p><p>输入：训练数据集 $T={(x1,y1),(x2,y2),…(xn,yn)}, xi, yi$ ；损失函数 $L(y,f(x))$ </p><p>输出：回归树 $\hat { f } ( x )$ </p><ol><li>初始化：$f _ { 0 } ( x ) = \arg \min _ { c } \sum _ { i = 1 } ^ { N } L \left( y _ { i } , c \right)$ </li><li>开始循环 m 从 1 到 M</li><li>对于 i 从 1 到 N ，计算： $r _ { m l } = - \left[ \frac { \partial L \left( y _ { i } , f \left( x _ { i } \right) \right) } { \partial f \left( x _ { i } \right) } \right] _ { f ( x ) = f _ { m- 1 } ( x ) }$ </li><li>对 $r_{mi}$ 拟合一个回归树，得到第 m 棵树的叶节点区域 $R_{mj}$</li><li>对 j 从 1 到 J ，计算：$c _ { m j } = \arg \min _ { c } \sum _ { x _ { i } \in R _ { mj } } L \left( y _ { i } , f _ { m - 1 } \left( x _ { i } \right) + c \right)$ </li><li>更新 $f _ { m } ( x ) = f _ { m - 1 } ( x ) + \sum _ { j = 1 } ^ { J } c _ { m j } I \left( x \in R _ { m j } \right)$ </li><li>得到回归树 $\hat { f } ( x ) = f _ { M } ( x ) = \sum _ { m = 1 } ^ { M } \sum _ { j = 1 } ^ { J } c _ { m j } I \left( x \in R _ { m j } \right)$ </li></ol><h3 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h3><p>原始的 GBDT 算法基于经验损失函数的负梯度来构造新的决策树，只是在决策树构建完成后再进行剪枝，而 XGBoost 在决策树构建阶段就加入了正则化：</p><script type="math/tex; mode=display">L_{t} = \sum _ { i = 1 } ^ { n } l \left( y _ { i } , F_{t-1}(x_{i})+f_{t}(x_{i}) \right) + \sum _ { k = 1 } ^ { K } \Omega \left( f _ { k } \right)</script><p>对于上面的式子，我们可以发现，除去正则项以外，就是我们传统的决策树。对于决定下一棵树：</p><script type="math/tex; mode=display">\left.\begin{aligned} \mathrm { obj } ^ { ( t ) } & = \sum _ { i = 1 } ^ { n } l \left( y _ { i } , \hat { y } _ { i } ^ { ( t ) } \right) + \sum _ { i = 1 } ^ { t } \Omega \left( f _ { i } \right) \\ & = \sum _ { i = 1 } ^ { n } l \left( y _ { i } , \hat { y } _ { i } ^ { ( t - 1 ) } + f _ { t } \left( x _ { i } \right) \right) + \Omega \left( f _ { t } \right) + \text { constant } \end{aligned} \right.</script><p>现在我们使用泰勒展开， $x$ 取值 $\hat { y } _ { i } ^ { ( t - 1 ) } + f _ { t } \left( x _ { i } \right)$ ，来逼近：</p><script type="math/tex; mode=display">\mathrm { obj } ^ { ( t ) } = \sum _ { i = 1 } ^ { n } \left[ l \left( y _ { i } , \hat { y } _ { i } ^ { ( t - 1 ) } \right) + g _ { i } f _ { t } \left( x _ { i } \right) + \frac { 1 } { 2 } h _ { i } f _ { t } ^ { 2 } \left( x _ { i } \right) \right] + \Omega \left( f _ { t } \right) + \text { constant }</script><p>其中：</p><script type="math/tex; mode=display">\left.\begin{aligned} g _ { i } & = \partial _ { \hat { y } _ { i } ( t - 1 ) } l \left( y _ { i } , \hat { y } _ { i } ^ { ( t - 1 ) } \right) \\ h _ { i } & = \partial _ { \hat { y } _ { i } ^ { ( t - 1 ) } } ^ { 2 } l \left( y _ { i } , \hat { y } _ { i } ^ { ( t - 1 ) } \right) \end{aligned} \right.</script><p>删除常数项，那么 t 目标函数就变成了：</p><script type="math/tex; mode=display">\sum _ { i = 1 } ^ { n } \left[ g _ { i } f _ { t } \left( x _ { i } \right) + \frac { 1 } { 2 } h _ { i } f _ { t } ^ { 2 } \left( x _ { i } \right) \right] + \Omega \left( f _ { t } \right)</script><p>我们需要定义树的复杂度 $\Omega ( f )$ ，首先我们定义一棵树：</p><script type="math/tex; mode=display">f _ { t } ( x ) = w _ { q ( x ) } , w \in R ^ { T } , q : R ^ { d } \rightarrow \{ 1,2 , \cdots , T \}</script><p>这里 w 是树叶上的分数向量，q 是将每个数据点分配给叶子的函数，T 是树叶的数量。正则化定义：</p><script type="math/tex; mode=display">\Omega \left( f _ { t } \right) = \gamma T + \frac { 1 } { 2 } \lambda \sum _ { j = 1 } ^ { T } w _ { j } ^ { 2 }</script><p>注意，当正则项系数为 $\gamma$ 为 0 时，整体目标就退化回了 GBDT 。</p><p>我们可以用第 t 棵树来编写目标值如：</p><script type="math/tex; mode=display">\left.\begin{aligned} O b j ^ { ( t ) } & \approx \sum _ { i = 1 } ^ { n } \left[ g _ { i } w _ { q \left( x _ { i } \right) } + \frac { 1 } { 2 } h _ { i } w _ { q \left( x _ { i } \right) } ^ { 2 } \right] + \gamma T + \frac { 1 } { 2 } \lambda \sum _ { j = 1 } ^ { T } w _ { j } ^ { 2 } \\ & = \sum _ { j = 1 } ^ { T } \left[ \left( \sum _ { i \in I _ { j } } g _ { i } \right) w _ { j } + \frac { 1 } { 2 } \left( \sum _ { i \in I _ { j } } h _ { i } + \lambda \right) w _ { j } ^ { 2 } \right] + \gamma T \end{aligned} \right.</script><p>其中 $I _ { j } = \{ i | q \left( x _ { i } \right) = j \}$ 是分配给第 j 个叶子的数据点的索引的集合。 请注意，在第二行中，我们更改了总和的索引，因为同一叶上的所有数据点都得到了相同的分数。 我们可以通过定义 $G _ { j } = \sum _ { i \in I _ { j } } g _ { i }$ 和 $H _ { j } = \sum _ { i \in I _ { j } } h _ { i }$ 来进一步压缩表达式 :</p><script type="math/tex; mode=display">O b j ^ { ( t ) } = \sum _ { j = 1 } ^ { T } \left[ G _ { j } w _ { j } + \frac { 1 } { 2 } \left( H _ { j } + \lambda \right) w _ { j } ^ { 2 } \right] + \gamma T</script><p>我们可以得到最好的客观规约：</p><script type="math/tex; mode=display">w _ { j } ^ { * } = - \frac { G _ { j } } { H _ { j } + \lambda }</script><p>将预测值带入损失函数可以得到损失函数的最小值，同时也在度量一个树有多好：</p><script type="math/tex; mode=display">{ Obj } _ { t } ^ { * } = - \frac { 1 } { 2 } \sum _ { j = 1 } ^ { T } \frac { G _ { j } ^ { 2 } } { H _ { j } + \lambda } + \gamma T</script><p>既然我们有了一个方法来衡量一棵树有多好，理想情况下我们会列举所有可能的树并挑选出最好的树。 在实践中，这种方法是比较棘手的，所以我们会尽量一次优化树的一个层次。 具体来说，我们试图将一片叶子分成两片，并得到分数：</p><script type="math/tex; mode=display">\text { Gain } = \frac { 1 } { 2 } \left[ \frac { G _ { L } ^ { 2 } } { H _ { L } + \lambda } + \frac { G _ { R } ^ { 2 } } { H _ { R } + \lambda } - \frac { \left( G _ { L } + G _ { R } \right) ^ { 2 } } { H _ { L } + H _ { R } + \lambda } \right] - \gamma</script><p>这个公式可以分解为 1) 新左叶上的得分 2) 新右叶上的得分 3) 原始叶子上的得分 4) additional leaf（附加叶子）上的正则化。 我们可以在这里看到一个重要的事实：如果增益小于 γ，我们最好不要添加那个分支。这正是基于树模型的 <strong>pruning（剪枝）</strong> 技术！通过使用监督学习的原则，我们自然会想出这些技术工作的原因 :)</p><p>另外，在分割的时候，这个系统还能感知稀疏值，我们给每个树的结点都加了一个默认方向，当一个值是缺失值时，我们就把他分类到默认方向，每个分支有两个选择，具体应该选哪个？这里提出一个算法，枚举向左和向右的情况，哪个 gain 大选哪个，这些都在这里完成。</p><p>总结一下，XGBoost 就是最大化这个差来进行决策树的构建，XGBoost 和 GDBT 的差别和联系：</p><ul><li>GDBT 是机器学习算法， XGBoost 是该算法的工程实现。</li><li>XGBoost 加入了正则化，支持多种类型的基分类器，支持对数据采样（和 RF 类似），能对缺省值处理。</li></ul><blockquote><p>ps: 论文第二章里提到了shrinkage 和 column subsampling，就是相当于学习速率和对于列的采样骚操作。<strong>调低 eta 能减少个体的影响，给后续的模型更多学习空间</strong>。对于列的重采样，根据一些使用者反馈，列的 subsampling 比行的 subsampling 效果好，列的 subsampling 也加速了并行化的特征筛选。</p></blockquote><h3 id="XGBoost-的调参"><a href="#XGBoost-的调参" class="headerlink" title="XGBoost 的调参"></a>XGBoost 的调参</h3><ul><li>过拟合：</li></ul><blockquote><p>直接控制模型的复杂度：</p><ul><li>这包括 <code>max_depth</code>, <code>min_child_weight</code> 和 <code>gamma</code></li></ul><p>增加随机性，使训练对噪声强健：</p><ul><li>这包括 <code>subsample</code>, <code>colsample_bytree</code></li><li>你也可以减小步长 <code>eta</code>, 但是当你这么做的时候需要记得增加 <code>num_round</code> 。</li></ul></blockquote><ul><li>不平衡的数据集</li></ul><blockquote><p>如果你只关心预测的排名顺序：</p><ul><li>通过 <code>scale_pos_weight</code> 来平衡 positive 和 negative 权重。</li><li>使用 AUC 进行评估</li></ul><p>如果你关心预测正确的概率：</p><ul><li>在这种情况下，您无法重新平衡数据集</li><li>在这种情况下，将参数 <code>max_delta_step</code> 设置为有限数字（比如说1）将有助于收敛</li></ul></blockquote><h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p>给定包含 m 个样本的数据集，随机取出一个样本放到采样集中，再把样本放回初始数据集，使得下次采样时仍有可能被选中，经过 m 次随机采样，我们得到含 m 个样本的采样集，初始训练集中有的样本在采样集有多次出现，有的则从未出现。</p><p>Bagging 可以不经修改用于多分类、回归等任务。</p><p>因为 Bagging 只使用了部分数据，剩下的可以用作验证集，称为包外估计 out-of-bag estimate ：</p><script type="math/tex; mode=display">H ^ { o o b } ( x ) = \underset { y \in \mathcal { Y } } { \arg \max } \sum _ { t = 1 } ^ { T } \mathbb { I } \left( h _ { t } ( \boldsymbol { x } ) = y \right) \cdot \mathbb { I } \left( \boldsymbol { x } \notin D _ { t } \right)</script><p>则泛化误差的包外估计是：</p><script type="math/tex; mode=display">\epsilon ^ { o o b } = \frac { 1 } { | D | } \sum _ { ( \boldsymbol { x } , y ) \in D } \mathbb { I } \left( H ^ { o o b } ( \boldsymbol { x } ) \neq y \right)</script><blockquote><p>Bagging 主要关注降低方差，因此它在不剪枝决策树、神经网络等易受样本扰动的学习器上效用更明显。</p></blockquote><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>在 Bagging 的基础上，进一步引入随机属性选择，假定决策树有 d 个属性，现在我们只随机选择 k 个属性的子集，然后在这个子集中选择一个最优属性进行划分，推荐 $k = log_{2}d$ 。</p><p>随机森林通常会训练效率优于 Bagging ，且随着学习器数目的增加，通常会收敛到更低的泛化误差。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="AdaBoost-伪码"><a href="#AdaBoost-伪码" class="headerlink" title="AdaBoost 伪码"></a>AdaBoost 伪码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">训练集 D = &#123;(x1, y1), (x2, y2)..., (xm, ym)&#125;</span></span><br><span class="line"><span class="string">基学习算法 L</span></span><br><span class="line"><span class="string">训练轮数 T</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">D[<span class="number">1</span>] = <span class="number">1</span>/m <span class="comment"># 初始化样本权值分布</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(T):</span><br><span class="line">  h[t] = L(D, D[t]) <span class="comment"># 基于分布 Dt 从数据集 D 中训练处分类器 ht</span></span><br><span class="line">  e[t] = P(ht(x), f(x)) <span class="comment"># 分类器 ht 的误差， ht(x) 是预测结果， f(x) 是真实结果</span></span><br><span class="line">  <span class="keyword">if</span> e[t] &gt; <span class="number">0.5</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  a[t] = <span class="number">0.5</span>*np.log((<span class="number">1</span>-e[t])/e[t])</span><br><span class="line">  D[t+<span class="number">1</span>] = D[t] / Z[t] <span class="comment"># Zt 是规范化因子</span></span><br><span class="line">  <span class="keyword">if</span> (h[t](x) == f(x)) D[t+<span class="number">1</span>] *= exp(-a[t]) <span class="comment"># 更新 D[t+1] 的权重</span></span><br><span class="line">  <span class="keyword">else</span> D[t+<span class="number">1</span>] *= exp(a[t])</span><br></pre></td></tr></table></figure><p> 最终返回 $H(x) = \operatorname { sign } \left( \sum _ { t = 1 } ^ { T } \alpha _ { t } h _ { t } ( \boldsymbol { x } ) \right)$ 。</p><blockquote><p>sign 表达符号函数。</p></blockquote><h3 id="Bagging-伪码"><a href="#Bagging-伪码" class="headerlink" title="Bagging 伪码"></a>Bagging 伪码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">训练集 D = &#123;(x1, y1), (x2, y2)..., (xm, ym)&#125;</span></span><br><span class="line"><span class="string">基学习算法 L</span></span><br><span class="line"><span class="string">训练轮数 T</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(T):</span><br><span class="line">  h[t] = L(D, D[bs]) <span class="comment"># D[bs] 是自助采样生成的样本分布</span></span><br></pre></td></tr></table></figure><p>最终返回 $H(x) = \underset { y \in \mathcal { Y } } { \arg \max } \sum _ { t = 1 } ^ { T } \mathbb { I } \left( h _ { t } ( \boldsymbol { x } ) = y \right)$ 。</p><h3 id="Stacking-伪码"><a href="#Stacking-伪码" class="headerlink" title="Stacking 伪码"></a>Stacking 伪码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">训练集 D = &#123;(x1, y1), (x2, y2)..., (xm, ym)&#125;</span></span><br><span class="line"><span class="string">初级学习算法 L1, L2, L3...</span></span><br><span class="line"><span class="string">次级学习算法 L</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(T):</span><br><span class="line">  h[t] = L(D) <span class="comment"># 初级学习器</span></span><br><span class="line">D_ = [] <span class="comment"># 生成次级训练集</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">  <span class="keyword">for</span> t <span class="keyword">in</span> range(T):</span><br><span class="line">    z[i][t] = ht(x[i])</span><br><span class="line">  D_ += ((z[i][<span class="number">1</span>], z[i][<span class="number">2</span>]...z[i][T]), y[i]) <span class="comment"># z 是由 x 产生的次级训练样例，标记是 yi</span></span><br><span class="line">h_ = L(D_)</span><br></pre></td></tr></table></figure><p>输出 $H ( \boldsymbol { x } ) = h ^ { \prime } \left( h _ { 1 } ( \boldsymbol { x } ) , h _ { 2 } ( \boldsymbol { x } ) , \ldots , h _ { T } ( \boldsymbol { x } ) \right)$ 。</p><h2 id="算法例子"><a href="#算法例子" class="headerlink" title="算法例子"></a>算法例子</h2><h3 id="AdaBoost-例子"><a href="#AdaBoost-例子" class="headerlink" title="AdaBoost 例子"></a>AdaBoost 例子</h3><p>假设存在3个分类器，对每一个分类器：</p><ul><li>初始化权值 Di。</li><li>取阈值来分类，得到基分类器 hi。</li><li>计算误差率 ei。</li><li>得到分类器系数 ai。</li><li>更新权值 Di+1。</li></ul><p>最后我们将三个分类器按照各自的系数 a 来进行预测，得到整体 H 。</p><p>如果没看懂我们再来一次：</p><p>输入数据集 $T = \left\{ \left( x _ { 1 } , y _ { 1 } \right) , \left( x _ { 2 } , y _ { 2 } \right) , \cdots , \left( x _ { N } , y _ { N } \right) \right\}$ 。</p><p>输出最终分类器 $G(x)$ 。</p><blockquote><p>Ps：刚才我们用 $H$ 来表示分类器。</p></blockquote><ol><li>初始化训练数据的权值分布：$D _ { 1 } = \left( w _ { 11 } , \cdots , w _ { 1 i } , \cdots , w _ { 1 N } \right) , \quad w _ { 1 } = \frac { 1 } { N } , \quad i = 1,2 , \cdots , N$ </li><li>循环开始，对于 $m=1,2,…M$ </li><li>使用具有权值分布 $D_{m}$ 的训练数据学习，得到基本分类器：$G _ { m } ( x ) : \mathcal { X } \rightarrow \{ - 1 , + 1 \}$ </li><li>计算 $G_{m}(x)$ 在训练数据集上的分类误差率：$e _ { m } = P \left( G _ { m } \left( x _ { i } \right) \neq y _ { i } \right) = \sum _ { i = 1 } ^ { N } w _ { m i } I \left( G _ { m } \left( x _ { i } \right) \neq y _ { i } \right)$ </li><li>计算 $G_m(x)$ 的系数：$\alpha _ { m } = \frac { 1 } { 2 } \log \frac { 1 - e _ { m } } { e _ { m } }$ </li><li>更新训练集的权值分布：$D _ { m + 1 } = \left( w _ { m + 1,1 } , \cdots , w _ { m + 1 , l } , \cdots , w _ { m + 1 , N } \right)$ $w _ { m + 1 , i } = \frac { w _ { m i } } { Z _ { m } } \exp \left( - \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right) , \quad i = 1,2 , \cdots , N$ </li><li>这里的 $Z_{m}$ 是规范化因子：$Z _ { m } = \sum _ { i = 1 } ^ { N } w _ { m } \exp \left( - \alpha _ { m } y _ { i } G _ { m } \left( x _ { i } \right) \right)$ ，它使 $D_{m+1}$ 成为一个概率分布</li><li>构建基本分类器的线性组合：$f ( x ) = \sum _ { m = 1 } ^ { M } \alpha _ { m } G _ { m } ( x )$ </li><li>得到最终分类器：$G ( x ) = \operatorname { sign } ( f ( x ) ) = \operatorname { sign } \left( \sum _ { m = 1 } ^ { M } \alpha _ { m } G _ { m } ( x ) \right)$ </li></ol><h2 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h2><ul><li>XGBoost 与 GBDT 的联系与区别有哪些？</li></ul><blockquote><p>GBDT 是机器学习算法；XGBoost 是工程实现。</p><p>传统 GBDT 采用 CART 作为基分类器， XGBoost 支持多种类型的基分类器，比如线性分类器。</p><p>XGBoost 增加了正则项，防止过拟合。</p><p>XGBoost 支持对数据进行采样，对缺失值有处理。</p></blockquote><p>从方差和偏差的角度解释 Boosting 和 Bagging  的原理？</p><h2 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h2><ul><li>提升算法是将弱学习算法提升为强学习算法的统计学习算法，通过反复修改训练数据的权值分布，构建一系列基本分类器，并将这些基本分类器线性组合，构成一个强分类器。</li><li>AdaBoost 将分类误差小的基本分类器以大的权值，给误差大的基本分类器以小的权值。</li><li>提升树是以分类树或回归树为基本分类器的提升方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> boosting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Batch normalization 推导</title>
      <link href="/machine-learning/2018-10-12-batch-normalization/"/>
      <url>/machine-learning/2018-10-12-batch-normalization/</url>
      
        <content type="html"><![CDATA[<h2 id="前向传播阶段"><a href="#前向传播阶段" class="headerlink" title="前向传播阶段"></a>前向传播阶段</h2><p>首先计算一个 batch 的平均：</p><script type="math/tex; mode=display">\mu _ { \mathcal { B } } \leftarrow \frac { 1 } { m } \sum _ { i = 1 } ^ { m } x _ { i }</script><p>然后计算这个 batch 的方差：</p><script type="math/tex; mode=display">\sigma _ { \mathcal { B } } ^ { 2 } \leftarrow \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \left( x _ { i } - \mu _ { \mathcal { B } } \right) ^ { 2 }</script><p>然后就可以进行 normalization 了：</p><script type="math/tex; mode=display">\widehat { x } _ { i } \leftarrow \frac { x _ { i } - \mu _ { \mathcal { B } } } { \sqrt { \sigma _ { \mathcal { B } } ^ { 2 } + \epsilon } }</script><blockquote><p>这一步是为了让输入分布满足标准正态分布，其中在分母上加上 $\epsilon$ 是为了防止分母过小或为 0 。</p></blockquote><p>进行缩放和平移，得到最终结果：</p><script type="math/tex; mode=display">y _ { i } \leftarrow \gamma \widehat { x } _ { i } + \beta \equiv \mathrm { B } \mathrm { N } _ { \gamma , \beta } \left( x _ { i } \right)</script><blockquote><p>从另一个角度看，这个操作就是上一步的反操作，抵消上面 bn 的影响，增强算法的表达能力，在之后，我们还能进行一些其他变换，比如 relu 等。</p></blockquote><p>在训练时就不需要进行 normalization 了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mode == <span class="string">'train'</span>:</span><br><span class="line">  sample_mean = np.mean(x, axis=<span class="number">0</span>)</span><br><span class="line">  sample_var = np.var(x, axis=<span class="number">0</span>)</span><br><span class="line">  x_hat = (x - sample_mean) / np.sqrt(sample_var + eps)</span><br><span class="line">  out = gamma * x_hat + beta</span><br><span class="line">  cache = (gamma, x, sample_mean, sample_var, eps, x_hat)</span><br><span class="line"></span><br><span class="line">  running_mean = momentum * running_mean + (<span class="number">1</span> - momentum) * sample_mean</span><br><span class="line">  running_var = momentum * running_var + (<span class="number">1</span> - momentum) * sample_var</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment"># 不需要进行 normalization</span></span><br><span class="line">  x_hat = (x - running_mean) / np.sqrt(running_var + eps)</span><br><span class="line">  out = gamma * x_hat + beta</span><br></pre></td></tr></table></figure><h2 id="反向传播阶段"><a href="#反向传播阶段" class="headerlink" title="反向传播阶段"></a>反向传播阶段</h2><p>对于 bn 的反向传播，能一步步进行推导，具体可以参考：</p><p><a href="https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html" target="_blank" rel="noopener">Understanding the backward pass through Batch Normalization Layer</a></p><blockquote><p>关键在于仔细。</p></blockquote><p>对于 alternative backward 的推导：</p><p><a href="http://cthorey.github.io./backpropagation/" target="_blank" rel="noopener">What does the gradient flowing through batch normalization looks like</a></p><p>其中最关键的是对于链式损失函数的推导：</p><script type="math/tex; mode=display">\begin{aligned} \frac { d \mathcal { L } } { d x _ { i j } } &= \sum _ { k , l } \frac { d \mathcal { L } } { d y _ { k l } } \frac { d y _ { k l } } { d \hat { x } _ { k l } } \frac { d \hat { x } _ { k l } } { d x _ { i j } } \\ \frac { d \mathcal { L } } { d \gamma _ { j } } &= \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \frac { d y _ { k l } } { d \gamma _ { j } } \\ \frac { d \mathcal { L } } { d \beta _ { j } } &= \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \frac { d y _ { k l } } { d \beta _ { j } } \end{aligned}</script><hr><p>假设，我们对于 x 的 normalization 的情况如下：</p><script type="math/tex; mode=display">\stackrel { \wedge } { x _ { k l } } = x _ { k l } - \mu _ { l }</script><p>也就是说只有位移，没有缩放，那么：</p><script type="math/tex; mode=display">\frac { d \hat { x } _ { k l } } { d x _ { i j } } = \delta _ { i , k } \delta _ { j , l } - \frac { 1 } { N } \delta _ { j , l }</script><p>这里就是该推导的核心部分，对于 $\delta _{i,j}$ 只有当 $i=j$ 时，$\delta$ 为 1 否则为 0 。所以对于上面的式子而言，第一个式子为 1 只有当 $k=i$ 且 $l=j$ ，第二个式子为 $1/N$ 只有当 $l=j$ 。</p><hr><p>从最简单 beta 的开始：</p><script type="math/tex; mode=display">\left.\begin{aligned} \frac { d \mathcal { L } } { d \beta _ { j } } & = \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \frac { d y _ { k l } } { d \beta _ { j } } \\ & = \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \delta _ { l j } \\ & = \sum _ { k } \frac { d \mathcal { L } } { d y _ { k j } } \end{aligned} \right.</script><hr><p>然后是次简单的 gamma ：</p><script type="math/tex; mode=display">\left.\begin{aligned} \frac { d \mathcal { L } } { d \gamma _ { j } } & = \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \frac { d y _ { k l } } { d \gamma _ { j } } \\ & = \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \hat { x } _ { k l } \delta _ { l j } \\ & = \sum _ { k } \frac { d \mathcal { L } } { d y _ { k j } } \left( x _ { k j } - \mu _ { j } \right) \left( \sigma _ { j } ^ { 2 } + \epsilon \right) ^ { - 1 / 2 } \end{aligned} \right.</script><hr><p>最后的第一条链式推导：</p><script type="math/tex; mode=display">\frac { d \mathcal { L } } { d x _ { i j } } = \sum _ { k , l } \frac { d \mathcal { L } } { d y _ { k l } } \frac { d y _ { k l } } { d \hat { x } _ { k l } } \frac { d \hat { x } _ { k l } } { d x _ { i j } }</script><p>首先我们知道：</p><script type="math/tex; mode=display">\hat { x _ { k l } } = \left( x _ { k l } - \mu _ { l } \right) \left( \sigma _ { l } ^ { 2 } + \epsilon \right) ^ { - 1 / 2 }</script><p>所以：</p><script type="math/tex; mode=display">\frac { d \hat { x } _ { k l } } { d x _ { i j } } = \left( \delta _ { i k } \delta _ { j l } - \frac { 1 } { N } \delta _ { j l } \right) \left( \sigma _ { l } ^ { 2 } + \epsilon \right) ^ { - 1 / 2 } - \frac { 1 } { 2 } \left( x _ { k l } - \mu _ { l } \right) \frac { d \sigma _ { l } ^ { 2 } } { d x _ { i j } } \left( \sigma _ { l } ^ { 2 } + \epsilon \right) ^ { - 3 / 2 }</script><p>还没完，我们知道：</p><script type="math/tex; mode=display">\sigma _ { l } ^ { 2 } = \frac { 1 } { N } \sum _ { p } \left( x _ { p l } - \mu _ { l } \right) ^ { 2 }</script><p>于是：</p><script type="math/tex; mode=display">\left.\begin{aligned} \frac { d \sigma _ { l } ^ { 2 } } { d x _ { i j } } & = \frac { 1 } { N } \sum _ { p } 2 \left( \delta _ { i p } \delta _ { j l } - \frac { 1 } { N } \delta _ { j l } \right) \left( x _ { p l } - \mu _ { l } \right) \\ & = \frac { 2 } { N } \left( x _ { i l } - \mu _ { l } \right) \delta _ { j l } - \frac { 2 } { N ^ { 2 } } \sum _ { p } \delta _ { j l } \left( x _ { p l } - \mu _ { l } \right) \\ & = \frac { 2 } { N } \left( x _ { i l } - \mu _ { l } \right) \delta _ { j l } - \frac { 2 } { N } \delta _ { j l } \left( \frac { 1 } { N } \sum _ { p } x _ { p l } - \mu _ { l } \right) \\ & = \frac { 2 } { N } \left( x _ { i l } - \mu _ { l } \right) \delta _ { j l } \end{aligned} \right.</script><p>组合一下：</p><script type="math/tex; mode=display">\frac { d \hat { x } _ { k l } } { d x _ { i j } } = \left( \delta _ { i k } \delta _ { j l } - \frac { 1 } { N } \delta _ { j l } \right) \left( \sigma _ { l } ^ { 2 } + \epsilon \right) ^ { - 1 / 2 } - \frac { 1 } { N } \left( x _ { k l } - \mu _ { l } \right) \left( x _ { i l } - \mu _ { l } \right) \delta _ { j l } \left( \sigma _ { l } ^ { 2 } + \epsilon \right) ^ { - 3 / 2 }</script><p>最后：</p><script type="math/tex; mode=display">\left.\begin{aligned} \frac { d \mathcal { L } } { d x _ { i j } } & = \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \frac { d y _ { k l } } { d \hat { x } _ { k l } } \frac { d \hat{x} _ { k l } } { d x _ { i j } } \\ & = \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \gamma _ { l } \left( \left( \delta _ { i k } \delta _ { j l } - \frac { 1 } { N } \delta _ { j l } \right) \left( \sigma _ { l } ^ { 2 } + \epsilon \right) ^ { - 1 / 2 } - \frac { 1 } { N } \left( x _ { k l } - \mu _ { l } \right) \left( x _ { i l } - \mu _ { l } \right) \delta _ { j l } \left( \sigma _ { l } ^ { 2 } + \epsilon \right) ^ { - 3 / 2 } \right) \\ &= \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \gamma _ { l } \left( \left( \delta _ { i k } \delta _ { j l } - \frac { 1 } { N } \delta _ { j l } \right) \left( \sigma _ { l } ^ { 2 } + \epsilon \right) ^ { - 1 / 2 } \right) - \sum _ { k l } \frac { d \mathcal { L } } { d y _ { k l } } \gamma _ { l } \left( \frac { 1 } { N } \left( x _ { k l } - \mu _ { l } \right) \left( x _ { i l } - \mu _ { l } \right) \delta _ { j l } \left( \sigma _ { l } ^ { 2 } + \epsilon \right) ^ { - 3 / 2 } \right) \\ &= \frac { d \mathcal { L } } { d y _ { i j } } \gamma _ { j } \left( \sigma _ { j } ^ { 2 } + \epsilon \right) ^ { - 1 / 2 } - \frac { 1 } { N } \sum _ { k } \frac { d \mathcal { L } } { d y _ { k j } } \gamma _ { j } \left( \sigma _ { j } ^ { 2 } + \epsilon \right) ^ { - 1 / 2 } - \frac { 1 } { N } \sum _ { k } \frac { d \mathcal { L } } { d y _ { k j } } \gamma _ { j } \left( \left( x _ { k j } - \mu _ { j } \right) \left( x _ { i j } - \mu _ { j } \right) \left( \sigma _ { j } ^ { 2 } + \epsilon \right) ^ { - 3 / 2 } \right) \\ &=\frac { 1 } { N } \gamma _ { j } \left( \sigma _ { j } ^ { 2 } + \epsilon \right) ^ { - 1 / 2 } \left( N \frac { d \mathcal { L } } { d y _ { i j } } - \sum _ { k } \frac { d \mathcal { L } } { d y _ { k j } } - \left( x _ { i j } - \mu _ { j } \right) \left( \sigma _ { j } ^ { 2 } + \epsilon \right) ^ { - 1 } \sum _ { k } \frac { d \mathcal { L } } { d y _ { k j } } \left( x _ { k j } - \mu _ { j } \right) \right) \end{aligned}\right.</script><p>该推导对应的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mean = <span class="number">1.</span>/N*np.sum(x, axis = <span class="number">0</span>)</span><br><span class="line">var = <span class="number">1.</span>/N*np.sum((x-mean)**<span class="number">2</span>, axis = <span class="number">0</span>)</span><br><span class="line">dbeta = np.sum(dy, axis=<span class="number">0</span>)</span><br><span class="line">dgamma = np.sum((h - mean) * (var + eps)**(<span class="number">-1.</span> / <span class="number">2.</span>) * dy, axis=<span class="number">0</span>)</span><br><span class="line">dx = (<span class="number">1.</span> / N) * gamma * (var + eps)**(<span class="number">-1.</span> / <span class="number">2.</span>) * (N * dy - np.sum(dy, axis=<span class="number">0</span>)</span><br><span class="line">    - (x - mean) * (var + eps)**(<span class="number">-1.0</span>) * np.sum(dy * (x - mean), axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>这个推导非常富有想象力，然而有一种更简单的推导方式：</p><p><a href="https://kevinzakka.github.io/2016/09/14/batch_normalization/" target="_blank" rel="noopener">Deriving the Gradient for the Backward Pass of Batch Normalization</a></p><p>新代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batchnorm_backward</span><span class="params">(dout, cache)</span>:</span></span><br><span class="line">N, D = dout.shape</span><br><span class="line">x_mu, inv_var, x_hat, gamma = cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># intermediate partial derivatives</span></span><br><span class="line">dxhat = dout * gamma</span><br><span class="line"></span><br><span class="line"><span class="comment"># final partial derivatives</span></span><br><span class="line">dx = (<span class="number">1.</span> / N) * inv_var * (N*dxhat - np.sum(dxhat, axis=<span class="number">0</span>) </span><br><span class="line">- x_hat*np.sum(dxhat*x_hat, axis=<span class="number">0</span>))</span><br><span class="line">dbeta = np.sum(dout, axis=<span class="number">0</span>)</span><br><span class="line">dgamma = np.sum(x_hat*dout, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dx, dgamma, dbeta</span><br></pre></td></tr></table></figure><p>LN 和 BN 的不同在于方向不同， LN 是纵向， BN 是横向。不再赘述。</p><p>LN：$\mathbf { x } : \mathbf { N } \times D \rightarrow \boldsymbol { \mu } , \boldsymbol { \sigma } : \boldsymbol { 1 } \times \mathbf { D }$ </p><p>BN：$\mathbf { x } : \mathbf { N } \times D \rightarrow \boldsymbol { \mu } , \boldsymbol { \sigma } : \mathbf { N } \times \mathbf { 1 }$ </p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Softmax 推导</title>
      <link href="/machine-learning/2018-10-08-softmax/"/>
      <url>/machine-learning/2018-10-08-softmax/</url>
      
        <content type="html"><![CDATA[<p>像一条咸鱼的学习让我不得不把这些记下来。</p><blockquote><p>不过介个确实容易遗忘鸭😅。</p></blockquote><h2 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h2><p>首先我们知道：</p><script type="math/tex; mode=display">\text { softmax } \left( f \left( \vec { x _ { i } } ; \vec { w } \right) \right) _ { j } = \frac { e ^ { f _ { j } } } { \sum _ { k = 1 } ^ { n } e ^ { f _ { k } } }</script><p>其中：</p><script type="math/tex; mode=display">f \left( \vec { x _ { i } } ; \vec { w } \right) = \vec { w } \cdot \vec { x _ { i } }</script><script type="math/tex; mode=display">f _ { j } \left( \vec { x _ { i } } ; \vec { w } \right) = \vec { w } _ { j } \cdot \vec { x _ { i } }</script><hr><p>我们现在将可能性转化为非标准化的对数概率，使用交叉熵损失：</p><script type="math/tex; mode=display">L _ { i } = - \log \left( \frac { e ^ { f _ { y _ { i } } } } { \sum _ { j } e ^ { f _ { j } } } \right)</script><p>或者说等价于：</p><script type="math/tex; mode=display">L _ { i } = - f _ { y _ { i } } + \log \sum _ { j } e ^ { f _ { j } }</script><hr><p>给定图像 $x_{i}​$ 由 $W​$ 参数化，被分配为正确 $y_{i}​$ 的概率：</p><script type="math/tex; mode=display">P \left( y _ { i } | x _ { i } ; w \right) = \frac { e ^ { f _ { y _ { i } } } } { \sum _ { k } e ^ { f _ { k } } }  = \text { softmax } \left( f \left( \vec { x _ { i } } ; \vec { w } \right) \right) _ { j }</script><p>这些指数计算结果可能会非常大，下面的表达式不会改变结果，但是会让结果数值更加稳定：</p><script type="math/tex; mode=display">\frac { e ^ { f _ { i } } } { \sum _ { j } e ^ { f _ { j } } } = \frac { C e ^ { f _ { i } } } { C \sum _ { j } e ^ { \ell _ { j } } } = \frac { e ^ { f _ { y _ { i } } + \log C } } { \sum _ { j } e ^ { f _ { j } + \log C } }</script><blockquote><p>一般，我们令 $\log C = - \max _ { j } f _ { j }$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始</span></span><br><span class="line">f = np.array([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]) <span class="comment"># example with 3 classes and each having large scores</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># Bad: Numeric problem, potential blowup</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在</span></span><br><span class="line">f -= np.max(f) <span class="comment"># f becomes [-666, -333, 0]</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># safe to do, gives the correct answer</span></span><br></pre></td></tr></table></figure><blockquote><p>softmax 只有挤压功能，但它是一种相对常用的简写。</p></blockquote><h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>MLE 最大似然估计的推导：</p><script type="math/tex; mode=display">\begin{aligned} \dot{x} &= \sigma(y-x) \ \dot{y} &= \rho x - y - xz \ \dot{z} &= -\beta z + xy \end{aligned}</script><script type="math/tex; mode=display">\left.\begin{aligned}L ( w ) &= \prod _ { N } P \left( y _ { i } , x _ { i } | w \right)\newline &=\sum _ { i } ^ { N } \log \left( \frac { e ^ { f _ { y _ { i } } } } { \sum _ { k = 1 } ^ { n } e ^ { f _ { k }  } } \right)\newline &=\sum _ { i } ^ { N } \left( f _ { y _ { i } }  - \log \sum _ { k = 1 } ^ { n } e ^ { f _ { k }  } \right) \end{aligned} \right.</script><blockquote><p>ps：向量求解 softmax 的 loss 时，直接用这里的第二步。</p></blockquote><p>MLE 求解最大似然估计，等价于下面的损失函数求最小：</p><script type="math/tex; mode=display">\operatorname { loss } ( w ) = - L ( w ) = \sum _ { i } ^ { N } \left( - f _ { y _ { i } }  + \log \sum _ { k = 1 } ^ { n } e ^ { f _ { k }  } \right)</script><p>重新定义损失函数，取平均，加上正则化：</p><script type="math/tex; mode=display">\operatorname { loss } ( w ) = \frac { 1 } { N } \sum _ { i } ^ { N } \left( - f _ { y _ { i } } + \log \sum _ { k = 1 } ^ { n } e ^ { f _ { k } } \right) + \lambda \| w \| ^ { 2 }</script><p>对损失函数进行求导：</p><script type="math/tex; mode=display">if \space (u==y_{i}) \space => \space \frac { d L ( \vec { w } ) } { d w _ { u } ^ { ( v ) } } = \frac { 1 } { N } \sum _ { i } ^ { N } \left( - x _ { i } ^ { ( v ) } + \frac { x _ { i } ^ { ( v ) } e^{f_{i}} } { \sum _ { k = 1 } ^ { n } e ^ { f _ { k }  } } \right) + 2 \lambda w _ { u } ^ { ( v ) }</script><script type="math/tex; mode=display">if \space (u != y_{i}) \space => \space \frac { d L ( \vec { w } ) } { d w _ { u } ^ { ( v ) } } = \frac { 1 } { N } \sum _ { i } ^ { N } \left( 0 + \frac { x _ { i } ^ { ( v ) }e^{f_{i}} } { \sum _ { k = 1 } ^ { n } e ^ { f _ { k }  } } \right) + 2 \lambda w _ { u } ^ { ( v ) }</script>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> softmax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>努力是没有用的</title>
      <link href="/after-reading/2018-09-12-cai-zhi-zhong-for-striving/"/>
      <url>/after-reading/2018-09-12-cai-zhi-zhong-for-striving/</url>
      
        <content type="html"><![CDATA[<p>这是漫画家，蔡志忠先生的演讲。</p><p>我是一个很难被文字打动的人，因为看了非常多的书，小说，文献，杂志，现在更以一周一本的速度扫荡着机器学习，开始我不觉得自己会看完这篇文章，也不觉得会将它转载，更不会意料到有一种石子扔进池塘，久久不能平复的心情。</p><p>结合白岩松先生关于道德经的演讲，我总觉得他们像在说同一件事，但是要我写读后感的话，我还是不知道该怎么表达出这种懊悔，喜悦和向往。</p><p>下面是演讲内容和视频：</p><hr><blockquote><p><strong><a href="https://zh.wikipedia.org/wiki/%E8%94%A1%E5%BF%97%E5%BF%A0" target="_blank" rel="noopener">蔡志忠</a></strong>（1948年2月2日－）是台湾的漫画家。出生于彰化县花坛乡。虽有从小受洗的天主教信仰家庭背景，蔡志忠却也是个佛像收藏家。</p></blockquote><iframe src="//player.bilibili.com/player.html?aid=7107829&cid=11591280&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: -webkit-fill-available; height: -webkit-fill-available; margin: 1em 0;"> </iframe><p>大家好，我老婆说我站着躺着都不厉害，我坐着很厉害，所以我要坐着演讲。</p><p>美国有一个化学教授得了诺贝尔奖，《纽约时报》找不到他的照片，就派了一个摄影记者去学校找给他拍照片。他问为什么要替我拍照片？“因为你得了化学诺贝尔，很伟大。”“我伟大不是我的脸蛋，而是我的屁股，因为我可以一天工作十五个钟头就做化学实验，所以请拍我的屁股吧。”我自己也是屁股最厉害，我脸蛋长得并不怎么样。我曾经坐在椅子上58个钟头做一个4分钟的电视片头；我曾经42天没有打开门，关在屋子里面做一件事；我曾经花了4年时间，到日本画了40本诸子百家跟四格漫画；我曾经花十年零四十天研究物理、数学。我平常是坐在那根棒棒上，所以我的屁股从头到尾有一道疤痕，开始会红肿，后来就结痂，现在是完全没有问题。我可以持续用电脑工作18个钟头，不过椅子的工学位置要对：椅子45公分，桌子70公分，手放在桌子上，唯一会动的就是手指头。所以我虽然每天工作16-18个钟头，却没有手臂酸肩膀酸脖子痛。我一生没有生过病，没去过医院，死掉以前都不会去。</p><h2 id="我的童年"><a href="#我的童年" class="headerlink" title="我的童年"></a>我的童年</h2><p>去年5月5号，中信出版社要出我的书，它想出的是我的一生。然后我就开始回想我的一生。后来发现我是早期教育养大的，因为我一岁就念《圣经》，三岁半开始思考，四岁半找到人生之路。</p><p>为什么会有这么好的机缘？彰化田中有一个裁缝师，叫叶举。他做了一辈子裁缝师想改行当天主教的传道士，人民教堂的柯神父说如果你可以传十户人家信天主教，我就让你当传道士。他不好意思在村庄里面传道，因为很害羞，所以就跑到二十公里外的三家春——我们的家乡传道。我爸爸跟他是好朋友，大概也是这个因缘他才到我们村庄传教的。以前信仰天主教，一般会说天主教不拜祖先，死了没人哭。天主教也会送米粉、面粉、牛油还有玉米粉给教友，所以大家会笑说天主教是“面粉教”。他大概待了半年，没几天就到我们家跟我爸爸说哪一户答应了哪一户答应了，我爸爸最后就说，好吧，那我们家就算第十户。在我出生那一年，在彰化很多地方都没有教堂的时代，我们的小村庄竟然有一座新盖的教堂。我出生就是天主教教徒，一岁就开始念《圣经》——当然不是我自己念。十户人家，大概二十五个小孩，就像那个画面那样，最旁边那个是我。我二哥6岁，我1岁，每天早上9点上到中午12点，从创世纪讲到耶稣复活。我三岁半已经会背诵《天主经》《圣母经》等很多种经文，也会参加教堂的仪轨，就是望弥撒、领圣体、办告解。三岁半的我就开始思考，我什么都不会。《圣经》里面有100到1000个故事，有50到100个厉害的人物，例如耶稣基督有超能力，可以让瘸子走路、可以让瞎子睁眼，可以用两条鱼、五张饼喂饱了三千个信徒；摩西可以分开红海，诺亚可以制造方舟，而蔡志忠什么都不会。蔡志忠什么都不会，看起来好像不太奇怪，事实上在我们乡下是很奇怪的。我们乡下没有三岁半的小孩不知道他将来要做什么。农夫的小孩已经可以在田里帮忙，铁匠的小孩已经在帮忙拉风，拉车的小孩已经在帮爸爸喂牛，三岁半的小姐姐已经背了一个一岁半的小妹妹，只有蔡志忠什么都不知道。因为我爸爸是全乡书法第一，他是乡民代表会秘书，我不能说我长大一定要做乡民代表会秘书，所以就很焦虑。所以我就会躲在我爸爸的书桌下，那里有一块垫子，然后再把椅子拉进来。像乡下用九重葛立篱笆，把九重葛剥开里面像火车的车厢，是空的，所以我会整理一块地方当我的别墅，在里面思考。思考了大概半年，记得大概四岁的时候，爸爸送给我一个小黑板。他教我学字，第一个写我的名字，然后写天地行、孔乙己，类似这样的。所以我四岁半就开始会写字会看书，也从这个小黑板发现了我的人生之路。</p><h2 id="我怎么立志画画的"><a href="#我怎么立志画画的" class="headerlink" title="我怎么立志画画的"></a>我怎么立志画画的</h2><p>我很爱画，也很会画，只要不饿死我就要画上一辈子。其实要饿死我还蛮难的，我已经四十五年不吃早餐，现在大概一天都只吃一餐，而且我的一餐是很少的，例如一碗清粥，米粒很少，平常还会配一块豆腐乳。如果今天豪华一点，就配两块豆腐乳，一块放到碗里面，一块在上面。</p><p>我立志一辈子要走画画这条路，可是当时并没有这条路，当时最接近画画的就是画电影招牌。因为画平常的招牌只是写字，我又不会写那种美术字，所以四岁半的我就立志要画电影招牌。 </p><p>我大概四五岁就可以自己搭车去都市里面，其实以前没有绑架小孩，车子也很少，所以父母也不会担心你被车子撞到了、被绑架，所以我会去每个城市。 </p><p>我去彰化市、云林市这些专门画电影招牌的地方，站着看他们画。画一张大概四平方米的，就是六尺乘六尺，我问他多少钱，他说六十块。我算了算，一个电影招牌大概要画十八片，十八片乘以六十块，大概一千块。我那时候觉得他们很厉害，一个鼻子只是画一点白点然后绕一圈，远远看过去就会反光，所以以前画电影招牌的就是我的偶像。九岁的时候，台湾流行漫画，当时的漫画都是原创的，我那时候就立志要当漫画家。当开始决定画漫画以后，我知道我跟其他漫画家不太一样，我知道漫画最主要的是内容，内容才是王道。其实你们看我画的漫画，我大部分只花1%的时间去画，其他99%都是在编故事。无论画庄子、老子，或后来的物理、数学，都是花99%的时间去了解故事内容，所以我很喜欢编故事。</p><p>我会讲故事给我妈妈听，她一边喂鸡我一边讲，她一边喂鸭我一边讲，她喂猪我一边讲。我说你都没有注意听，她说有啊有啊，我有听。我说那你讲一遍我讲的什么。她说好啦好啦，我会仔细听，你再仔细讲。我们家跟一般的中国家庭好像不太一样，可能是我们那个村庄都是这个样子。我们家没有问句，就是你生而为子，出生了就是家庭的一份子。比如一年到头最多就是中秋节有人送一盒月饼，每一次回到家我就去看书柜里有没有月饼。终于有一天有一盒月饼，我一定先吃两个，第二天要上学，我又带了两个走，下课回来再把最后两个吃掉。这样十几年，从来没有人问我这个月饼是你吃的吗？就像我要去彰化看电影，可能是五岁，就是告诉爸爸我要去彰化看电影，不是问可不可以。我的任务就是坐白天的最后一班车回来，因为天黑以前要回来。像我们平常都在外面玩，我妈妈煮完饭就会站在晒谷场边上说回家吃饭喽，我还在玩。到了三点，人家说哎呦你糟糕了，你妈妈半个钟头前就叫你吃饭了，你还在那里玩。我说哦，再继续玩。玩到十字路口，别人又说你糟糕了，你妈妈一个钟头前就叫你回家吃饭，你还在玩。我说哦，又玩。玩到隔壁家，他说哇，你糟糕了，你妈妈一个半钟头前叫你吃饭，你还在玩。我说哦。我回到家就是把竹笼的罩子打开，吃完再把罩子盖好就好了，从来没有被骂过。我一生没有被父亲或母亲骂过一次、打过一次。最右边那个小男生就是九岁的我，我那时候为了要站得太正头就歪了。左下角那个是我大哥，他们是很优雅的，他们在高雄的电信局。五六十年前，电信局是最高端的职业，是要打摩尔斯码的。</p><h2 id="我怎么用漫画赚钱？"><a href="#我怎么用漫画赚钱？" class="headerlink" title="我怎么用漫画赚钱？"></a>我怎么用漫画赚钱？</h2><p>我初中二年级的时候就画了四页漫画寄给台北的集英出版社。出版社不晓得我几岁，就说你画得很好，我们请你当漫画家。接到信的那天下午，我就跟妈妈说：“妈妈，明天我要坐早班车到台北了。”意思是永远不回来了。她说你要跟爸爸讲一声。我平常很少跟我爸爸讲话，我一辈子只有跟妈妈讲了无数的话，我跟我爸爸、大哥、二哥，跟我姐姐、妹妹一辈子讲的话不超过五十句。我还跟我二哥两个人同住一个房间一张床，好像三年中没有讲话，因为那时候我看不起他，我觉得他没什么文化，我虽然小他五岁。那天晚上我爸爸吃完饭，坐在藤椅上看报纸。我就站在他后面，说爸爸明天我要去台北。他说去干吗，我说去画漫画。找到工作了吗，我说找到了，他说那就去吧。一共27个字，我讲14个字，他讲13个字，讲完了我没有走到他前面，他也没有回头看我。第二天早班车，他好像去田里，我就拎着皮箱先坐公车到彰化，然后搭平快的。他给我两百块，搭平快的32块，到了台北又花了三块半坐三轮车——我说的是台币，其实就是带了40块人民币。 坐火车的时候，我就走到最后一节，看着铁轨往后面跑。我对着故乡说永远不回来了，再也不回来了。我肩不能挑、手不能提，做不了农夫，我爸爸妈妈以前都说我以后只能去路上捡牛粪——以前乡下有这个职务，断了手的或是跛脚的，他带着一个竹笼，沿路去找牛粪，已经干了的可以卖钱。到台北，那个老板才发现原来我这么小，大概没有比皮箱高多少。睡的地方很糟糕，一个大概四平方米的屋子，里面有两张床，两层的，睡了四个人。第二天早上，我通常是大概四五点就起床了。从以前在乡下的鸟叫声公鸡叫声狗叫声，突然变成卡车发动的声音和喇叭声，我突然发现，哇，我现在已经是职业漫画家了，就非常高兴。所以我就从15岁画到20岁，从一张八毛钱画到一张一块半。当时画漫画的时候必须要非常快，一个月要画456张。我们每一本是152张，这样才刚刚好可以在台北过得还不错，可以去看电影，可以做衣服，可以买唱片，所以我就训练画得非常快非常快。今天的漫画家听说一个月画不到三十张，以前我们是两天就要画超过三十张，因为那个赚钱不够活，其实也是今天的漫画家没有办法维持很长远的原因。很多漫画家误以为他会画漫画就是漫画家，其实还是差得很远。因为漫画家毕竟是一个创作者，所以内容、故事才是主要的，而不是画画技巧。通常我的一生都是自己想，就像我们打开门走出去是知道要去哪里，我们开车上高速公路是知道目的地，然而人生这么大的旅程，居然99.99%的人都不晓得他要去哪里。我四岁半就决定一生，到今天并没有改变。我到今天一天的花费都很少超过三十块人民币，其中要花十块去买一包香烟，这个不是故意展开的。我拿着破包包，穿着破鞋，还穿着带补丁的裤子，我很多衣服都是破了还在穿着——当一个人找到了自己的最爱，其他都不在乎。三十五年前我在日本。我是台湾人，同样的日语也不够溜，那为什么日本出版社愿意出我的书，一定是不肯的。所以第一个就是思考：我要画什么东西可以非常畅销，我要画什么东西日本漫画家画不了，所以就决定画诸子百家。其实我刚开始打稿打了八十几张就找讲谈社的阿久津先生给他看，他说哇，这个肯定很畅销。我说当然了，我也知道。他说这个会卖疯了，这一本书一定要给我们讲谈社出版。我就说，对不起，不是一本，是三十本。他说这三十本一定要给我们讲谈社出版。我说行。所以一开始就是要想通，你在画的时候就知道一定很畅销。</p><h2 id="努力是没有用的"><a href="#努力是没有用的" class="headerlink" title="努力是没有用的"></a>努力是没有用的</h2><p>其实我的人生观，可以教你们一点——我已经68岁，很有资格教你们一点。我觉得努力是没有用的，小学三年级我就知道不能跟老师学，跟老师学没有活路。就像前天我告诉两个美院的学生，我说你怎么可以跟永远卖不了画的老师学如何去画画呢，办不到嘛。像我的小学老师叫李再兴，他就说学问啊，就是平常要学，不懂要问，如果课堂上的问题不懂上课问，生活上的问题不懂下课问。我们乡下不怕老师的，老师一下课，就有人问老师老师，为什么玩水玩久了每个手指头都很皱，而且大拇指最皱。李再兴老师说，老师明天告诉你——很明显他家里的资料很少，都经不起你问。有时候问老师老师，为什么筷子插在水杯会转弯，他说这是折射。我说老师为什么会折射，他说因为光在空气中比较快，在水中比较慢。我说老师光在空气中为什么比较快。他说老师明天告诉你。有一天我从教室走出来，李再兴老师从教室休息室走出来，看到我他马上闪进保健室，因为他欠我23个问题没有回答，包括手为什么会皱——玩水以后皮肤表面会增大，大拇指表面积最大，所以皱得最厉害——那个他也没有告诉我。所以那时候我就知道，不能跟老师学，老师什么都不会。所以我从来都是自己的问题自己找答案，所有的东西都自己学。</p><p>为什么努力是没有用的？老师或父母老是说努力努力就会走到巅峰——才怪。如果这样，不是所有人都走上巅峰了吗？没有人开始不努力，为什么后来不努力，因为努力没有效果。人生不是走斜坡，你持续走就可以走到巅峰；人生像走阶梯，每一阶有每一阶的难点，学物理有物理的难点，学漫画有漫画的难点，你没有克服难点，再怎么努力都是原地跳。所以当你克服难点，你跳上去就不会下来了。就像你学会语文，即使你十年不讲，碰到状况就会讲；就像学脚踏车，十年没骑，碰到脚踏车一上去就可以上手一样。 </p><h2 id="人生其实很简单"><a href="#人生其实很简单" class="headerlink" title="人生其实很简单"></a>人生其实很简单</h2><p>改变观念听起来好像很容易，其实是不太容易的。像我第一次到香港，知道水果之王榴莲，然后就买了一颗，57块港币。回到朋友的别墅，打开就像婴儿大便，味道也像，形状也像，怎么也吃不下，就把它放到了冷冻库。7天以后就要回去，想想那么贵，再拿出来看，再怎么看都是大便，还是拿去外面丢了。有一次我去马来西亚，要走的前一天，我看到街道上有一个人挑着一担榴莲，有两个人蹲在那里吃。我就给他马币，他给我一个榴莲，我觉得非常好吃。我在飞机上就恨自己为什么不吃两个。所以后来我去巴厘岛都是去吃榴莲的。 同样都是榴莲，只是我的观念改变了，就像老外永远不敢吃皮蛋，永远不敢吃臭豆腐。所以观念改变看起来好像很简单，其实有点难。就像你们后来会觉得老师、文凭不重要，但这个对大部分的妈妈们好像很难改变。对我来说，我只念到初中二年级。后来台湾一个漫画家叫可乐王，他宣称到小学三年级就不念了，我很恨自己为什么要去上小学，输了人家一大截。另外一个例子是小洛克菲勒。二次世界大战结束，各国决定要成立联合国。联合国的地址首选是伦敦、巴黎或纽约，但伦敦跟巴黎都很危险，大家就一致选定纽约。纽约光那片土地跟盖大楼就要花860万美金，但是没有人愿意捐土地给联合国，因为联合国没有任何利益。但小洛克菲勒知道了，宣称他要捐给联合国。所有人都觉他这个完全没有利益，可事实是，洛克菲勒买了100倍土地，中间那一块捐给联合国，当联合国建立了，他的土地涨了10倍，所以他虽然捐了860万，其实赚了8600万。当然不是说不去努力，努力只比不努力好一点而已，是要会思考。我的结论就是人生其实很简单，只要你找寻你最拿手、最喜欢的事物，把它做到极致，无论做什么，没有不成功的。你做迷魂汤、做水晶包或做漫画家、工程师，都一样。当你在做的过程中，要比其他人快，比其他人好。我每一次开画展都会要求这次要比上次快，还要比上次好，而价格要比上次更贵，最后当然都达到这个目的了。每一次都比上一次涨两千，然后你越做越快、越做越好，你就会进入到第三个状况，就会身心合一、排除一切。就像我没有手表，没有手机，没有名片，不跟人家来往，我唯一的就是E-Mail。像一个怀胎九个月的妈妈，她很迫切地急着把自己的小孩生下来，所以舍不得睡觉，一醒来就赶快去完成事物。所以这个时候，你会发现人生的最大秘密，原来完成事物不是工作，而是人生最大的享受。我今天讲得已经超过了30分钟，不好意思，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 努力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探职责链模式</title>
      <link href="/design-pattern/2018-09-12-chain-of-responsibility/"/>
      <url>/design-pattern/2018-09-12-chain-of-responsibility/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/chain-of-responsibility" target="_blank" rel="noopener">koonchen/design-patterns/chain-of-responsibility</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条连链传递该请求，直到有一个对象处理它为止。</p></blockquote><p>如果我们在一个界面上进行帮助功能的编写，那么非常自然的，我们可以从最特殊的帮助开始编写，同时，我们需要一个对象来处理帮助请求，这里我们请求的对象并不知道最终提供帮助的对象是谁。我们需要一种方法来将他们解耦。</p><p>Chain of Responsibility 模式的想法是，给与一条链，链中每一个对象将处理请求，或者将这一请求转发给下一个候选对象，直到该请求被处理并返回给最开始的一个按钮或者其他的提示框。</p><p>职责链模式的适用性：</p><blockquote><ul><li>有多个对象可以处理一个请求，而哪个对象处理该请求运行时刻自动确定。</li><li>在不明确指定接收者的情况下，向多个对象的其中一个提交请求。</li><li>可以处理一个请求的对象集合应被动态指定。</li></ul></blockquote><p>职责链模式的参与者：</p><blockquote><ul><li>Handler — 定义一个处理请求的接口。</li><li>ConcreteHandler — 处理它所负责的请求。</li><li>Client — 提交请求者。</li></ul></blockquote><p>现在， Chain of Responsibility 模式的结构已经显而易见了：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/chain_of_responsibility.png" alt="cover"></p><p>职责链模式的优缺点：</p><blockquote><ul><li>降低耦合度：接收者和发送者都没有对方明确的信息。</li><li>增强了给对象指派职责的灵活性：我们可以在运行时刻对该链进行动态地增加或修改来增加或改变一个请求的职责。</li><li>不保证被接受：既然接收者和发送者都不知道对方的存在，所以一个请求可能会因为没有被正确配置二得不到处理。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们在实现前需要考虑实现问题：</p><blockquote><ul><li>实现后继者链有两种方法：</li></ul><blockquote><ul><li>定义新的链接：通常在 Handler 中定义，但也可由 ConcreteHandlers 来定义。</li><li>使用已有的链接：在一个部分 — 整体 的结构中，父构件应用可定义一个部件的后继者，此时窗口组件是已经有了的链接，我们可以直接使用。就像 Composite 模式那样。</li></ul></blockquote><ul><li>连接后继者：Handler 不仅需要定义请求的接口，同时需要维护后继链接，它需要提供一个缺省实现，向后继者转发请求。</li><li>表示请求：可以有不同的方法来表示请求，一种是硬编码操作调用，另一种是使用一个处理函数，这个函数以一个请求码为参数。</li></ul></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> RequestType &#123;</span><br><span class="line">  ConcreteHandler1, ConcreteHandler2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  RequestType requestType;</span><br><span class="line">  String requestDescription;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(RequestType requestType, String requestDescription)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.requestType = requestType;</span><br><span class="line">    <span class="keyword">this</span>.requestDescription = requestDescription;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Request&#123;"</span> +</span><br><span class="line">        <span class="string">"requestType="</span> + requestType +</span><br><span class="line">        <span class="string">", requestDescription='"</span> + requestDescription + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> requestType;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Handler next;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Handler next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      next.handleRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteHandler1</span><span class="params">(Handler next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.getRequestType().equals(RequestType.ConcreteHandler1))</span><br><span class="line">      System.out.println(<span class="string">"ConcreteHandler1 instance has been created"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">super</span>.handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteHandler2</span><span class="params">(Handler next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.getRequestType().equals(RequestType.ConcreteHandler2))</span><br><span class="line">      System.out.println(<span class="string">"ConcreteHandler2 instance has been created"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">super</span>.handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Handler handler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> ConcreteHandler1(<span class="keyword">new</span> ConcreteHandler2(<span class="keyword">null</span>)));</span><br><span class="line">    handler.handleRequest(<span class="keyword">new</span> Request(RequestType.ConcreteHandler1, <span class="string">"ConcreteHandler1"</span>));</span><br><span class="line">    handler.handleRequest(<span class="keyword">new</span> Request(RequestType.ConcreteHandler2, <span class="string">"ConcreteHandler2"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _type)</span>:</span></span><br><span class="line">        self._type = _type</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _next)</span>:</span></span><br><span class="line">        self._next = _next</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        self._next.handle_request(request);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request._type == <span class="string">'ConcreteHandler1'</span>:</span><br><span class="line">            print(<span class="string">'ConcreteHandler1 instance has been created'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._next.handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request._type == <span class="string">'ConcreteHandler2'</span>:</span><br><span class="line">            print(<span class="string">'ConcreteHandler2 instance has been created'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._next.handle_request(request)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultHandler</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'Without this request type'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    handler = ConcreteHandler1(ConcreteHandler2(DefaultHandler()))</span><br><span class="line">    handler.handle_request(Request(<span class="string">'ConcreteHandler1'</span>))</span><br><span class="line">    handler.handle_request(Request(<span class="string">'ConcreteHandler2'</span>))</span><br><span class="line">    handler.handle_request(Request(<span class="string">'ConcreteHandler3'</span>))</span><br></pre></td></tr></table></figure><p>职责链模式与 Composite 模式一起使用，这种情况下，一个构件的父构件也可以作为它的后继。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 责任链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探代理模式</title>
      <link href="/design-pattern/2018-08-27-proxy/"/>
      <url>/design-pattern/2018-08-27-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/proxy" target="_blank" rel="noopener">koonchen/design-patterns/proxy</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>为其他对象提供一种代理以控制这个对象的访问。</p></blockquote><p>当我们打开某个图形编辑器的时候，很多图形对象的创建开销很大，但是打开它需要很迅速，所以应该按需创建。我们如何才能隐藏根据需要创建图像这一事实，从而不会让编辑器的实现复杂化？</p><p>问题的解决是使用另外一个对象，即图像 Proxy ，代替那个真正的图像。 Proxy 可以代替一个图像对象，并且在需要时负责实例化图像对象。</p><p>代理模式的适用性：</p><blockquote><ul><li><p>远程代理：为一个对象在不同的地址空间提供局部代表。</p></li><li><p>虚代理：根据需要创建开销很大的对象。</p></li><li><p>保护代理：控制对原始对象的访问。保护代理用于对象应该有不同访问权限的时候。</p></li><li><p>智能指引：取代了简单的指针，它在访问对象时执行了一些附加操作：</p></li></ul><blockquote><ul><li>对指向实际对象的引用计数，这样当该对象没有引用的时候，可以自动释放它。</li><li>当第一次引用一个持久对象时，将它装入内存。</li><li>在访问一个实际对象前，检查时候已经锁定了它，以确保其他对象不能改变它。</li></ul></blockquote></blockquote><p>代理模式的参与者：</p><blockquote><ul><li>Proxy — 保存一个引用使得代理可以访问实体。代替实体，同时它控制对实体的读取、创建、删除。</li><li>Subject — 定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 了。</li><li>RealSubject — 定义 Proxy 所代表的实体。</li></ul></blockquote><p>现在，代理模式已经显而易见了，结构如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/proxy.png" alt="cover"></p><p>Proxy 模式在访问对象时引入了一定程度的间接性，根据代理的类型，附加了很多用途：</p><blockquote><ul><li>Remote Proxy 可以隐藏一个对象存在于不同地址空间的事实。</li><li>Virtual Proxy 可以进行最优化，例如根据要求创建对象。</li><li>Protection Proxies 和 Smart Reference 都允许在访问一个对象时有一些附加的内务处理。</li></ul></blockquote><p>需要注意的是，还有一种被称为 copy-on-write 的优化方式，该优化根据需要创建的对象有关，用代理延迟拷贝的过程，因为它没有被修改的时候，没有必要因为拷贝而产生开销。只有用户请求修改实体的操作时，代理才会真正拷贝它。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Proxy 模式可以利用以下一些语言特性：</p><blockquote><ul><li>重载 C++ 中的存取运算符。</li><li>使用 Smalltalk 中的 doesNotUnderstand ， Smalltalk 提供一个 hook 方法可以用来自动转发请求。当用户向接受者发送一个消息， Proxy 可以重定义 doesNotUnderstand 以便它的实体转发这个消息。</li><li>Proxy 并不总是需要知道实体的类型，若 Proxy 类能够完全通过一个抽象接口处理它的实体，则无需为每一个 RealSubject 都生成一个 Proxy 类， Proxy 类统一处理所有的 RealSubject 类。当然，如果是实例化，那么是需要知道具体类的。</li></ul></blockquote><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"RealSubject instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Subject realSubject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject realSubject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    realSubject.request();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Proxy proxy = <span class="keyword">new</span> Proxy(<span class="keyword">new</span> RealSubject());</span><br><span class="line">    proxy.request();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Subject instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span><span class="params">(Subject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'RealSubject instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span><span class="params">(Subject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, subject)</span>:</span></span><br><span class="line">        self._subject = subject</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._subject.request()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    proxy = Proxy(RealSubject())</span><br><span class="line">    proxy.request()</span><br></pre></td></tr></table></figure><p>实现异曲同工，不再赘述。</p><p>相关模式：</p><ul><li>Adapter ：适配器为它所适配的对象提供了一个不同的接口。相反的，代理提供了与它实体相同的接口。</li><li>Decoratro ：它和 Proxy 很像，但是目的不同，Decorator 为对象添加一个或多个功能，而代理则控制对对象的访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探享元模式</title>
      <link href="/design-pattern/2018-08-23-flyweight/"/>
      <url>/design-pattern/2018-08-23-flyweight/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/flyweight" target="_blank" rel="noopener">koonchen/design-patterns/flyweight</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>运用共享技术有效地支持大量细粒度的对象。</p></blockquote><p>有些程序得益于在其整个设计过程中采用了对象技术，但是简单化的实现代价极大。</p><p>在实现一个编辑器的时候，我们会用对象来表示嵌入的成分，例如表格和图形，我们可以想象 <strong>字符对象</strong> 被放在 <strong>行对象</strong> 里， <strong>行对象</strong> 被放在 <strong>列对象</strong> 里。但是这种设计将导致代价太大，文档中有成千上万的字符对象，这对于内存是极大的开销。 Flyweight 模式描述了如何共享对象，以至于可以细粒度地使用对象而无需高昂的价格。</p><p>flyweight (这里指的是对象不是模式) 是一个共享对象，它是独立的，它拥有 <strong>内部状态</strong> 和 <strong>外部状态</strong> ，内部状态存储于 flyweight 中，它包含了独立于 flyweight 场景的信息，这些信息使得 flyweight 可以被共享，而外部状态取决于 Flyweight 模式的场景，不可以被共享。</p><p>Flyweight 模式对那些数量太大而难以用对象来表示的概念进行建模。我们可以对字母表中每一个字母创建一个 flyweight ，每个 flyweight 存储一个字符代码，字符代码是内部状态，而其他信息是外部状态，比如位置。</p><p>逻辑上，我们的字符出现对应如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/flyweight-1.jpg" alt="cover"></p><p>使用 flyweight 对象以后，一个特定字符指向同一个实例：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/flyweight-2.jpg" alt="cover"></p><p>表示字母 a 的 flyweight 不需要知道字符具体的位置和字体，它只含有字符，用户根据具体的场景绘制自己的 flyweight ， row 对象知道它的子女应该在哪儿绘制自己保证横向排列，因此 row 在绘制时可以向每一个子女传递它的位置。</p><p>Flyweight 模式的适用情况 :</p><blockquote><ul><li>一个应用适用了大量的对象。</li><li>完全由于大量对象，导致极大存储开销。</li><li>对象的大多数状态都可以转换成外部状态。</li><li>如果删除对象的外部状态，那么可以使用相对较少的共享对象取代很多对象。</li><li>应用程序不依赖于对象标识，由于 Flyweight 模式下，对象可以被共享，所以只有概念有别的对象的标识将不同。</li></ul></blockquote><p>Flyweight 模式的参与者：</p><blockquote><ul><li>Flyweight (Glyph) — 通过这个接口 flyweight 可以接受并作用于外部状态。</li><li>ConcreteFlyweight (Character) — 实现了 Flyweight 接口，它的存储状态是内部的。</li><li>UnsharedConcreteFlyweight (Row, Column) — 并非所有 Flyweight 子类都需要被共享，这个对象通常将 ConcreteFlyweight 对象作为子节点。</li><li>FlyweightFactory — 创建并管理 flyweight 对象。</li><li>Client — 维持 flyweight 应用，保存 flyweight 的外部状态。</li></ul></blockquote><p>Flyweight 模式的结构也呼之欲出了：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/flyweight-pattern.jpg" alt="cover"></p><p>Flyweight 模式的协作方式如下：</p><blockquote><ul><li>flyweight 执行时所需的状态必定是内部的或外部的，内部状态存储于 ConcreteFlyweight 对象之中；而外部对象则由 Client 对象存储。</li><li>用户不直接对 ConcreteFlyweight 类进行实例化，而只能从 FlyweightFactory 对象得到 ConcreteFlyweight 对象，这保证了他们一定程度的共享。</li></ul></blockquote><p>Flyweight 模式常常和 Composite 模式相结合组成一个层次结构，这一结构是共享叶节点。但是结果是叶子节点不能存储指向父节点的指针，而父节点的指针将传给 flyweight 作为它外部状态的一部分。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现 Flyweight 模式时，需要注意以下几点：</p><blockquote><ul><li>删除外部状态：该模式的可用性很大程度上取决于是否容易识别外部状态并将它从共享对象中删除，如果不同种类的外部状态和共享前对象数目相同的话，删除外部状态不会降低存储消耗。理想情况下，外部状态可以由一个单独的对象结构计算得到，且该结构的存储要求非常小。</li><li>管理共享对象：对象是共享的，用户不能直接对它进行实例化，我们可以用 FlyweightFactory 找到特定的 flyweight 对象。这里共享的概念和单例类似。</li></ul></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EnumMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> FlyweightType &#123;</span><br><span class="line">  SHARED, UNSHARED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ConcreteFlyweight instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UnsharedConcreteFlyweight instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;FlyweightType, Flyweight&gt; factory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FlyweightFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    factory = <span class="keyword">new</span> EnumMap(FlyweightType.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Flyweight <span class="title">getFlyweight</span><span class="params">(FlyweightType type)</span> </span>&#123;</span><br><span class="line">    Flyweight flyweight = factory.get(type);</span><br><span class="line">    <span class="keyword">if</span> (flyweight == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SHARED:</span><br><span class="line">          flyweight = <span class="keyword">new</span> ConcreteFlyweight();</span><br><span class="line">          factory.put(type, flyweight);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UNSHARED:</span><br><span class="line">          flyweight = <span class="keyword">new</span> UnsharedConcreteFlyweight();</span><br><span class="line">          factory.put(type, flyweight);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flyweight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">    factory.getFlyweight(FlyweightType.SHARED).operation();</span><br><span class="line">    factory.getFlyweight(FlyweightType.UNSHARED).operation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现还是非常简单的，这里用了枚举，所以采用 EnumMap ，但它不是线程安全的。</p><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightType</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    SHARED = <span class="number">0</span></span><br><span class="line">    UNSHARED = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Flyweight instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span><span class="params">(Flyweight)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'ConcreteFlyweight instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span><span class="params">(Flyweight)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'UnsharedConcreteFlyweight instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._flyweight_factory = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_flyweight</span><span class="params">(self, flyweight_type)</span>:</span></span><br><span class="line">        flyweight = self._flyweight_factory.get(flyweight_type)</span><br><span class="line">        <span class="keyword">if</span> flyweight <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> flyweight_type == FlyweightType.SHARED:</span><br><span class="line">                flyweight = ConcreteFlyweight()</span><br><span class="line">                self._flyweight_factory[flyweight_type] = flyweight</span><br><span class="line">            <span class="keyword">elif</span> flyweight_type == FlyweightType.UNSHARED:</span><br><span class="line">                flyweight = UnsharedConcreteFlyweight()</span><br><span class="line">                self._flyweight_factory[flyweight_type] = flyweight</span><br><span class="line">        <span class="keyword">return</span> flyweight</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    factory = FlyweightFactory()</span><br><span class="line">    factory.get_flyweight(FlyweightType.SHARED).operation()</span><br><span class="line">    factory.get_flyweight(FlyweightType.UNSHARED).operation()</span><br></pre></td></tr></table></figure><p>实现也是大同小异。</p><ul><li>我们已经知道 Flyweight 模式可以和 Composite 模式结合起来，共享叶节点。</li><li>通常，最好用 Flyweight 模式实现 State 和 Strategy 对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 享元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ml 常用资源</title>
      <link href="/resource/2018-07-23-ml-collect/"/>
      <url>/resource/2018-07-23-ml-collect/</url>
      
        <content type="html"><![CDATA[<h2 id="新闻资讯"><a href="#新闻资讯" class="headerlink" title="新闻资讯"></a>新闻资讯</h2><ul><li><a href="https://news.google.com/topics/CAAqIggKIhxDQkFTRHdvSkwyMHZNREZvZVdoZkVnSmxiaWdBUAE?hl=en-US&amp;gl=US&amp;ceid=US%3Aen" target="_blank" rel="noopener">Google News</a> : Google News Machine learning</li><li><a href="http://news.mit.edu/topic/machine-learning?from=koon.cool" target="_blank" rel="noopener">MIT News</a> : Machine learning | MIT News</li><li><a href="https://www.jiqizhixin.com?from=koon.cool" target="_blank" rel="noopener">机器之心</a> : 机器之心 | 全球人工智能信息服务</li><li><a href="https://www.leiphone.com/?from=koon.cool" target="_blank" rel="noopener">雷锋网</a> : 雷锋网 | 读懂智能，未来</li><li><a href="https://www.zhihu.com/topic/19559450/hot?from=koon.cool" target="_blank" rel="noopener">知乎主题</a> : 知乎机器学习热门主题</li><li><a href="https://www.afenxi.com?from=koon.cool" target="_blank" rel="noopener">数据分析网</a> : 数据分析网 - 大数据学习交流第一平台</li><li><a href="http://www.17bigdata.com?from=koon.cool" target="_blank" rel="noopener">17bigdata</a> : 专注数据分析、挖掘、大数据相关领域的技术分享、交流</li></ul><h2 id="社区交流"><a href="#社区交流" class="headerlink" title="社区交流"></a>社区交流</h2><ul><li><a href="https://www.datatau.com?from=koon.cool" target="_blank" rel="noopener">DataTau</a> : 人工智能领域的Hacker News</li><li><a href="http://www.paperweekly.site?from=koon.cool" target="_blank" rel="noopener">PaperWeekly</a> : 一个推荐、解读、讨论和报道人工智能前沿论文成果的学术平台</li><li><a href="https://www.reddit.com/r/MachineLearning/?from=koon.cool" target="_blank" rel="noopener">Reddit</a> : Reddit | 机器学习板块</li><li><a href="https://www.quora.com/pinned/Machine-Learning?from=koon.cool" target="_blank" rel="noopener">Quora</a> : Quora | 机器学习主题</li><li><a href="http://www.6aiq.com/?from=koon.cool" target="_blank" rel="noopener">AIQ</a> : 机器学习大数据技术社区</li><li><a href="http://www.ziiai.com/?from=koon.cool" target="_blank" rel="noopener">极智能</a> : 人工智能技术社区</li><li><a href="http://www.shortscience.org?from=koon.cool" target="_blank" rel="noopener">ShortScience</a> : 用最简单的篇幅去概况科学著作</li><li><a href="https://mathoverflow.net?from=koon.cool" target="_blank" rel="noopener">MathOverflow</a> : 数学知识问答社区</li></ul><h2 id="优质博文"><a href="#优质博文" class="headerlink" title="优质博文"></a>优质博文</h2><ul><li><a href="https://machinelearningmastery.com/blog?from=koon.cool" target="_blank" rel="noopener">Machine Learning Mastery</a> : 帮助开发人员使用机器学习的知识解决复杂的问题</li><li><a href="https://blog.statsbot.co/?from=koon.cool" target="_blank" rel="noopener">Stats and Bots - Medium</a> : 机器学习应用程序和代码的实用指南</li><li><a href="https://www.cnblogs.com/tornadomeet/archive/2012/06/24/2560261.html?from=koon.cool" target="_blank" rel="noopener">tornadomeet的博客</a> : 很详细的ML&amp;DL学习博客</li><li><a href="https://weibo.com/fly51fly?topnav=1&amp;wvr=6&amp;topsug=1" target="_blank" rel="noopener">爱可可-爱生活</a> : 知名互联网资讯博主</li><li><a href="https://zhuanlan.zhihu.com/YJango" target="_blank" rel="noopener">超智能体</a> : 分享最通俗易懂的深度学习教程</li><li><a href="https://zhuanlan.zhihu.com/ainote" target="_blank" rel="noopener">人工智能笔记</a> : 人工智能从入门到AI统治世界</li></ul><h2 id="论文检索"><a href="#论文检索" class="headerlink" title="论文检索"></a>论文检索</h2><ul><li><a href="https://sci-hub.tw/" target="_blank" rel="noopener">SCI-HUB</a> : 找论文必备</li><li><a href="https://lunwen.im/?from=koon.cool" target="_blank" rel="noopener">猫咪论文</a> : 简单自由的论文下载平台</li><li><a href="https://arxiv.org/?from=koon.cool" target="_blank" rel="noopener">arXiv</a> : 康奈尔大学运营的学术预印本发布的平台</li><li><a href="http://www.gitxiv.com/?from=koon.cool" target="_blank" rel="noopener">GitXiv</a> : arXiv的成果开源实现平台</li><li><a href="http://www.arxiv-sanity.com/?from=koon.cool" target="_blank" rel="noopener">Arxiv Sanity</a> : 论文查询推荐</li><li><a href="https://paperswithcode.com/?from=koon.cool" target="_blank" rel="noopener">Papers with Code</a> : 将论文与开源代码实现结合</li></ul><h2 id="比赛实践"><a href="#比赛实践" class="headerlink" title="比赛实践"></a>比赛实践</h2><ul><li><a href="https://www.kaggle.com/?from=koon.cool" target="_blank" rel="noopener">Kaggle</a> : 为数据科学家提供举办机器学习竞赛</li><li><a href="http://www.kdd.org/kdd-cup?from=koon.cool" target="_blank" rel="noopener">KDD-CUP</a> : 国际知识发现和数据挖掘竞赛</li><li><a href="https://tianchi.aliyun.com/?from=koon.cool" target="_blank" rel="noopener">天池大数据</a> : 大数据竞赛、大数据解决方案、数据科学家社区、人工智能、机器学习</li><li><a href="http://www.pkbigdata.com/?from=koon.cool" target="_blank" rel="noopener">DataCastle</a> : 中国领先的数据科学竞赛平台</li><li><a href="http://www.saikr.com/?from=koon.cool" target="_blank" rel="noopener">赛氪网</a> : 汇集以高校竞赛为主，活动、社区为辅的大学生竞赛活动平台</li><li><a href="http://www.datafountain.cn/#/?from=koon.cool" target="_blank" rel="noopener">DataFountain</a> : DF,CCF指定专业大数据竞赛平台</li><li><a href="http://research.xiaojukeji.com/trainee.html?from=koon.cool" target="_blank" rel="noopener">滴滴新锐</a> : 滴滴面向全球高校博士、硕士、优秀本科生的精英人才计划</li></ul><h2 id="课程学习"><a href="#课程学习" class="headerlink" title="课程学习"></a>课程学习</h2><ul><li><a href="https://developers.google.cn/machine-learning/crash-course/" target="_blank" rel="noopener">机器学习速成课程</a> : Google制作的节奏紧凑、内容实用的机器学习简介课程</li><li><a href="http://study.163.com/course/introduction/1004570029.htm" target="_blank" rel="noopener">吴恩达</a> : 机器学习课程</li><li><a href="https://mooc.study.163.com/smartSpec/detail/1001319001.htm" target="_blank" rel="noopener">吴恩达</a> : 深度学习课程</li><li><a href="https://www.bilibili.com/video/av4294020/" target="_blank" rel="noopener">林轩田</a> : 机器学习基石</li><li><a href="https://www.bilibili.com/video/av12469267" target="_blank" rel="noopener">林轩田</a> : 机器学习技法</li><li><a href="https://coding.imooc.com/class/169.html" target="_blank" rel="noopener">liuyubobobo</a> : Python3 入门机器学习</li><li><a href="http://www.fast.ai/" target="_blank" rel="noopener">fast.ai</a> : Making neural nets uncool again</li><li><a href="https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw" target="_blank" rel="noopener">3Blue1Brown</a> : YouTube | 数学基础频道</li><li><a href="https://www.youtube.com/channel/UCbfYPyITQ-7l4upoX8nvctg" target="_blank" rel="noopener">Two Minute Papers</a> : YouTube | 最简短的语言概况最新的热点论文</li><li><a href="https://metacademy.org/" target="_blank" rel="noopener">Metacademy</a> : 知识点检索并画出通向这个知识点的知识图谱</li></ul><h2 id="开源资源"><a href="#开源资源" class="headerlink" title="开源资源"></a>开源资源</h2><ul><li><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">Coursera-ML-AndrewNg-Notes</a> : 吴恩达老师的机器学习课程个人笔记</li><li><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener">deeplearning_ai_books</a> : 吴恩达老师的深度学习课程笔记及资源</li><li><a href="https://github.com/jobbole/awesome-machine-learning-cn" target="_blank" rel="noopener">awesome-machine-learning-cn</a> : 机器学习资源大全中文版，包括机器学习领域的框架、库以及软件</li><li><a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">周志华 - 机器学习</a> : 周志华《机器学习》笔记</li><li><a href="https://github.com/MorvanZhou/tutorials" target="_blank" rel="noopener">ml_tutorials</a> : 机器学习相关教程</li><li><a href="https://github.com/ty4z2008/Qix/blob/master/dl.md" target="_blank" rel="noopener">Machine Learning、Deep Learning</a> : ML&amp;DL资料</li><li><a href="https://github.com/lawlite19/MachineLearning_Python" target="_blank" rel="noopener">MachineLearning_Python</a> : 机器学习算法python实现</li></ul><h2 id="开源书籍"><a href="#开源书籍" class="headerlink" title="开源书籍"></a>开源书籍</h2><ul><li><a href="https://github.com/exacity/deeplearningbook-chinese" target="_blank" rel="noopener">deeplearningbook-chinese</a> : 深度学习中文版</li><li><a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> : 深度学习开源书籍</li><li><a href="https://github.com/zhanggyb/nndl" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> : 深度学习开源书籍 - 中文</li><li><a href="https://github.com/apachecn/hands_on_Ml_with_Sklearn_and_TF" target="_blank" rel="noopener">hands_on_Ml_with_Sklearn_and_TF</a> : Sklearn与TensorFlow机器学习实用指南</li><li><a href="https://github.com/apachecn/MachineLearning" target="_blank" rel="noopener">机器学习实战</a> : Machine Learning in Action（机器学习实战）</li></ul><h2 id="名库文档"><a href="#名库文档" class="headerlink" title="名库文档"></a>名库文档</h2><ul><li><a href="https://www.tensorflow.org/tutorials/" target="_blank" rel="noopener">TensorFlow</a> : TF官方文档</li><li><a href="https://pytorch.org/tutorials/" target="_blank" rel="noopener">PyTorch</a> : PyTorch官方文档</li><li><a href="http://caffe.berkeleyvision.org/" target="_blank" rel="noopener">Caffe</a> : 一个基于表达式，速度和模块化原则创建的深度学习框架</li><li><a href="https://keras.io/" target="_blank" rel="noopener">Keras</a> : Keras官方文档</li><li><a href="http://neon.nervanasys.com/index.html/" target="_blank" rel="noopener">Neon</a> : Nervana公司一个基于Python的深度学习库</li><li><a href="https://docs.chainer.org/en/stable/" target="_blank" rel="noopener">Chainer</a> : 基于Python的独立的深度学习模型开源框架</li><li><a href="http://scikit-learn.org/stable/documentation.html" target="_blank" rel="noopener">scikit-learn</a> : scikit-learn官方文档</li><li><a href="http://pybrain.org/docs/" target="_blank" rel="noopener">PyBrain</a> : 一个模块化的Python机器学习库</li><li><a href="http://www.statsmodels.org/stable/index.html" target="_blank" rel="noopener">Statsmodels</a> : 用来探索数据，估计统计模型，进行统计测试</li><li><a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano</a> : 允许高效地定义、优化以及评估涉及多维数组的数学表达式</li><li><a href="http://deeplearning.net/software/pylearn2/" target="_blank" rel="noopener">Pylearn2</a> : 构建于Theano之上的机器学习库</li><li><a href="https://radimrehurek.com/gensim/index.html" target="_blank" rel="noopener">Gensim</a> : 包含可扩展的统计语义，分析纯文本文档的语义结构，以及检索相似语义的文档等功能</li><li><a href="http://www.numpy.org/" target="_blank" rel="noopener">NumPy</a> : NumPy官方文档</li><li><a href="http://pandas.pydata.org/pandas-docs/stable/" target="_blank" rel="noopener">pandas</a> : pandas官方文档</li><li><a href="https://matplotlib.org/tutorials/index.html" target="_blank" rel="noopener">Matplotlib</a> : Matplotlib官方文档</li></ul>]]></content>
      
      
      <categories>
          
          <category> resource </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探外观模式</title>
      <link href="/design-pattern/2018-08-15-facade/"/>
      <url>/design-pattern/2018-08-15-facade/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/facade" target="_blank" rel="noopener">koonchen/design-patterns/facade</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p> 为子系统中的一组接口提供一个一致的界面， Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></blockquote><p>假设我们拥有一个编程器，这个编译器包含一些类，比如： Scanner 、 Parser 、 ProgramNode 、 BytecodeStream 和 ProgramNodeBuilder 等，用于实现编译器。大多数的用户仅仅将使用编译器完成编译工作，子系统中那些功能强大但层次较低的接口只会让他们将任务复杂化。</p><p>现在，我们用一个 Compiler 类来定义这个编译器的统一接口，它是一个外观，给用户提供了一个统一而简单的编译器子系统接口。这方便了大多数人使用，同时也对懂得使用底层功能的人展示它的底层功能。</p><p>什么情况下适用外观模式：</p><blockquote><ul><li>当我们要为一个复杂子系统提供一个简单接口的时候：子系统往往因为不断演化而变得越来越复杂。这给那些不需要定制子系统的用户适用上造成困难，而 Facade 可以提供一个简单的缺省视图，这一视图对大多数用户而言已经足够，而需要定制的用户则可以通过 Facade 层来使用子系统。</li><li>客户程序与抽象类的实现之间存在很大的依赖性：引入 Facade 将这个子系统与客户以及其他的子系统进行分离，可以提高子系统的独立性和可移植性。</li><li>使用 Facade 作为子系统的入口：如果子系统之间相互通讯，那么 Facade 可以简化它们的依赖关系。</li></ul></blockquote><p>Facade 模式的参与者：</p><blockquote><ul><li>Facade ( Compiler ) : 知道哪些子系统负责处理请求，将用户的请求恰当发送。</li><li>Subsystem classes ( Scanner 等 )：实现子系统的功能，处理 Facade 指派。</li></ul></blockquote><p><em>PS: 没有从子系统指向 Facade 的指针。</em></p><p>该系统的结构如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/facade.png" alt="cover"></p><p>从协作角度出发，我们可以这样理解这个系统：</p><blockquote><ul><li>客户程序通过发送请求给 Facade 的方式与子系统通讯， Facade 将这些消息转发给适当的子系统对象。</li><li>使用 Facade 的客户程序不需要直接直接访问子系统对象。</li></ul></blockquote><p>Facade 模式具有以下优点：</p><blockquote><ul><li>它对客户屏蔽子系统组件，因为减少了客户处理的对象的数目并使得子系统使用起来更加方便。</li><li>它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的，松耦合关系使得子系统的组件变化不会影响到它的客户。 Facade 模式有助于建立层次结构系统，也有助于对对象之间的依赖关系分层。</li><li>如果应用需要，它并不限制它们使用子系统。因此我们可以在系统易用性和通用性之间加以选择。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现上，我们需要注意以下几点：</p><blockquote><ul><li>降低客户 - 子系统之间的耦合度：用抽象类实现 Facade 而它的具体子类对应于不同的子系统实现，这可以进一步降低客户与子系统的耦合度。现在，客户可以通过抽象的 Facade 类接口与子系统通讯。</li><li>公共子系统类与私有子系统类：一个子系统与一个类的相似之处在于，他们都有接口并且他们都封装了一些东西——类封装了状态和操作，而子系统封装了一些类。</li></ul></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSystem</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"BaseSystem instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">otherOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span> <span class="keyword">extends</span> <span class="title">BaseSystem</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Scanner instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span> <span class="keyword">extends</span> <span class="title">BaseSystem</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Stream instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompilerFacade</span> </span>&#123;</span><br><span class="line">  List&lt;BaseSystem&gt; subSystems;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CompilerFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    subSystems = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    subSystems.add(<span class="keyword">new</span> Scanner());</span><br><span class="line">    subSystems.add(<span class="keyword">new</span> Stream());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">makeActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    subSystems.forEach(item -&gt; &#123;</span><br><span class="line">      item.operation();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CompilerFacade facade = <span class="keyword">new</span> CompilerFacade();</span><br><span class="line">    facade.makeActions();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>facade 在这里的实现就是一个子系统的入口。</p><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSystem</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'BaseSystem instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span><span class="params">(BaseSystem)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Scanner instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span><span class="params">(BaseSystem)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Stream instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompilerFacade</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._scanner = Scanner()</span><br><span class="line">        self._stream = Stream()</span><br><span class="line">        self._sub_systems = [self._scanner, self._stream]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        [i.operation() <span class="keyword">for</span> i <span class="keyword">in</span> self._sub_systems]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    facade = CompilerFacade()</span><br><span class="line">    facade.operation()</span><br></pre></td></tr></table></figure><p>实现大同小异。</p><blockquote><p>PS: 妥协了，从上一章开始，就改用 pyhton 的四格缩进了…</p></blockquote><ul><li><p>Abstract Factory 模式可以与 Facade 模式一起使用以提供一个接口，这一个接口可用来与一种子系统独立地方式创建子系统对象。当然， Abstract Factory 也可以代替 Facade 来隐藏那些平台相关的类，就是还需要管理子类，更显复杂。</p></li><li><p>Mediator 模式还没有开始，它与 Facade 相似的地方是，它抽象了一些已有的类的功能。然而 Mediator 的目的是对同事之间的任意通讯进行抽象，通常集中不属于任何单个对象的功能。它的同事知道中介者，并与其通讯。而 Facade 模式仅对子系统的接口进行抽象，它不会定义新的功能，子系统也不知道 Facade 的存在。</p></li><li><p>通常，只有一个 Facade 对象，所以它属于 Singleton 模式。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 外观 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习从分类到降维</title>
      <link href="/machine-learning/2018-08-14-review-classify-to-dimensionality-reduction/"/>
      <url>/machine-learning/2018-08-14-review-classify-to-dimensionality-reduction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Review the key points from Classify to Dimensionality Reduction.</p></blockquote><p>我把总结笔记手写在了本子上，因为结合了吴恩达笔记一起学习，所以够我喝三壶 … 所幸现在脑子里的线条已经流畅了。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><a href="https://chenzeping.com/ml-review/hands-on/review_classify.html">link_to_code</a></p><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p><a href="https://chenzeping.com/ml-review/hands-on/train_model.html">link_to_code</a></p><h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><p><a href="https://chenzeping.com/ml-review/hands-on/SVM.html">link_to_code</a></p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p><a href="https://chenzeping.com/ml-review/hands-on/decision_tree.html">link_to_code</a></p><h2 id="集成学习和随机森林"><a href="#集成学习和随机森林" class="headerlink" title="集成学习和随机森林"></a>集成学习和随机森林</h2><p><a href="https://chenzeping.com/ml-review/hands-on/random_forests.html">link_to_code</a></p><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p><a href="https://chenzeping.com/ml-review/hands-on/dimensionality_reduction.html">link_to_code</a></p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探装饰模式</title>
      <link href="/design-pattern/2018-08-07-decorator/"/>
      <url>/design-pattern/2018-08-07-decorator/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/decorator" target="_blank" rel="noopener">koonchen/design-patterns/decorator</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>动态地给一个对象增加一些额外的职责。就增加功能来说， Decorator 模式相比生成子类更加灵活。</p></blockquote><p>一个图形界面允许我们仅仅给某个窗口增加特性，比如窗口滚动。我们可以将窗口滚动的边框加入到一个组件中，这个对象被称为 <strong>装饰</strong> 。这个装饰与它所装饰的组件接口一致，因此它对使用该组件的客户透明。</p><p>假设现在有一个对象被称作 <code>TextView</code> ，它可以在窗口中显示正文，缺省的 <code>TextView</code> 没有滚动条，因为我们可能并不需要滚动条。当需要滚动条的时候，我们可以使用 <code>ScrollDecorator</code> 添加滚动条到 <code>TextView</code> 。如果我们还想在 <code>TextView</code> 周围增加一个粗黑边框，我们可以使用 <code>BorderDecorator</code> 添加滚动条。示意图如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/decorator-1.jpg" alt="cover"></p><p>从上文，我们可以发现， <code>ScrollDecorator</code> 和 <code>BorderDecorator</code> 类是 <code>Decorator</code> 类的子类。 <code>Decorator</code> 类是一个可视化组件的抽象类，具体结构如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/decorator-2.jpg" alt="cover"></p><p><code>VisualComponent</code> 是一个描述可视对象的抽象类，它定义了绘制和事件处理的接口。 <code>Decorator</code> 的子类为特定功能增加一些操作。比如我现在想要一个滚动窗口，那么就可以使用 <code>ScrollDecorator</code> 对象的 <code>ScrollTo</code> 操作滚动这个界面，同时，我们不会感受到装饰和未装饰的差异。</p><p>在以下情况使用 Decorator 模式：</p><blockquote><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象增加职责；</li><li>处理那些可以撤销的职责；</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立地扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li></ul></blockquote><p>参与者以下：</p><blockquote><ul><li>Component — 定义一个对象接口，可以给这些对象动态地增加职责。</li><li>ConcreteComponent — 定义一个对象，可以给这个对象添加一些职责。</li><li>Decorator — 维持一个指向 Component 对象的指针，并定义一个与 Component 接口一致地接口。</li><li>ConcreteDecorator — 向组件添加职责。</li></ul></blockquote><p>总体结构如下：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/decorator.jpg" alt="cover"></p><p>decorator 模式的优点及缺点</p><blockquote><ul><li>比静态继承更灵活：与对象的静态继承相比， Decorator 模式提供了更加灵活的对象添加职责的方式。可以用添加和分离的方法，用装饰在运行时刻增加和删除职责。相比之下，继承机制要求为每个增加的职责创建一个新的子类，这会导致产生许多新的类，并且会增加系统复杂度。甚至可以对一个特定的 Component 类提供多个不同的 Decorator 类，这就使得你可以对一些职责进行混合和匹配。</li><li>避免在层级结构高层的类有太多的特征： Decorator 模式是一种即用即付的方法来添加职责。它并不试图在一个复杂的可定制的类中支持所有可预见的特征，相反，你可以定义一个简单的类，并且用 Decorator 类给他组件添加功能。</li><li>Decorator 与它的 Component 不一样： Decorator 是一个透明的包装。如果我们从对象标识的观点出发，一个被装饰了的组件与这个组件是有差别的，因此，使用装饰时不应该依赖对象标识。</li><li>有许多小对象：采用 Decorator 模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在他们相互连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。尽管对于那些了解这些系统的人来说，很容易对它们进行定制，但是很难学习这些系统，排错也很困难。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现 Decorator 模式时有以下几点需要注意：</p><blockquote><ul><li>接口一致性：装饰对象的接口必须与它所装饰的 Component 的接口是一致的。</li><li>省略抽象的 Decorator 类：当仅需添加一个职责时，没有必要定义抽象 Decorator 类。</li><li>保持 Component 类的简单性：为了保证接口的一致性，组件和装饰必须公用一个父类，保持简单性很重要。</li><li>改变对象外壳与改变对象内核：可以将 Decorator 看做一个对象的外壳，他可以改变这个对象的行为。</li></ul></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Component instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"DecoratorClient instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  Component component;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.component = component;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    component.operation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(component);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addedState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Added state"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorB</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(component);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addedBehavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Added behavior"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ConcreteComponent component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">    ConcreteDecoratorA concreteDecoratorA = <span class="keyword">new</span> ConcreteDecoratorA(component);</span><br><span class="line">    ConcreteDecoratorB concreteDecoratorB = <span class="keyword">new</span> ConcreteDecoratorB(component);</span><br><span class="line">    component.operation();</span><br><span class="line">    concreteDecoratorA.addedState();</span><br><span class="line">    concreteDecoratorB.addedBehavior();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对原始的 <code>ConcreteComponent</code> 增加了 <code>addedState</code> 和 <code>addedBehavior</code> 两个方法。</p><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Component instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span><span class="params">(Component)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'ConcreteComponent instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(Component)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, component)</span>:</span></span><br><span class="line">        self._component = component</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Decorator instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Decorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addedState</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Added state'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span><span class="params">(Decorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addedBehavior</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Added behavior'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    component = ConcreteComponent()</span><br><span class="line">    componenta = ConcreteDecoratorA(component)</span><br><span class="line">    componentb = ConcreteDecoratorB(component)</span><br><span class="line">    component.operation()</span><br><span class="line">    componenta.addedState()</span><br><span class="line">    componentb.addedBehavior()</span><br></pre></td></tr></table></figure><p>实现大同小异，不再赘述。</p><p>相关模式：</p><blockquote><ul><li>Adapter 模式： Decorator 模式不同于 Adapter 模式，因为装饰仅仅改变对象的职责而不是改变接口；适配器模式给出了一个全新的接口。</li><li>Composite 模式：可以将装饰视为一个退化的、仅有一个组件的组合模式。然而，装饰的目的是给对象增加职责，而不是将对象进行聚集。</li><li>Strategy 模式：用一个装饰可以改变对象的外表；而 Strategy 模式使得我们可以改变对象的内核。这是改变对象的两种途径。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探组合模式</title>
      <link href="/design-pattern/2018-07-26-composite/"/>
      <url>/design-pattern/2018-07-26-composite/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/composite" target="_blank" rel="noopener">koonchen/design-patterns/composite</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>将对象组合成树形结构以表示 <strong>部分—整体</strong> 的层次结构。 Composite 使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><p>我们假设存在一个图形编辑器，用户可以组合多个简单组件以形成一个较大的组件，这些组件又可以组合成更大的组件。一个简单的想法是使用 <code>Text</code> 和 <code>Line</code> 这样的图元来定义一些类，与此同时，定义另一些类作为图元的容器类。</p><p>然而，这样做的后果是我们将区别对待图元对象和容器对象，而实际上大多数情况下用户认为他们是一样的。区别对待将使得程序更加复杂。 Composite 模式描述了如何使用递归组合，使得用户不必对这些类进行区别对待，如下图：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/composite-1.jpg" alt="cover"></p><p>Composite 模式的关键是一个抽象类，它既可以代表图元也可以代表图元的容器。在图形系统中这个类就是 <code>Graphic</code> ，它声明了一些与特定图形对象相关的操作。在其子类如 <code>Line</code> 、 <code>Rectangle</code> 、 <code>Text</code> 中定义图元，并实现一些图元操作。而子类如 <code>Picture</code> 定义了图元容器，实现了图元容器的方法。而因为图元和容器使用了相同的父类 ( 接口 ) ，因此容器对象可以递归组合其他 <code>Graphic</code> 子类。其结构如下图：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/composite-2.jpg" alt="cover"></p><p>什么情况下适用这种模式：</p><blockquote><ul><li>想表示对象的 部分—整体 层次结构。</li><li>希望用户忽略组合对象与单个对象的不同，用户将统一地适用组合结构中的所有对象。</li></ul></blockquote><p>他的参与者如下：</p><blockquote><ul><li>Component ( Graphic ) — 为组合中的对象声明的接口。</li><li>Leaf ( Rectangle 等 ) — 定义图元对象。</li><li>Composite ( Picture 等 ) — 定义容器 ( 部件 ) 对象。</li><li>Client — 通过 Composite 接口操纵组合容器的对象。</li></ul></blockquote><p>现在 composite 结构就很明显了：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/composite-pattern.jpg" alt="cover"></p><p>composite 模式具有以下特点：</p><blockquote><ul><li>定义了包含基本对象和组合对象的类层次结构：基本对象可以被组合成更复杂的组合对象，而这个组合对象可以被二次组合，这样不断递归下去。</li><li>简化客户代码：客户可以一致地使用组合结构和单个对象。客户也无需知道使用的子节点还是组合组件。</li><li>使得更容易增加新类型的组件：新定义的 <code>Composite</code> 或 <code>Leaf</code> 自动地与已有的结构和客户代码一起工作，无需对原有组件进行更改。</li><li>使得设计变得更加一般化：容易增加新组件也会产生一些问题，那就是很难限制组合中的组件。比如你希望只是用某些特定的组件来组合一个 <code>Composite</code> ，但是不能通过类型系统来进行约束，而是在运行时进行检查。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现 composite 模式时，有以下几点需要注意：</p><blockquote><ul><li>显式的父部件引用：保持从子部件到父部件的引用能简化组合结构的遍历和管理。</li><li>共享组件：减少对存储的需求。</li><li>最大化 <code>Component</code> 接口： composite 模式的目的之一是使用户不知道他们使用的是 <code>Leaf</code> 还是 <code>Composite</code> 。为了达到这个目的，公共接口应该尽量多定义操作，通常实现缺省。</li><li>声明管理子部件的操作：虽然 <code>Composite</code> 类实现了部分操作，但现在我们要作抉择：应该在 <code>Component</code> 中声明这些操作，并使这些操作对 <code>Leaf</code> 有意义呢？还是只在 <code>Composite</code> 和它的子类中声明并定义这些操作？</li></ul><p>这需要在安全性和透明性之间做出抉择：</p><blockquote><ul><li>在类层次结构的根部定义子节点管理结构的方法，具有良好的透明性，因为你一致地使用所有的组件，但是这一方法是以安全性为代价的，因为客户有可能会做一些无意义的事情，例如在 <code>Leaf</code> 中增加和删除对象等。</li><li>在 <code>Composite</code> 类中定义管理子部件的方法具有良好的安全性，因为在 C++ 这样的静态语言中，在编译时任何任何从 <code>Leaf</code> 中增加或删除对象的尝试都将被发现。但是这损失了透明性，因为现在 <code>Leaf</code> 和 <code>Composite</code> 相当于使用了不同的接口。</li></ul><p><strong>推荐的是选择透明性，即选择第一种方式。</strong>因为第二种方式可能会丢失类型信息，以至于我们不得不将一个组件转换成一个组件，这样的类型转换必定不是类型安全的。</p></blockquote></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Component instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function">Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Leaf instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  List list = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">    list.add(component);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">    list.remove(component);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Component) list.get(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Leaf leaf = <span class="keyword">new</span> Leaf();</span><br><span class="line">    Composite composite = <span class="keyword">new</span> Composite();</span><br><span class="line">    composite.add(leaf);</span><br><span class="line">    composite.getChild(<span class="number">0</span>).operation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 的实现比较统一，实现如上。</p><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, obj)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, obj)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_child</span><span class="params">(self, index)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(Component)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a leaf'</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Leaf instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span><span class="params">(Component)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._array = list()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">    self._array.append(obj)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">    self._array.remove(obj)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_child</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._array[index]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  composite = Composite()</span><br><span class="line">  leaf = Leaf()</span><br><span class="line">  composite.add(leaf)</span><br><span class="line">  composite.get_child(<span class="number">0</span>).operation()</span><br></pre></td></tr></table></figure><p>其他实现也大同小异。</p><p>从其他模式出发：</p><blockquote><ul><li>部件—父部件 的连接可用于 responsibility of chain 模式。</li><li>decorator 模式经常和 composite 模式一起使用。</li><li>flyweight 模式可以共享组件，但不再能引用他们的父组件。</li><li>iterator 可用于遍历 composite 。</li><li>visitor 将本来应该分布在 <code>Composite</code> 和 <code>Leaf</code> 类中的操作和行为局部化。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探桥接模式</title>
      <link href="/design-pattern/2018-07-22-bridge/"/>
      <url>/design-pattern/2018-07-22-bridge/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/bridge" target="_blank" rel="noopener">koonchen/design-patterns/bridge</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p></blockquote><p>假设有一个抽象有多种实现需要用继承来协调，但是继承机制将抽象与它的实现固定在一起，难以对抽象和实现独立地进行修改、扩充、重用。</p><p>现在 <code>Window</code> 上有一个抽象，我们可以将它移植到 <code>X Window System</code> 和 <code>Presentation Manager</code> 上，首先哟啊做的是实现窗口，我们分别用 <code>XWindow</code> 和 <code>PMWindow</code> 实现两种系统的窗口，但是这样做有两个不足之处：</p><ul><li>假设存在的抽象在 <code>Window</code> 下是 <code>IconWindow</code> 且用来处理图标，我们在另外两个系统下完成 <code>XIconWindow</code> 和 <code>PMIconWindow</code> 实现处理图标，加上窗口类，我们不得不为每一种类型的窗口都定义两个类，而为了支持第三个系统，我们还必须为每一种窗口定义一个新的 <code>Window</code> 子类，过于繁琐，如图：</li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/bridge-1.jpg" alt="cover"></p><ul><li>如果我们不创建两个类又会产生怎样的问题？继承机制使得客户代码与平台相关。比如 <code>XWindow</code> 对象将 <code>Window</code> 抽象和 <code>X Window</code> 的实现绑定在一起，使得很难将这些代码移植到其他平台上，所以客户在创建窗口时不应该涉及到具体实现。</li></ul><p>bridge 模式解决上面问题的方式是，将 <code>Window</code> 抽象和它的实现分别放到独立的类层次结构中。其中一个类层次结构针对窗口接口，比如： <code>IconWindow</code> 等，他们会在大量的系统中被使用；另一个类层次针对平台相关的窗口实现，其根类定为 <code>WindowImp</code> ，其子类用来实现平台的窗口实现。如下图结构所示：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/bridge.jpg" alt="cover"></p><p><code>Window</code> 子类的操作使用的都是 <code>WindowImp</code> 接口的抽象实现的，因此存在聚合关系，与此同时，窗口抽象和平台相关的实现成功进行了分离。我们将 <code>Window</code> 和 <code>WindowImp</code> 之间的关系称作 <strong>桥接</strong> 。</p><p>什么时候适合这种模式：</p><blockquote><ul><li>不希望在抽象和实现之间有一个固定的绑定。</li><li>类的抽象以及它的实现都可以通过生成子类的方法进行扩充。</li><li>对抽象的实现部分修改希望对客户不产生影响。</li><li>希望对客户完全隐藏抽象的实现部分。</li><li>如图一中那样，有许多类要生成，我们必须将一个对象分解成两个部分，这种情况叫『嵌套的普化』。</li><li>希望在多个对象间共享实现，但同时客户并不知道这一点。</li></ul></blockquote><p>他拥有哪些参与者：</p><blockquote><ul><li>Abstraction ( Window ) — 定义抽象类的接口。</li><li>RefinedAbstraction ( IconWindow ) — 扩充由 Abstraction 定义的接口。</li><li>Implementor ( WIndowImp ) — 定义实现类接口，一般该接口仅提供基本操作。</li><li>ConcreteImplementor ( XWindowImp ) — 实现 Implementor 接口。</li></ul></blockquote><p>现在， bridge 模式的结构就呼之欲出了：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/bridge-pattern.png" alt="cover"></p><p>bridge 模式的优点主要体现在：</p><blockquote><ul><li>分离接口及其实现部分：一个实现未必不变地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。同时，接口与实现分离有助于分层。</li><li>提高可扩充性：可以独立地对 <code>Abstraction</code> 和 <code>Implementor</code> 层次进行扩充。</li><li>实现细节对客户透明：可以对客户隐藏实现细节。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现 bridge 模式前，有几点需要注意的内容：</p><blockquote><ul><li>仅有一个 <code>Implementor</code> ：在只有一个实现的时候，没有必要创建一个抽象的 <code>Implementor</code> 类。这是 bridge 模式的退化情况；在 <code>Abstraction</code> 与 <code>Implementor</code> 之间有一种一对一的关系。尽管如此，当你希望改变一个类的实现不会影响已有的客户程序的时候，模式的分离机制还是非常有用的，不必重新编译它们，仅需重新连接即可。在 C++ 中， <code>Implementor</code> 类的类接口可以在一个私有的头文件中定义，这个文件不提供给客户，这样你就对客户彻底隐藏了一个类的实现。</li><li>创建正确的 <code>Implementor</code> 对象：当存在多个 <code>Implementor</code> 类时，你应该用何种方法，在何时何处确定创建哪一个 <code>Implementor</code> 类呢？如果 <code>Abstraction</code> 知道所有的 <code>ConcreteImplementor</code> 类，它就可以在它的构造器中对其中一个类进行实例化；或者我们可以首先选择一个缺省的实现，然后根据需求改变这个实现；也可以代理给另一个对象，由它一次决定。</li><li>共享 <code>Implementor</code> 对象： C++ 中常用 Handle/Body 方法在多个对象间共享一些实现，包括 C++ 在内一般是使用引用计数器，需要维护指向 <code>Implementor</code> 的指针。</li><li>采用多重继承机制：假设我们在 C++ 中用 pulic 继承 <code>Abstraction</code> ，而以 private 继承 <code>ConcreteImplementor</code> ，我们知道这种方法依赖于静态继承，它将实现部分与接口固定不变地绑定在一起。因此在 C++ 中不能用多重继承来实现真正的 bridge 模式。</li></ul></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">  Implementor implementor;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    implementor.operationImp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operationImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Implementor instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(String classname)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      implementor = (Implementor) Class.forName(classname).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">extends</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operationImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ConcreteImplementorA instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorB</span> <span class="keyword">extends</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operationImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ConcreteImplementorB instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Abstraction abstraction = <span class="keyword">new</span> RefinedAbstraction(ConcreteImplementorA.class.toString().substring(<span class="number">6</span>));</span><br><span class="line">    abstraction.operation();</span><br><span class="line">    abstraction = <span class="keyword">new</span> RefinedAbstraction((ConcreteImplementorB.class.toString().substring(<span class="number">6</span>)));</span><br><span class="line">    abstraction.operation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主流实现也大多异曲同工，或者改用接口的方式，在 <code>Implementor</code> 下定义通用的方法抽象，在 <code>Abstraction</code> 下定义使用者的抽象，因为抽象和实现进行了分离，所以可以更加灵活实现其他功能。</p><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementor</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">operationImp</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Implementor instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._imp.operationImp()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span><span class="params">(Implementor)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">operationImp</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'ConcreteImplementorA instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorB</span><span class="params">(Implementor)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">operationImp</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'ConcreteImplementorB instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span><span class="params">(Abstraction)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cls)</span>:</span></span><br><span class="line">    self._imp = cls()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  abstraction = RefinedAbstraction(ConcreteImplementorA)</span><br><span class="line">  abstraction.operation()</span><br><span class="line">  abstraction = RefinedAbstraction(ConcreteImplementorB)</span><br><span class="line">  abstraction.operation()</span><br></pre></td></tr></table></figure><p>在 python 下，我们可以将 <code>ConcreteImplementor</code> 作为参数在 <code>RefinedAbstraction</code> 中使用，实现与上例大同小异，所以不再复述实现了。</p><p>bridge 模式的重点在于<strong>将抽象和实现分离</strong>，这种思想的有趣之处在于消除了接口和实现的绑定，我们更加灵活地对实现增删改。</p><p>bridge 模式可以被 abstract factory 模式实现，把 <code>factory</code> 的子类作为 <code>ConcreteImplementor</code> ，把具体的 <code>RefinedAbstraction</code> 作为 <code>product</code> 的子类，可以解释为：特定的产品用特定的工厂实现来生产。但也存在不同，抽象工厂的主要目的是生产产品，重点是创建；桥接模式的主要目的是换一个方式使用实现，重点是使用。</p><p>adapter 模式用来帮助无关的类进行协同工作，它通常在系统设计完成才会被使用； bridge 模式则在系统开始就可以被使用。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桥接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探适配器模式</title>
      <link href="/design-pattern/2018-07-19-adapter/"/>
      <url>/design-pattern/2018-07-19-adapter/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/adapter" target="_blank" rel="noopener">koonchen/design-patterns/adapter</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>将一个类的接口转换成客户希望的另外一个接口。该模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><p>假设现在有一个绘图软件，我们可以绘制各种图形，并且这些图形可以进行编辑。所有的图形都实现于接口 <code>Shape</code> ，比如 <code>LineShape</code> 实现直线， <code>PolygonShape</code> 实现多边形，但是 <code>TextShape</code> 就没有这么简单了，我们要考虑到屏幕刷新和缓冲区管理的问题，我们假设在工具箱中已经有一个成品工具叫做 <code>TextView</code> 它完成了编辑和显示的工作，但此时， <code>TextView</code> 和 <code>Shape</code> 对象不能互换。</p><p>adapter 模式的解决方案是创建一个新的 <code>TextShape</code> 子类，由它适配 <code>TextView</code> 和 <code>Shape</code> 的接口。我们可以通过两种方法完成这件事：</p><ol><li>实现 <code>Shape</code> 接口和继承 <code>TextView</code> ，做单实现单继承或双继承，这称为 <strong>类适配器</strong> 。</li><li>将 <code>TextView</code> 实例作为 <code>TextShape</code> 的组成部分，使用 <code>TextView</code> 的接口实现 <code>TextShape</code> ，此时 <code>TextView</code> 和 <code>TextShape</code> 之间的关系是关联，然后实现 <code>Shape</code> 接口，做单实现，这称为 <strong>对象适配器</strong> 。结构看下类图：</li></ol><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/adapter.jpg" alt="cover"></p><p>这里我们将 <code>TextShape</code> 称为 <code>Adapter</code> 。</p><p>Adapter 模式的使用情况：</p><blockquote><ul><li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li><li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。</li><li>你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以适配它们的接口。<strong>此时适配器可以适配它的父类接口</strong>。</li></ul></blockquote><p>他有以下参与者：</p><blockquote><ul><li>Target ( Shape ) — 定义 Client 使用的与特定领域相关的接口。</li><li>Client ( DrawingEditor ) — 与符合 Target 接口的对象协同。</li><li>Adaptee ( TextView ) — 已经存在的接口，这个接口需要适配。</li><li>Adapter ( TextShape ) — 对 Adaptee 的接口和 Target 接口进行适配。</li></ul></blockquote><p>适配器结构已经呼之欲出了 ( 对象适配器 ) ：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/adapter-pattern.jpg" alt="cover"></p><blockquote><p>事实上，对于适配器模式，还有另外一种的结构，称为类适配器：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/adapter-pattern2.png" alt="cover"></p><hr><p><em>关于 <strong>对象适配器</strong> 和 <strong>类适配器</strong></em> ：</p><p>他们的结构不同，造成了一些差别，类适配器：</p><ul><li>用一个具体的 Adapter 类对 Adaptee 和 Target 进行适配。结果是我们想要适配一个类以及它所有的子类是不能胜任的。</li><li>使得 Adapter 可以重定义 Adaptee 的部分行为，因为 Adapter 此时是 Adaptee 的一个子类。</li><li>仅仅引入了一个对象，并不需要额外的指针以间接得到 Adaptee。</li></ul><p>对象适配器：</p><ul><li>允许一个 Adapter 与多个 Adaptee 同时工作，即 Adaptee 本身以及它的所有子类同时工作。</li><li>使得重定义 Adaptee 的行为比较困难，需要生成并引用 Adaptee 的子类并引用这个子类而非 Adaptee 本身。</li></ul><hr><p><em>关于使用 Adapter 模式时需要考虑的其他一些因素</em> ：</p><ul><li>Adapter 的适配程度：各个 Adapter 对于 Adaptee 的接口和 Target 接口适配的工作量是不一样的，这取决于它们的相似程度。</li><li>可插入的 Adapter ：当其他的类使用一个类时，如果所需的假定条件越少，这个类就更具有可复用性。如果将接口适配构建为一个类，就不需要假设对其他的类可见的是一个相同的接口，换句话说，接口适配使得我们可以将自己的类加入到一些现有的系统中去，这些系统对这个类的接口可能有所不同。</li><li>使用双向适配器提供透明操作：使用适配器的一个潜在问题是，它们不对所有的客户都透明。比如被适配的对象不再兼容 Adaptee 的接口，因此并不是所有 Adaptee 对象可以被使用的地方它都可以被使用。双向适配器提供了这样的透明性，在两个不同的客户需要用不同的方式查看同一个对象时，双向适配器尤其有用。 <em>PS：所谓的双向适配器结构与类适配器相同，属于多重继承。</em></li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现中有以下注意点：</p><blockquote><p>在 c++ 实现时， Adapter 类应该采用公共方式继承 Target 类，并且用私有方式继承 Adaptee 类，因此 Adapter 类应该是 Target 的子类，但不是 Adaptee 的子类。有许多方法可以实现可插入的适配器。</p><p>这里有三种实现方法，首先，是为 Adaptee 找到一个窄的接口，即可用于适配的最小操作集。因为包含较少操作的窄接口相对容易进行适配：</p><ul><li>使用抽象操作：在父类 ( Target ) 中使用子类 ( Adapter ) 方法，而该方法可能与 Adaptee 存在某关系，比如关联。如下图所示：</li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/adapter-abstract.png" alt="cover"></p><ul><li>使用代理对象：从下面的机构中可以发现，现在我们将 Client 和 Target 进行了分离， Adapter 仅继承自被委派的具体的 Target ，其他部分和抽象操作是一样的。</li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/adapter-agency.png" alt="cover"></p><ul><li>参数化适配器：在 Smalltalk 中可以用一个或多个模块对适配器进行参数化。一个模块可以适配一个请求，并且适配器可以为每个请求存储一个模块。在本例中，先将一个结构进行转换，另一个模块存储。这种方式相对子类化是更方便的。</li></ul><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/adapter-parameter.png" alt="cover"></p></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Adaptee instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    adaptee.specificRequest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">    adapter.request();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Client client = <span class="keyword">new</span> Client();</span><br><span class="line">    client.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按照对象适配器完成了单实现的 Adapter 模式。</p><p>在实际使用中，我们常常会有这样的状况，我们先用接口实现一个类，这个类的方法在下一个需要实现的类中也要使用，再次从头创建比较浪费时间，此时，适配器模式很好地处理了这件事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TargetPro</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">requestPro</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapteePro</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">specificRequestPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AdapteePro instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapterPro</span> <span class="keyword">implements</span> <span class="title">TargetPro</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  AdapteePro adapteePro;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AdapterPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.adapteePro = <span class="keyword">new</span> AdapteePro();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    adapteePro.specificRequestPro();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientPro</span> <span class="keyword">implements</span> <span class="title">TargetPro</span> </span>&#123;</span><br><span class="line">  TargetPro targetPro;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClientPro</span><span class="params">(TargetPro targetPro)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.targetPro = targetPro;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestPro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    targetPro.requestPro();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterProClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    ClientPro client = <span class="keyword">new</span> ClientPro(<span class="keyword">new</span> AdapterPro());</span><br><span class="line">    client.requestPro();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果我们继续实现具体的 <code>Target</code> ，只需要使用已有的 <code>Adapter</code> 作为参数即可。</p><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">specificRequest</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'"Adaptee instance has been created"'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span><span class="params">(Target)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._adaptee = Adaptee()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._adaptee.specificRequest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  adapter = Adapter()</span><br><span class="line">  adapter.request()</span><br></pre></td></tr></table></figure><p>这样实现了基本的对象适配器。</p><p>参考 <a href="https://github.com/faif/python-patterns/blob/master/structural/adapter.py" target="_blank" rel="noopener">python-patterns/structural/adapter.py</a> 。和 Smalltalk 类似，用 Python 也可以实现参数化的适配器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._name = <span class="string">"Dog"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"woof!"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._name = <span class="string">"Cat"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">meow</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"meow!"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._name = <span class="string">"Human"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj, **kwargs)</span>:</span></span><br><span class="line">    self._obj = obj</span><br><span class="line">    self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> getattr(self._obj, item)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">original_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._obj.__dict__</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  dog = Dog()</span><br><span class="line">  objects = []</span><br><span class="line">  objects.append(Adapter(dog, make_noise = dog.bark()))</span><br><span class="line">  cat = Cat()</span><br><span class="line">  objects.append(Adapter(cat, make_noise = cat.meow()))</span><br><span class="line">  human = Human()</span><br><span class="line">  objects.append(Adapter(human, make_noise = human.speak()))</span><br><span class="line">  <span class="keyword">for</span> obj <span class="keyword">in</span> objects:</span><br><span class="line">    print(<span class="string">f'A <span class="subst">&#123;obj._name&#125;</span> goes <span class="subst">&#123;obj.make_noise&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>Brige 模式的结构和对象适配器类似，但是它们的出发点不同:</p><ul><li>Brige 的目的是将接口和实现分离。</li><li>Adapter 的目的是改变一个已有对象的接口。</li></ul><p>Decorator 模式增强了其他对象的功能而同时不改变它的接口，因此 Decorator 模式对应用的透明性比 Adapter 模式好，同时 Decorator 支持递归组合，而纯粹的 Adapter 无法实现这一点。</p><p>Proxy 模式在不改变它的接口的条件下，为另一个对象定义了一个代理。</p><p>这些，我们将在未来将一探究竟。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 适配器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探生成器模式</title>
      <link href="/design-pattern/2018-07-12-builder/"/>
      <url>/design-pattern/2018-07-12-builder/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/builder" target="_blank" rel="noopener">koonchen/design-patterns/builder</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>现在有一个 RTF 文档阅读器我们叫他 <code>RTFReader</code> ，他可以将阅读内容转换成多种正文格式，比如 ASCII 或一个正文窗口组件等。我们在完成这一转换时，有一个问题是转换的数量是无限的，我们需要实现新的转换的增加的同时，不改变 <code>RTFReader</code> 本身。</p><p>生成器模式的解法是使用一个统一的 <code>TextConvert</code> 接口完成转换，当 <code>RTFReader</code> 读出一个 RTF 标记，就给他进行转换，而具体的转换方法又是 <code>TextConvert</code> 接口的具体实现，因此可以在不改变 <code>RTFReader</code> 的实现的同时，非常便捷地完成转换工作。</p><p>上面的模式实现中， <code>RTFReader</code> 我们称之为 Director 导向器， <code>TextConvert</code> 的每一个具体实现都称之为 Builder 生成器。因此，<strong>生成器模式的目的就是将对象的处理和对象的组成进行分离</strong>。下图展示了上例：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/builder.png" alt="cover"></p><p>Builder 模式的使用情况：</p><blockquote><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li><li>当构造过程必须允许被构造的对象有不同的表示时。</li></ul></blockquote><p>他拥有以下参与者：</p><blockquote><ul><li>Builder—为创建一个 Product 对象的各个部件指定抽象接口。</li><li>ConcreteBuilder—实现接口以构造和装配产品的各个部件。还需要有一个检查产品的接口，一般是 Get 方法，验证生成对象。</li><li>Director—构造一个使用 Builder 接口的对象。</li><li>Product—表示被构造的对象。</li></ul></blockquote><p>模式结构也就清晰了：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/builder-pattern.png" alt="cover"></p><p>因为用了接口方法，所以聚合关系是必须的。在协作中，产品需要早于工厂，生成器早于导向器，接着用 Builder 创建各个部分，最后检查产品，结束。</p><blockquote><ul><li>改变一个产品的内部表示。 Builder 相当于产品的构造，现在被分离了，定义一个新的生成方法非常简单，改变内部表示就是这个意思。</li><li>分离构造和表示。不同的 Director 可以复用不同的 Builder ，而 Director 和 Builder 又互不相知。</li><li>构造过程进行更精细的控制。因为导向器的存在，我们可以一步一步构造产品，比如每次创建一个部分，所以 Builder 接口也就比其他创建型模式更好反映了产品的构造过程。</li></ul></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>生成器先于导向器完成，默认情况下什么都不做，只在具体的 <code>ConcreteBuilder</code> 中进行实现，而这个过程中有三个小问题：</p><blockquote><ul><li>装配和构造接口：构造尽量简单通用，Builder 装配需要满足各种具体生成器，因此突出两个字，<strong>简单</strong>。</li><li>为什么产品没有抽象类：以上面的 RTF 为例，ASCII 格式和其他文本对象之间可能千差万别，同时现在我们处于一个知道每一步装配什么的位置，<strong>产品公共接口的存在并不必须也不重要也不大可能</strong>。</li><li>Builder 缺省方法：接口没有具体实现当然是不存在的，这里的意思是有一个默认的空方法， C++ 中也就是非纯虚函数， java 就用抽象类实现。</li></ul></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String describe;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withNameDes</span><span class="params">(String name, String describe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.describe = describe;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Product&#123;"</span> +</span><br><span class="line">        <span class="string">"describe='"</span> + describe + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">  Product product = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Product <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(product);</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">buildPart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    product = <span class="keyword">new</span> Product();</span><br><span class="line">    product.withNameDes(<span class="string">"product"</span>, <span class="string">"Product instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">  Builder builder;</span><br><span class="line">  Director(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.builder = builder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    builder.buildPart();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderBasic</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">    Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">    director.construct();</span><br><span class="line">    builder.getResult();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，实际上产品是被导向器使用接口所创建的，我们需要获得的是 <code>product</code> ，创建了 <code>builder</code> 来进行 <code>product</code> 的构建，使用 <code>director</code> 来进行使用，思考发现， <code>director</code> 的职能就是使用，因此进行一些改进：</p><ul><li>其一，不直观创建出 <code>director</code> ，而是将笔者角度来假设存在，这样我们的 <code>main</code> 或者实际调用处就作为 <code>director</code> 。</li><li>其二，我们所有的信息来源可以发现都是上面的 <code>builder</code> ，为什么我们的 <code>product</code> 存在的属性是这些，就是来自 <code>builder</code> ，因此完全可以对 <code>builder</code> 进行一定的扩展，将属性赋值给 <code>builder</code> ，而创建 <code>product</code> 的时候，直接使用 <code>builder</code> 对象，这样似乎更为直观。</li></ul><h3 id="java-改进"><a href="#java-改进" class="headerlink" title="java 改进"></a>java 改进</h3><p>根据上面的两点总结进行了改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdv</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String describe;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  ProductAdv(ConcreteBuilderAdv builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.describe = builder.getName();</span><br><span class="line">    <span class="keyword">this</span>.name = builder.getDescribe();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ProductAdv&#123;"</span> +</span><br><span class="line">        <span class="string">"describe='"</span> + describe + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilderAdv</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String describe;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function">ConcreteBuilderAdv <span class="title">withName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ConcreteBuilderAdv <span class="title">withDes</span><span class="params">(String describe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.describe = describe;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> describe;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ProductAdv <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProductAdv(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderAdv</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ProductAdv product = <span class="keyword">new</span> ConcreteBuilderAdv()</span><br><span class="line">        .withName(<span class="string">"productAdv"</span>)</span><br><span class="line">        .withDes(<span class="string">"ProductAdv instance has been created"</span>)</span><br><span class="line">        .getResult();</span><br><span class="line">    System.out.println(product);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是 java 实现的生成器模式。</p><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><p>这里直接省略 director 的创建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withNameDes</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">    self._name = kwargs.get(<span class="string">'name'</span>)</span><br><span class="line">    self._des = kwargs.get(<span class="string">'describe'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name: '</span>+self._name+<span class="string">'\ndescribe: '</span>+self._des</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildePart</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getResult</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span><span class="params">(Builder)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildePart</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._product = Product()</span><br><span class="line">    self._product.withNameDes(name=<span class="string">'product'</span>,</span><br><span class="line">                              describe=<span class="string">'Product instance has been created'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getResult</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(self._product)</span><br><span class="line">    <span class="keyword">return</span> self._product</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  builder = ConcreteBuilder()</span><br><span class="line">  builder.buildePart()</span><br><span class="line">  builder.getResult()</span><br></pre></td></tr></table></figure><h3 id="python-改进"><a href="#python-改进" class="headerlink" title="python 改进"></a>python 改进</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, builder)</span>:</span></span><br><span class="line">    self._name = builder._name</span><br><span class="line">    self._describe = builder._describe</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name: '</span>+self._name+<span class="string">'\ndescribe: '</span>+self._describe</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withName</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self._name = name</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withDescribe</span><span class="params">(self, describe)</span>:</span></span><br><span class="line">    self._describe = describe</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getsult</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Product(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  product = ConcreteBuilder()\</span><br><span class="line">    .withName(<span class="string">'product'</span>)\</span><br><span class="line">    .withDescribe(<span class="string">'Product instance has been created'</span>)\</span><br><span class="line">    .getsult()</span><br><span class="line">  print(product)</span><br></pre></td></tr></table></figure><p>改进方式也是将 builder 封装而作为了参数。</p><blockquote><p> 我们常常拿抽象方法和生成器进行对比，或者将工厂和生成器进行对比，因为他们都可以完成复杂对象的创建，但是在 abstract factory 中，我们的目的是创建多个系列，而 builder 中是创建一种复杂对象且着重于一步步的构造。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探原型模式</title>
      <link href="/design-pattern/2018-07-04-prototype/"/>
      <url>/design-pattern/2018-07-04-prototype/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/prototype" target="_blank" rel="noopener">koonchen/design-patterns/prototype</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></blockquote><p>我们假设存在一个框架，它拥有大量的图形 <code>Graphic</code> ，对图形本身的选择等框架层面的功能存放在 <code>Tool</code> 中，并且每一个图形的创建都需要 <code>Tool</code> 的一个实现 <code>GraphicTool</code> 子类来协助。现在问题来了，框架的 <code>GraphicTool</code> 并不知道我们需要创建的 <code>Graphic</code> 具体是什么，最朴素的想法是为每一个图形都创建一个 <code>GraphicTool</code> 的子类，但这样将产生大量的子类，<strong>对象复合是比创建子类更灵活的一种选择</strong>。</p><p>原型模式让 <code>GraphicTool</code> 通过克隆具体图形( <code>Graphic</code> 子类，或者称之为<strong>原型</strong> )实例来创建新的图形，或者说将这个具体的图形实例作为了参数，所以如果 <code>Graphic</code> 子类都支持克隆操作，那么 <code>GraphicTool</code> 就可以克隆所有类型的图形。可以看下图更好理解这一模式：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/prototype.jpg" alt="cover"></p><p>什么时候适用这种模式：</p><blockquote><ul><li>当一个系统独立于它的产品创建、构造、表示时；</li><li>当要实例化的类是在运行时指定，比如动态加载时；</li><li>为了避免创建一个与产品类层次平行的工厂类层次时 ( 现在工厂类和产品类之间仅仅是聚合关系 ) ；</li><li>当一个类的实例只能有几个不同状态组合中的一种的时。</li></ul><p>建立相应数目的原型并克隆他们可能比每次用特定的状态手动实例化该类更方便时。</p></blockquote><p>他拥有以下参与者：</p><blockquote><ul><li>Prototype—声明一个克隆自身的接口。</li><li>ConcretePrototype—实现一个克隆自身的操作。</li><li>Client—让一个原型克隆自身从而创建一个新的对象。</li></ul></blockquote><p>所以一个典型的原型模式结构也就呼之欲出了：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/prototype-frame.png" alt="cover"></p><p>我们发现到现在为止的模式：工厂方法、抽象工厂，以及现在的原型模式。他们都有一个一样的效果：隐藏了具体的产品类，下面是原型模式的一些优点：</p><blockquote><ul><li>运行时增加和删除产品。客户只要注册原型实例就可以将一个新的产品类加入系统中。</li><li>改变值以指定新对象。我们现在拥有原型，而原型就是新类别的对象，我们将职责给实例化，就表现出了新的行为。比如刚才的 <code>GraphicTool</code> 类，他就可以创建无数种图形对象，是职责代理的一种应用。</li><li>改变结构以指定新对象。在电路设计中，我们存在子电路构造电路的情况，并且允许一次又一次重复使用一个特定的子电路，将子电路作为原型完成电路就是这一优点的体现。</li><li>减少子类的构造。工厂方法中还需要一个产品类平行的 <code>Creator</code> 类，原型模式则克隆一个原型，这一平行层次都需要了。更有甚者，在类作为一级类对象的语言中，类对象已经起到了原型的作用，所以获益较少，比如 Python 、 Smalltalk 等等 。</li><li>用类动态配置应用。一些运行时刻环境允许你动态将类装载到应用中。有一句很绕口的话是这么说的：一个希望创建动态载入类的实例的应用不能静态引入类的构造器，而应该由运行环境在载入时创建每个类的实例。( 多读几遍还是很好懂的 ) 在像 C++ 这样的语言中，原型模式是这种功能的关键。</li></ul><p>原型模式的主要缺陷是每一个原型的子类都必须有克隆操作，这可能是困难的。比方说这个类只要存在了，就难以新增克隆操作；或者当内部一些不支持拷贝或有循环引用的对象时，实现克隆也会困难。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在像 C++ 这样的语言中，类不是对象，所以原型模式特别有用，当实现原型时，要考虑：</p><blockquote><ul><li>使用一个原型管理器。当一个系统中原型数目不固定时，要保持一个可用原型的注册表。</li><li>实现克隆操作。原型模式最困难的部分在于正确实现克隆操作。</li><li>初始化克隆对象。当一部分人对克隆对象已经满意，另一部分人可能希望使用他们所选择的一些值来初始化该对象。一种是有专门该值更改的方法，一种是初始化方法，后者需要删除已有对象，而前者要逐一修改已有对象。</li></ul></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Prototype clone = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      clone = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Prototype instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ConcretePrototype1 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype2</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ConcretePrototype2 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Hashtable map = <span class="keyword">new</span> Hashtable&lt;String,Prototype&gt;();</span><br><span class="line">    map.put(<span class="string">"Prototype"</span>,<span class="keyword">new</span> Prototype());</span><br><span class="line">    map.put(<span class="string">"ConcretePrototype1"</span>,<span class="keyword">new</span> ConcretePrototype1());</span><br><span class="line">    map.put(<span class="string">"ConcretePrototype2"</span>,<span class="keyword">new</span> ConcretePrototype2());</span><br><span class="line">    ((Prototype) map.get(<span class="string">"Prototype"</span>)).clone().check();</span><br><span class="line">    ((Prototype) map.get(<span class="string">"ConcretePrototype1"</span>)).clone().check();</span><br><span class="line">    ((Prototype) map.get(<span class="string">"ConcretePrototype2"</span>)).clone().check();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 <code>Cloneable</code> 接口实现 <code>clone</code> 方法，使用一个 <code>map</code> 作为原型管理器，但不是最理想的状态，因为取出的内容是 <code>object</code> 所以需要从父类转换成子类，这是一个不规范的行为，但是如果全部的行为在父类都有了默认的定义，那就变得可以接受了。</p><p>这里的克隆操作是最简单的浅拷贝，如果存在引用类型还是要自己完成深拷贝。</p><blockquote><p><em>PS: 这里方法完全可以和工厂模式相互结合：</em></p><p>抽象工厂和工厂方法中，可以先保存产品原型的集合，然后返回产品对象，跳过从 <code>Factory</code> 或 <code>Creator</code> 创建产品；</p></blockquote><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><p>参考 <a href="https://github.com/faif/python-patterns/blob/master/creational/prototype.py" target="_blank" rel="noopener">python-patterns/creational/prototype.py</a> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span><span class="params">(object)</span>:</span></span><br><span class="line">  value = <span class="string">'default'</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">clone</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">    obj = self.__class__()</span><br><span class="line">    obj.__dict__.update(kwargs)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeDispatcher</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._objs=&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_objects</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._objs</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_obj</span><span class="params">(self, name, obj)</span>:</span></span><br><span class="line">    self._objs[name]=obj</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unregister_obj</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="keyword">del</span> self._objs[name]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  prototypeDispatcher = PrototypeDispatcher()</span><br><span class="line">  prototype = Prototype()</span><br><span class="line">  a = prototype.clone(value=<span class="string">'a'</span>)</span><br><span class="line">  b = prototype.clone(value=<span class="string">'b'</span>)</span><br><span class="line">  prototypeDispatcher.register_obj(<span class="string">'objDefault'</span>, prototype)</span><br><span class="line">  prototypeDispatcher.register_obj(<span class="string">'objA'</span>, a)</span><br><span class="line">  prototypeDispatcher.register_obj(<span class="string">'objB'</span>, b)</span><br><span class="line">  print([&#123;n:p.value&#125; <span class="keyword">for</span> n, p <span class="keyword">in</span> prototypeDispatcher.get_objects().items()])</span><br></pre></td></tr></table></figure><blockquote><ul><li>在 python 的实现中使用一个 <code>PrototypeDispatcher</code> 作为原型管理器；</li><li>克隆操作上创建新的实例，开辟了新的内存空间，如果有其他引用类型应该会引入 <code>copy</code> 包协同工作；</li><li>初始化对于该例，可以选择删除全部已有实例或者逐个更改，这值得斟酌。</li></ul></blockquote><p>原型模式一句话概括就是运行时复制原型实例，抽象工厂要求我们按部就班创建工厂然后创建产品 (工厂方法是搭建一个和产品平行层次的 <code>Creator</code> ，所以不加入讨论) ，原型模式直接用一个产品作为原型，然后复制生产，前者在大方向上指明道路，后者在某一条分支上另辟蹊径，这些思想非常有趣。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探抽象工厂模式</title>
      <link href="/design-pattern/2018-06-23-abstract-factory/"/>
      <url>/design-pattern/2018-06-23-abstract-factory/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/abstract-factory" target="_blank" rel="noopener">koonchen/design-patterns/abstract-factory</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，且无需指定它们具体的类。</p></blockquote><p>假设现在有一个应用界面，比如一个视频应用。其中包含了许多视觉模块，比如视频栏、评论栏。这些不同的模块拥有各式的外观，比如按钮、滚动条等。因此我们如果对某一个外观进行编码，在复用的时候可能存在难以改变视感风格的问题。</p><p>因此可以定义一个抽象类 <code>WidgetFactory</code> ，通过泛化的子类 <code>MotifWidgeFactory</code> 或者 <code>PMWidgeFactory</code> 可以创建每一类视感风格的窗口组件操作比如 <code>CreateScrollBar</code> 等 ，这样我们在获取某一个具体的窗口组件时，对工厂子类和具体实现之间只有依赖关系，而客户仅与抽象类（工厂）进行交互，而不需要使用特定的具体类的接口。</p><p>什么时候适用这种模式呢：</p><blockquote><ul><li>一个系统要独立于它的产品的创建、组合和表示时；</li><li>一个系统要用多个产品系列中的一个来配置时；</li><li>当你要强调一系列相关的产品对象的设计以便进行联合适用的时候；</li><li>当你提供一个产品类库，而只想显示它们的接口而不是实现的时候。</li></ul></blockquote><p>他拥有以下参与者：</p><blockquote><ul><li>AbstractFactory—创建抽象产品对象的操作接口。</li><li>ConcreteFactory—实现创建具体产品对象的操作。</li><li>AbstractProduct—为一类产品对象声明的接口。</li><li>ConcreteProduct—实现 AbstractProduct 接口，具体创建的产品对象。</li><li>Client —仅使用 AbstractFactory 和 AbstractProduct 类声明的接口。</li></ul></blockquote><p>所以抽象工厂模式的三个优点和一个缺点：</p><ol><li>有效分离了具体的类，它将客户与类的实现进行了分离，客户仅仅使用接口操纵实例，而具体实现不会再客户代码中。</li><li>配置简单化，一个具体工厂的实现在应用中仅出现了一次，就是它初始化的时候。这使得改变一个实现很容易。</li><li>有利于产品一致性，当一个系列中的产品对象被设计成一起工作时，一个类中只有一个对象被实现，好比只需要某一个形式的按钮配上某一个形式的主题，而不会出现特定情况下的两种按钮，这在抽象工厂容易实现。</li><li>难以支持新种类的产品，或者说是新产品的实现，因为一旦接口上进行了改变，子类也要进行改变。</li></ol><p>他与工厂方法有什么区别呢？</p><blockquote><p>初看起来他们很像，他们的区别在于：</p><p>首先工厂方法，工厂被实现在方法中，准确地讲是实现在 Creater 中，只有一个 Creater 所以他创建的内容 Product 是一个类别的，而后在生产者子类的方法中实例化不同的产品。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/factory-method.png" alt="cover"></p><p>抽象工厂，工厂被实现在类中，从创建不同的工厂类就已经决定了未来我们将实例化不同的一系列产品，我们有一个很明确的目的，比如说中国货或者美国货，他们就可以代表是两个系列。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/abstract-factory.jpg" alt="cover"></p><p>在抽象工厂中，<strong>最通常的方法是为每一个产品定义一个工厂方法</strong>，从上图我们可以发现，抽象工厂仅仅是多个工厂方法的结合。从工厂方法的平行层次我们能更直观发现这一点。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/horizontal-factory-method.jpg" alt="cover"></p><p><strong>所以最重要的区别是，抽象工厂目的是生产不同系列的产品，而工厂方法目的是生产相同系列的产品。</strong></p><p>也因此，虽然工厂方法是抽象工厂的一部分，但是工厂方法中没有抽象工厂的缺陷。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>当有多个可能的产品系列，具体工厂也可以使用 Prototype 模式实现，这里暂且不讨论。</p></blockquote><p><em>关于抽象工厂的缺陷如何处理？</em></p><p>前面说道抽象工厂对于扩展有着一定缺陷，如果我们想增加一类新的产品，需要改变 <code>AbstractFactory</code> 来创建新的方法，然后在子类实现上实现这个方法用以创建新的产品。一个更加灵活但不太安全的设计是给创建对象的方法一个参数，该参数指定创建对象的种类，所有的产品将返回相同的接口，客户也就不能区分一个特定的产品类别，可读性会变差，但是这是折衷可行的方法。</p><h3 id="基础抽象工厂实现"><a href="#基础抽象工厂实现" class="headerlink" title="基础抽象工厂实现"></a>基础抽象工厂实现</h3><h4 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">productAOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">productBOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="function">AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">implements</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productAOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ProductA1 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">implements</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productAOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ProductA2 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">implements</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productBOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ProductB1 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">implements</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productBOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ProductB2 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Factory factory = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">    factory.createProductA().productAOperation();</span><br><span class="line">    factory.createProductB().productBOperation();</span><br><span class="line">    factory = <span class="keyword">new</span> ConcreteFactory2();</span><br><span class="line">    factory.createProductA().productAOperation();</span><br><span class="line">    factory.createProductB().productBOperation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据书上对于抽象工厂的改进，我们下一步需要对工厂中创建实例的方法加上参数，统一成一个方法，所有的创建都通过这里，这样一来我们再添加新的产品也就无需改进接口了，此外还需要统一产品接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductUnify</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">productOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryUnify</span> </span>&#123;</span><br><span class="line">  <span class="function">ProductUnify <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductUnifyA1</span> <span class="keyword">implements</span> <span class="title">ProductUnify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ProductUnifyA1 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductUnifyA2</span> <span class="keyword">implements</span> <span class="title">ProductUnify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ProductUnifyA2 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductUnifyB1</span> <span class="keyword">implements</span> <span class="title">ProductUnify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ProductUnifyB1 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductUnifyB2</span> <span class="keyword">implements</span> <span class="title">ProductUnify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ProductUnifyB2 instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryUnifyA1</span> <span class="keyword">implements</span> <span class="title">FactoryUnify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProductUnify <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProductUnifyA1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryUnifyA2</span> <span class="keyword">implements</span> <span class="title">FactoryUnify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProductUnify <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProductUnifyA2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryUnifyB1</span> <span class="keyword">implements</span> <span class="title">FactoryUnify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProductUnify <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProductUnifyB1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryUnifyB2</span> <span class="keyword">implements</span> <span class="title">FactoryUnify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProductUnify <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProductUnifyB2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryUnify</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FactoryUnify factory = <span class="keyword">new</span> ConcreteFactoryUnifyA1();</span><br><span class="line">    factory.make().productOperation();</span><br><span class="line">    factory = <span class="keyword">new</span> ConcreteFactoryUnifyA2();</span><br><span class="line">    factory.make().productOperation();</span><br><span class="line">    factory = <span class="keyword">new</span> ConcreteFactoryUnifyB1();</span><br><span class="line">    factory.make().productOperation();</span><br><span class="line">    factory = <span class="keyword">new</span> ConcreteFactoryUnifyB2();</span><br><span class="line">    factory.make().productOperation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以发现，现在的抽象工厂和工厂方法非常非常像，代码逻辑完全相同，含义也近似相同，但注意目的是不一样的，再次强调，前者的目的是创造多个系列，而后者的目的是创造一个系列！</p></blockquote><p>个人认为，如果项目庞大，产品系列很多，那么不如用修改麻烦的方法（前者），因为这样创建在内存的工厂会少；相对的，如果系列不大，用工厂方法实现的抽象工厂更加灵活。我会选择前者。</p><h4 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productAOperation</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productBOperation</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createProductA</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createProductB</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span><span class="params">(AbstractProductA)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productAOperation</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'ProductA1 instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span><span class="params">(AbstractProductA)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productAOperation</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'ProductA2 instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span><span class="params">(AbstractProductB)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productBOperation</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'ProductB1 instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span><span class="params">(AbstractProductB)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productBOperation</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'ProductB2 instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span><span class="params">(Factory)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createProductA</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ProductA1()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createProductB</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ProductB1()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span><span class="params">(Factory)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createProductA</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ProductA2()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createProductB</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ProductB2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  factory = ConcreteFactory1()</span><br><span class="line">  factory.createProductA().productAOperation()</span><br><span class="line">  factory.createProductB().productBOperation()</span><br><span class="line">  factory = ConcreteFactory2()</span><br><span class="line">  factory.createProductA().productAOperation()</span><br><span class="line">  factory.createProductB().productBOperation()</span><br></pre></td></tr></table></figure><p>如上 java 改进的 python 代码和之前实现的 <a href="http://koon.cool/factory-method.html#python-%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">工厂方法实现</a> 也是一回事情，这里的代码就省略了。</p><hr><h3 id="python-其他实现"><a href="#python-其他实现" class="headerlink" title="python 其他实现"></a>python 其他实现</h3><p>python 真的只能这样完成抽象工厂吗？是否可以完成抽象工厂的同时满足添加产品的任务？答案是可以的。</p><p>我从 <a href="https://github.com/faif/python-patterns/blob/master/creational/abstract_factory.py" target="_blank" rel="noopener">python-patterns/creational/abstract_factory.py</a> 找到了一个例子，下面的代码实现了一个宠物店。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetShop</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, animal_factory = None)</span>:</span></span><br><span class="line">    self.pet_factory = animal_factory</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show_pet</span><span class="params">(self)</span>:</span></span><br><span class="line">    pet = self.pet_factory()</span><br><span class="line">    pet.show()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Dog instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Cat instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  cat_shop = PetShop(Cat)</span><br><span class="line">  cat_shop.show_pet()</span><br><span class="line">  dog_shop = PetShop(Dog)</span><br><span class="line">  dog_shop.show_pet()</span><br></pre></td></tr></table></figure><p>在这里 <code>Cat</code> 和 <code>Dog</code> 是抽象工厂的两个实现，当增加宠物类别，也不会出现更改已有特定子类的事情。</p><p>和上文提及的抽象工厂包含的缺陷及解决一样，这样处理和工厂方法本质上没有区别，将多个系列的产品混杂在一起，是一种灵活但耗费内存的处理方法。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象工厂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探工厂方法模式</title>
      <link href="/design-pattern/2018-06-11-factory-method/"/>
      <url>/design-pattern/2018-06-11-factory-method/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/factory-method" target="_blank" rel="noopener">koonchen/design-patterns/factory-method</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>定义一个创建对象的接口，让子类决定实例化哪一个类。让一个类的实例化延迟到其子类。</p></blockquote><p>比如我们想在有一个应用，它可以显示多个文档。在这个应用框架下，我们创建了两个抽象类，分别是 <code>Application</code> 和 <code>Document</code> ， <code>Application</code> 类负责管理 <code>Document</code> 类，用户从菜单的选择或者 open 来创建相应的文档，也就是说， <code>Application</code> 类不能预测哪一个 <code>Document</code> 将会被创建。</p><p>Factory Method 给我们的解决方式是：由 <code>Application</code> 的子类来重定义  <code>CreateDocument</code> 方法，来返回相应的 <code>Document</code> ，一旦一个需要的 <code>Application</code> 子类被创建了，那么它就能创建相关的文档了。</p><p>用 <code>MyApplication</code> 和 <code>MyDocument</code> 来 <strong>泛化</strong> <code>Application</code> 和 <code>Document</code> ，而原本 <code>Application</code> 和 <code>Document</code> 之间的 <strong>聚合</strong> 变成了 <strong>依赖</strong> 。</p><p>什么情况才使用工厂方法模式：</p><blockquote><ul><li>一个类不知道它所创建对象的具体类的时候；</li><li>一个类希望由其子类来指定创建对象的时候；</li><li>当类所创建对象的职责被委托给多个帮助子类中的一个，并且希望将哪一个子类是代理者这一信息局部化的时候。</li></ul></blockquote><p>因此定义以下参与者：</p><blockquote><ul><li>Product ( Document ) — 定义工厂方法所创建对象的接口。</li><li>ConcreteProduct ( MyDocument ) — 实现 Product 接口。</li><li>Creator ( Application ) — 声明工厂方法，创建一个 Product 对象 ( 或省略 ) 并返回。</li><li>ConcreteCreator ( MyApplication ) — 重定义工厂方法，创建一个 ConcreateProduct 对象并返回。</li></ul></blockquote><p>工厂方法的一个 <strong>潜在缺点</strong> 在于用户可能仅仅为了创建一个特定的 ConcreteProduct 对象，就不得不从 Creator 开始创建，再创建相应的子类。但是当 Creator 的子类不是必需品时，我们还要考虑类的演化问题；或者就照着这繁复的公式完成。</p><p>工厂方法模式有另外两种效果：</p><blockquote><p>一、为子类提供挂钩 ( hook )</p><p>所谓 hook ，指空实现或默认实现。用工厂方法在一个类的内部创建对象通常比直接创建对象更加灵活。比如我在之前的 <code>Document</code> 下再创建一个方法 <code>CreateFileDialog</code> ，这个方法可以创建一个文件对话框，那么对于 <code>MyDocument</code> 就能覆盖该方法，创建自己的文件对话框。</p><p>二、连接平行的类层次</p><p>假设现在有一个图形界面，我们可以对图形界面的文字操作，也能对线条进行操作，能托拉拽的内容非常多，但每个对象的操作又各不相同，我们就能通过一个 <code>Figure</code> 接口控制图形，用 <code>Manipulator</code> 接口定义操作，而只有 <code>Figure</code> 才能创建相应的 <code>Manipulator</code> ，一个平行的类层次就出现了。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>工厂方法的实现上，对于 Creator 是否需要给出默认的工厂方法实现给出了讨论，推荐的情况是 <strong>不给出具体实现</strong> ，因为在这避免了不可预见类的问题；关于参数，需要唯一标识，可以是 id 之类的东西 ( Unidraw 框架对于每一个类拥有一个类标识符 )，保证不重名用名字当然没有问题；不同的语言将会存在不同的变化和警告，这是当然的。</p><h3 id="基础工厂方法实现"><a href="#基础工厂方法实现" class="headerlink" title="基础工厂方法实现"></a>基础工厂方法实现</h3><h4 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">productOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line">  <span class="function">Product <span class="title">factoryMethod</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">creatorOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Product instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator</span> <span class="keyword">implements</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatorOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Creator instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethod</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Creator creator = <span class="keyword">new</span> ConcreteCreator();</span><br><span class="line">    Product product = creator.factoryMethod();</span><br><span class="line">    creator.creatorOperation();</span><br><span class="line">    product.productOperation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现平行层次的类也就和上面一样的完成，这里不再赘述，值得注意的是，上面的代码显示出了该方法的问题，就是上文提及的：我们的目标如果仅仅只是创建一个 <code>ConcreteProduct</code> 类的实例，但是我们需要从 <code>Prodct</code> 这个接口开始，过于繁复。</p><p>现在我们的目标是跳过 <code>ConcreteCreator</code> 的创建，直接创建 <code>ConcreteProduct</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsProduct</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">productOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericsCreator</span> </span>&#123;</span><br><span class="line">  <span class="function">GenericsProduct <span class="title">factoryMethod</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">creatorOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardCreator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericsProduct</span>&gt; <span class="keyword">implements</span> <span class="title">GenericsCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StandardCreator</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> GenericsProduct <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T temp = clazz.newInstance();</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatorOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"GenericsCreator instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericsConcreteProduct</span> <span class="keyword">extends</span> <span class="title">GenericsProduct</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"GenericsProduct instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsFactoryMethod</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GenericsCreator creator = <span class="keyword">new</span> StandardCreator(GenericsConcreteProduct.class);</span><br><span class="line">    GenericsProduct product = creator.factoryMethod();</span><br><span class="line">    creator.creatorOperation();</span><br><span class="line">    product.productOperation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 java 中没有 c++ 的 <code>template</code> ，所以这里使用反射和泛型 ( 虽然个人认为这个都不能叫泛型， jvm 的类型擦除历史包袱沉重，暂且不讨论 ) 完成 ( 感谢这篇文章：<a href="https://www.artima.com/weblogs/viewpost.jsp?thread=208860" target="_blank" rel="noopener">Reflecting generics</a> )。</p><h4 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h4><p>python 因为多重继承的存在，其实并不需要接口的存在，这里使用 abc 模块来实现接口的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productOperation</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">creatorOperaton</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">factoryMethod</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span><span class="params">(Product)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productOperation</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Product instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator</span><span class="params">(Creator)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">creatorOperaton</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Creator instance has been created'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">factoryMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ConcreteProduct();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  creator = ConcreteCreator()</span><br><span class="line">  product = creator.factoryMethod()</span><br><span class="line">  creator.creatorOperaton()</span><br><span class="line">  product.productOperation()</span><br></pre></td></tr></table></figure><p>那么在 python 中如何省略 <code>ConcreteCreator</code> 的创建呢？</p><p>注意泛型是一种类型声明的方法，属于多态的概念， python 没有泛型，跟强弱、静态动态没有直接关联。</p><blockquote><p>PS: 静态语言利用多态机制 ( 包括泛型 ) ，实现动态语言的便利，同时避免动态语言的性能和安全问题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productOperation</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span><span class="params">(object)</span>:</span></span><br><span class="line">  __clazz = <span class="keyword">None</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">    self.__clazz = name</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">creatorOperaton</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Creator instance has been created'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">factoryMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__clazz()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span><span class="params">(Product)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">productOperation</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Product instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  creator = Creator(ConcreteProduct)</span><br><span class="line">  product = creator.factoryMethod().productOperation()</span><br></pre></td></tr></table></figure><hr><p>简单来说，工厂方法模式需要按部就班，可以认为是对构造函数的补充，当我们的实际类多样，而构造类不够明确表达时，这是一个好办法。</p><h3 id="python-的其他实现"><a href="#python-的其他实现" class="headerlink" title="python 的其他实现"></a>python 的其他实现</h3><p>从上面的内容我们得知 python 不需要接口，并且动态实例化非常的简单，那么如何确切在 python 中使用工厂方法呢？</p><p>我从 <a href="https://github.com/faif/python-patterns/blob/master/creational/factory_method.py" target="_blank" rel="noopener">python-patterns/creational/factory_method.py</a> 找到了一个例子，下面的代码实现了一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseGetter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.trans = dict(dog=<span class="string">"狗"</span>, cat=<span class="string">"猫"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.trans.get(item, str(item))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnglishGetter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_localizer</span><span class="params">(language=<span class="string">"English"</span>)</span>:</span></span><br><span class="line">  languages = dict(English=EnglishGetter, Chinese=ChineseGetter)</span><br><span class="line">  <span class="keyword">return</span> languages[language]()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  e, c = get_localizer(), get_localizer(language=<span class="string">"Chinese"</span>)</span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">"dog parrot cat bear"</span>.split():</span><br><span class="line">    print(e.get(item), c.get(item))</span><br></pre></td></tr></table></figure><p><code>get_localizer</code> 方法是工厂方法，它将返回的是我们将创建的语言实例，这里以英语为例，将其翻译成中文，其中 <code>dict.get</code> 方法的第二项为默认值。</p><p>在 django 框架中，也能看到工厂方法模式的身影—— <a href="http://django.wikispaces.asu.edu/*NEW*+Django+Design+Patterns" target="_blank" rel="noopener">NEW Django Design Patterns</a> ；之后的抽象工厂模式也是工厂方法模式的一个子集，也能看出这一模式的重要性。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔术方法</title>
      <link href="/technology/2018-06-07-magic-methods/"/>
      <url>/technology/2018-06-07-magic-methods/</url>
      
        <content type="html"><![CDATA[<blockquote><p>资料柜：<br><a href="https://rszalski.github.io/magicmethods/#pickling" target="_blank" rel="noopener">A Guide to Python’s Magic Methods</a></p></blockquote><p>魔术方法 ( magic methods ) 是 python 的一种语法，允许在类的定义中使用，一般格式是 <code>__xx__</code> ，它能对类进行功能上的额外增加，同时又非常方便，并且我们不得不去研究它。</p><p>为什么说不得不研究？比如我们知道使用 <code>str()</code> 可以将一个对象转换成 string 输出，那么 <code>repr()</code> 也能将一个对象转换成 string 输出，它们的区别是什么？前者调用了 <code>__str__</code> 后者调用了 <code>__repr__</code> ，它们的魔术方法不同…</p><p>魔术方法怎么用呢？比如说我们要定义一个人 ，同时要有姓名、年龄，还要允许根据姓名和年龄进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name + <span class="string">":"</span> + str(self.age)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name &lt; other.name \</span><br><span class="line">      <span class="keyword">if</span> self.name != other.name \</span><br><span class="line">      <span class="keyword">else</span> self.age &lt; other.age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"\t"</span>.join(</span><br><span class="line">  [str(item)<span class="keyword">for</span> item <span class="keyword">in</span> sorted([People(<span class="string">"abc"</span>, <span class="number">18</span>),</span><br><span class="line">                                People(<span class="string">"qwd"</span>, <span class="number">19</span>),</span><br><span class="line">                                People(<span class="string">"wds"</span>, <span class="number">12</span>),</span><br><span class="line">                                People(<span class="string">"awd"</span>, <span class="number">17</span>)])])</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里用了三个魔术方法： <code>__init__</code> 初始化， <code>__str__</code> 字符串格式， <code>__lt__</code> 小于的含义。</p><p>或者说一个非常理性的需求，想对默认的 dict 进行修改，让它可以完成 <code>dict[1][1] = x</code> 这样的操作，当然默认是不行的，我们只能依靠 <code>dict.update({&#39;1&#39;:{&#39;1&#39;:x}})</code> 完成，非常绕口。想简便完成这个任务，首先我们无法确定 dict 中是否存在某个值，可以通过 <code>__getitem__</code> 函数重新定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">(dict)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">      temp = MyDict()</span><br><span class="line">      self[item]=temp</span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    <span class="keyword">return</span> self[item]</span><br><span class="line"></span><br><span class="line">test = MyDict()</span><br><span class="line">test[<span class="number">0</span>] = <span class="string">'test'</span></span><br><span class="line">test[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">'test1'</span></span><br><span class="line">test[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>] = <span class="string">'test2'</span></span><br><span class="line">print(test)</span><br></pre></td></tr></table></figure><p>所以魔术方法给了我们非常多的便利。</p><h2 id="用于创建删除实例"><a href="#用于创建删除实例" class="headerlink" title="用于创建删除实例"></a>用于创建删除实例</h2><p>当一个实例被创建，最先被使用的方法是 <code>__new__(cls, *args, **kwargs)</code> ，它的第一个参数是类，后面的可变参数将传递给 <code>__init__</code> 使用，所以其追主要的目的是在 <code>__init__</code> 前做准备，而值得一提的是，这一切都是由元类的 <code>__call__</code> 控制的。</p><p>接下来是实例的初始化方法，使用的方法是 <code>__init__(self)</code> ，它的第一个参数是实例自身。</p><p>当对象的使命结束，在删除时调用的方法是 <code>__del__(self)</code> ，它相当于程序的析构器，但是它不能在解释器退出以后执行，所以它只在特定的环境下有作用，不是一个优美的编程习惯，对于 cpython 还是仰仗 gc 模块。</p><h2 id="比较的魔术方法"><a href="#比较的魔术方法" class="headerlink" title="比较的魔术方法"></a>比较的魔术方法</h2><p>在 python 语言中我们可能需要这样来进行等于的判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> instance.equals(other_instance) : <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这样的操作可能会让产生困扰，于是有了 <code>__eq__</code> 方法，当实现其之后，可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> instance == other_instance : <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这是比较的魔术方法的一个小例子。</p><p>最完善的比较是 <code>__cmp__</code> 它实现了所有的比较符号，包括了  <code>&lt;,==,&gt;,!=,etc.</code> ，但是它需要对每一个可能进行定义，比如 <code>self &lt; other</code> 返回0， <code>self = other</code> 返回负数， <code>self &gt; other</code> 返回正数。所以这个方法是让你保持所有状态明白的一个好方法。</p><p>下面列举其他比较用魔术方法。</p><div class="table-container"><table><thead><tr><th>名称</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>__eq__</code></td><td>self, other</td><td>等号的行为</td></tr><tr><td><code>__ne__</code></td><td>self, other</td><td>不等号的行为</td></tr><tr><td><code>__lt__</code></td><td>self, other</td><td>小于号的行为</td></tr><tr><td><code>__gt__</code></td><td>self, other</td><td>大于等于号的行为</td></tr></tbody></table></div><p>这里值得一提的是 functools 模块，该模块大大降低了开发成本，其中的 <code>functool.partial</code> 通过包装类的手法，允许我们重新定义函数签名，什么意思呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlunquote = functools.partial(urlunquote, encoding=<span class="string">'latin1'</span>)</span><br><span class="line"><span class="comment"># 上面定义以后，下面的调用等价</span></span><br><span class="line"><span class="comment"># urlunquote(args, *kargs)</span></span><br><span class="line"><span class="comment"># urlunquote(args, *kargs, encoding='latin1')</span></span><br></pre></td></tr></table></figure><p>再比如说 <code>functool.update_wrapper</code> ，该函数可以补充封装函数的 <code>__name__、__module__、__doc__和 __dict__</code> 等信息，便于 debug。</p><p>而 <code>functools.wraps</code> 可以作为 <code>functool.update_wrapper</code> 的简易写法，以装饰器的方式使用。</p><p>此外还有 <code>reduce</code> 作为兼容 py3 ， <code>cmp_to_key</code> 小于负数大于整数等于为0， <code>total_ordering</code> 在实现 <code>__eq__</code>  和其他一个比较的前提下，自动实现其他比较的函数。</p><h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><p>顾名思义，一个操作位的一元操作，好比绝对值等。</p><div class="table-container"><table><thead><tr><th>名称</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>__neg__</code></td><td>self</td><td>-</td></tr><tr><td><code>__pos__</code></td><td>self</td><td>+</td></tr><tr><td><code>__abs__</code></td><td>self</td><td>abs()</td></tr><tr><td><code>__invert__</code></td><td>self</td><td>~</td></tr><tr><td><code>__complex__</code></td><td>self</td><td>转换成复数</td></tr><tr><td><code>__int__</code></td><td>self</td><td>转换成整型</td></tr><tr><td><code>__long__</code></td><td>self</td><td>转换成长整型</td></tr><tr><td><code>__float__</code></td><td>self</td><td>转换成浮点型</td></tr><tr><td><code>__oct__</code></td><td>self</td><td>转换成八进制</td></tr><tr><td><code>__hex__</code></td><td>self</td><td>转换成十六进制</td></tr><tr><td><code>__round__</code></td><td>self, n</td><td>四舍五入</td></tr><tr><td><code>__floor__</code></td><td>self</td><td>向下取整</td></tr><tr><td><code>__ceil__</code></td><td>self</td><td>向上取整</td></tr><tr><td><code>__trunc__</code></td><td>self</td><td>距离 0 最近的整数</td></tr><tr><td><code>__coerce__</code></td><td>self</td><td>将一个列表转换成相同类型</td></tr></tbody></table></div><h2 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h2><p>好比加法。</p><div class="table-container"><table><thead><tr><th>名称</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>__add__</code></td><td>self, other</td><td>加法</td></tr><tr><td><code>__sub__</code></td><td>self, other</td><td>减法</td></tr><tr><td><code>__mul__</code></td><td>self, other</td><td>乘法</td></tr><tr><td><code>__floordiv__</code></td><td>self, other</td><td>整除</td></tr><tr><td><code>__div__</code></td><td>self, other</td><td>除法</td></tr><tr><td><code>__truediv__</code></td><td>self, other</td><td>真除，但结果和除没有区别</td></tr><tr><td><code>__mod__</code></td><td>self, other</td><td>取模</td></tr><tr><td><code>__divmod__</code></td><td>self, other</td><td>如果两个参数 a , b 都是整数，那么会采用整数除法，结果相当于 <code>(a//b, a % b)</code> 。如果 a 或 b 是浮点数，相当于 <code>(math.floor(a/b), a%b)</code> 。</td></tr><tr><td><code>__pow__</code></td><td>self, other</td><td>指数 <code>**</code></td></tr><tr><td><code>__lshift__</code></td><td>self, other</td><td>左移</td></tr><tr><td><code>__rshift__</code></td><td>self, other</td><td>右移</td></tr><tr><td><code>__and__</code></td><td>self, other</td><td>按位 <code>&amp;</code></td></tr><tr><td><code>__or__</code></td><td>self, other</td><td>按位 `</td><td>`</td></tr><tr><td><code>__xor__</code></td><td>self, other</td><td>按位 <code>^</code></td></tr></tbody></table></div><blockquote><p>省略反运算和增量赋值，没有区别且个人觉得没有太大意义，可以在使用时再查看。</p></blockquote><h2 id="类的表示"><a href="#类的表示" class="headerlink" title="类的表示"></a>类的表示</h2><p>什么叫类的表示？类在程序中的输出以及行为。比如输出 string，下面的方法在特定情况下一般只修改极个别，并且可以用 <code>obj.method()</code> 调用。其中的 <code>__sizeof__</code> 使用的是 <code>getsizeof()</code> 。</p><div class="table-container"><table><thead><tr><th>名称</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>__str__</code></td><td>self</td><td>人读的输出</td></tr><tr><td><code>__repr__</code></td><td>self</td><td>机器读的输出</td></tr><tr><td><code>__unicode__</code></td><td>self</td><td>unicode 字符串</td></tr><tr><td><code>__hash__</code></td><td>self</td><td>hash 值</td></tr><tr><td><code>__nonzero__</code></td><td>self</td><td>将类转换成布尔值</td></tr><tr><td><code>__dir__</code></td><td>self</td><td>属性列表</td></tr><tr><td><code>__format__</code></td><td>self</td><td>格式化输出</td></tr><tr><td><code>__len__</code></td><td>self</td><td>输出长度</td></tr><tr><td><code>__sizeof__</code></td><td>self</td><td>输出内存</td></tr></tbody></table></div><h2 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h2><div class="table-container"><table><thead><tr><th>名称</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>__getattr__</code></td><td>self, name</td><td>获取属性，必须存在</td></tr><tr><td><code>__setattr__</code></td><td>self, name</td><td>设置属性，无论是否存在</td></tr><tr><td><code>__delattr__</code></td><td>self, name</td><td>删除属性</td></tr><tr><td><code>__getattribute__</code></td><td>self, name</td><td>获取属性，无论是否存在</td></tr></tbody></table></div><blockquote><p><em>PS: 在 <code>setattr</code> 中可能出现无限循环</em></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name. value)</span>:</span></span><br><span class="line">  self.name = value</span><br><span class="line">  <span class="comment"># 因为每次属性幅值都要调用 __setattr__()，所以这里的实现会导致递归</span></span><br><span class="line">  <span class="comment"># 这里的调用实际上是 self.__setattr('name', value)。因为这个方法一直</span></span><br><span class="line">  <span class="comment"># 在调用自己，因此递归将持续进行，直到程序崩溃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">  self.__dict__[name] = value </span><br><span class="line">  <span class="comment"># 使用 __dict__ 进行赋值</span></span><br></pre></td></tr></table></figure><h2 id="容器中的魔术方法"><a href="#容器中的魔术方法" class="headerlink" title="容器中的魔术方法"></a>容器中的魔术方法</h2><div class="table-container"><table><thead><tr><th>名称</th><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>__len__</code></td><td>self</td><td>返回容器长度</td></tr><tr><td><code>__getitem__</code></td><td>self, key</td><td>返回某一项，必须存在</td></tr><tr><td><code>__setitem__</code></td><td>self, key</td><td>设置某一项，它将先使用 <code>__getitem__</code></td></tr><tr><td><code>__iter__</code></td><td>self, key</td><td>返回迭代器</td></tr><tr><td><code>__reversed__</code></td><td>self</td><td>反转</td></tr><tr><td><code>__contains__</code></td><td>self, item</td><td>是否存在某一项</td></tr><tr><td><code>__missing__</code></td><td>self ,key</td><td>不存在键时的行为</td></tr></tbody></table></div><hr><p>到这里，基本该使用的魔术方法已经列举了，其实还剩下很多，甚至无穷无尽，每一个包的创建，我们也就能创建一个又一个魔术方法，所以学习无止境，等待我们的探索。</p><blockquote><p>continue…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 的设计和问题</title>
      <link href="/technology/2018-06-05-python-why/"/>
      <url>/technology/2018-06-05-python-why/</url>
      
        <content type="html"><![CDATA[<p>python 语言的使用中，不得不说非常方便，但是对于从 java 系转 python 开发的学习者，还是存在多处难以理解的地方，这里我们讨论一下 python 的设计问题。</p><blockquote><p>资料柜：<br><a href="https://docs.python.org/3.8/faq/design.html" target="_blank" rel="noopener">Design and History FAQ</a></p></blockquote><h2 id="为什么-python-使用缩进来分组？"><a href="#为什么-python-使用缩进来分组？" class="headerlink" title="为什么 python 使用缩进来分组？"></a>为什么 python 使用缩进来分组？</h2><p>设计者 ( Guido van Rossum ) 认为使用缩进来分组会很优雅这是一点，也不会出现下面 c++ 代码的歧义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= y)</span><br><span class="line">  x++;</span><br><span class="line">  y--;</span><br><span class="line">z++;</span><br></pre></td></tr></table></figure><p>条件如果是真，那么只会执行 <code>x++;</code> ，但是缩进让我们觉得，下面一行也会执行，让机器和人的感受相同这是第二点，最后统一了编码风格。</p><h2 id="为什么浮点运算很奇怪？"><a href="#为什么浮点运算很奇怪？" class="headerlink" title="为什么浮点运算很奇怪？"></a>为什么浮点运算很奇怪？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.2</span> - <span class="number">1.0</span></span><br><span class="line"><span class="number">0.19999999999999996</span></span><br></pre></td></tr></table></figure><p>这是因为 python 中的 float 即 c 的 double 存储格式，它的浮点运算和 c 和 java 是十分相似的，都依赖于处理器的硬件。它可以精确到小数点后17位。</p><p>比如 <code>1.2</code> 这个十进制数在机器中的二进制表示是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0011001100110011001100110011001100110011001100110011</span><br></pre></td></tr></table></figure><p>它所对应的十进制就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1999999999999999555910790149937383830547332763671875</span><br></pre></td></tr></table></figure><p>对于必须的运算 ( 超过17位的精度 ) 可以采用 <code>decimal</code> 模块进行处理， decimal 默认精度到28位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line">a = Decimal(repr(<span class="number">1.2</span>))</span><br><span class="line">b = Decimal(repr(<span class="number">1.0</span>))</span><br><span class="line">print(a - b)</span><br><span class="line"><span class="comment"># 0.2</span></span><br></pre></td></tr></table></figure><p>当然也可以用 <code>round()</code> 四舍五入凑合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line">a = <span class="number">1.2</span></span><br><span class="line">b = <span class="number">1.0</span></span><br><span class="line">print(round(a - b , <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 0.2</span></span><br></pre></td></tr></table></figure><h2 id="为什么在方法中明确使用-self-参数？"><a href="#为什么在方法中明确使用-self-参数？" class="headerlink" title="为什么在方法中明确使用 self 参数？"></a>为什么在方法中明确使用 self 参数？</h2><p>我现在所能理解的原因还停留在 python 没有 <strong>声明</strong> 这一功能，使用 self 来保存实例的变量更加方便。</p><p>事实上这也是主要原因之二 （方便保存，区分实例变量和局部变量) ，别的有一点在于在派生类中覆盖基类的方法以及调用。</p><h2 id="为什么有的方法用-“-”-调用，有的用-“-”-？"><a href="#为什么有的方法用-“-”-调用，有的用-“-”-？" class="headerlink" title="为什么有的方法用 “.” 调用，有的用 “()” ？"></a>为什么有的方法用 “.” 调用，有的用 “()” ？</h2><p>比如 <code>list.index()</code> 使用 <code>.</code> 来调用，有的比如 <code>len(list)</code>  使用 <code>()</code> 来调用。一个对象在前面，一个对象在括号里。</p><p>主要历史的原因导致，函数 <code>()</code> 对于一组类型通用的操作，比如 <code>map()</code> 和 <code>zip()</code> ；而例如 <code>len()</code> 、 <code>max()</code> 等内置的方法实际上它们已经存在了，所以无法再进行更改，就是这个理由…</p><h2 id="为什么-python-没有-switch-case-？"><a href="#为什么-python-没有-switch-case-？" class="headerlink" title="为什么 python 没有 switch case ？"></a>为什么 python 没有 switch case ？</h2><p>我们不讨论 <code>if else</code> 的实现，对于大量可能性中选择，可以创建一个字典，或者使用 <code>getattr()</code> 检索方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit_a</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    method_name = <span class="string">'visit_'</span> + str(value)</span><br><span class="line">    method = getattr(self, method_name)</span><br><span class="line">    method()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  a = A()</span><br><span class="line">  a.dispatch(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>在方法前加上统一的前缀是推荐的。</p><h2 id="可以在解释器中实现线程而不依赖系统的线程吗？"><a href="#可以在解释器中实现线程而不依赖系统的线程吗？" class="headerlink" title="可以在解释器中实现线程而不依赖系统的线程吗？"></a>可以在解释器中实现线程而不依赖系统的线程吗？</h2><p>我们通常使用的是 cpython 解释器，而这个解释器的线程需要 c 的线程支持，或者使用完全重新设计的解释器绕过 c 栈。</p><blockquote><p><a href="https://github.com/stackless-dev" target="_blank" rel="noopener">stackless-dev/stackless</a></p></blockquote><p>python 的线程总是被人们诟病，因为 全局解释器锁 ( GIL ) 的存在， python 中只有一个线程在运行，对于 I/O 操作来说， GIL 会在 I/O 前释放，以允许其他线程在这个线程等待 I/O 的时候运行，而非 I/O 呢？它将等待。所以说： <strong>I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程</strong>。</p><blockquote><p>PS :<br>什么是 I/O 密集？涉及到网络、磁盘 I/O 的任务都是 I/O 密集型任务。（CPU 上的时间少）<br>什么是计算密集？消耗 CPU 资源，比如对视频进行解码等。</p></blockquote><p>python 的线程执行必须要 GIL ，所以无论多少核，单位时间里，多个核只能跑一个线程。怎么办？</p><ul><li>使用多进程，每个进程一个 GIL ，所以多进程是没问题的。</li><li>用不带 GIL 的解释器。</li><li>用其他语言扩展，比如 c ，不用 python 实现。</li></ul><h2 id="为什么-lambda-表达式不能包含语句？"><a href="#为什么-lambda-表达式不能包含语句？" class="headerlink" title="为什么 lambda 表达式不能包含语句？"></a>为什么 lambda 表达式不能包含语句？</h2><p>因为 python 的句法框架无法处理嵌套在表达式中的语句。</p><p>使用 lambda 表达式的唯一好处是不再需要创建一个新的函数，并且 lambda 表达只是一个局部变量，而函数相当于 lambda 表达式生成的对象。python 中的 lambda 表达式冒号前是参数，冒号后面是返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  add = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line">  print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="python-如何管理内存？"><a href="#python-如何管理内存？" class="headerlink" title="python 如何管理内存？"></a>python 如何管理内存？</h2><p>python 根据解释器的不同，对于内存的管理也不相同。比如 cpython 使用引用计数来检测不可访问的对象；用另一种收集引用周期的机制：周期性地执行循环检测算法，寻找不可访问的循环并删除其中涉及的对象。 gc 模块提供垃圾收集、获取调试统计信息和调整收集器参数的功能。</p><p>而其他实现，比如 jython 或 pypy ，可以采用不同的机制，比如非模块提供的垃圾收集器。</p><p>在传统的 cpython 下，使用 gc 模块提供的垃圾回收机制，而对于一段开启文件的代码，我们最好的做法是明确关闭文件 ( <code>with</code> ) ，否则将以不同长的时间被收集和关闭。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(file) <span class="keyword">as</span> f:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="为什么-cpython-不使用更传统的垃圾回收机制？"><a href="#为什么-cpython-不使用更传统的垃圾回收机制？" class="headerlink" title="为什么 cpython 不使用更传统的垃圾回收机制？"></a>为什么 cpython 不使用更传统的垃圾回收机制？</h2><p>在 c 中，垃圾回收也不是其标准功能，因此无法移植。</p><p>其次，当 python 嵌入到其他程序中时，它们可能有自己更好的内存垃圾回收方案。</p><h2 id="为什么当-cpython-退出时不会释放所有的内存？"><a href="#为什么当-cpython-退出时不会释放所有的内存？" class="headerlink" title="为什么当 cpython 退出时不会释放所有的内存？"></a>为什么当 cpython 退出时不会释放所有的内存？</h2><p>python 在退出的时候会试图删除每一个对象，但是循环引用可能出现退出的时候无法删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = Sth(), Sth()</span><br><span class="line">a.attr = b</span><br><span class="line">b.attr = a</span><br></pre></td></tr></table></figure><p>如果想要强制摧毁，可以使用 atexit 模块，这个模块可以在退出的时候调用函数，只要在其中写摧毁的方法即可。</p><h2 id="为什么需要单独的元组和列表类型？"><a href="#为什么需要单独的元组和列表类型？" class="headerlink" title="为什么需要单独的元组和列表类型？"></a>为什么需要单独的元组和列表类型？</h2><p>列表和元组类似，但是通常以不同的方式使用。元组被认为是 c 的结构体，它们可以是不同类型作为一组的集合，例如笛卡尔坐标被认为是两个或三个数字的集合；列表更像数组，它倾向于数量不同的相同类型对象。元组不可变，列表可变，只有不可变元素可以作为字典的键值，所以只有元组可以作为键。</p><h2 id="如何实现字典？"><a href="#如何实现字典？" class="headerlink" title="如何实现字典？"></a>如何实现字典？</h2><p>python 中的字典是可调整大小的散列表，用内置 <code>hash()</code> 方法计算键值，可以在 O(1) 的时间里找到目标，这也意味着他没有维护键的排序顺序。</p><h2 id="为什么字典的键必须是不可变的？"><a href="#为什么字典的键必须是不可变的？" class="headerlink" title="为什么字典的键必须是不可变的？"></a>为什么字典的键必须是不可变的？</h2><p>字典哈希表的实现是根据键的 hash 值来查找，如果 key 可变，那么值也在变化，所以对象就找不到了。</p><h2 id="为什么-list-sort-不返回排序的列表？"><a href="#为什么-list-sort-不返回排序的列表？" class="headerlink" title="为什么 list.sort() 不返回排序的列表？"></a>为什么 list.sort() 不返回排序的列表？</h2><p>我们总会记错， <code>list.sort()</code> 在 list 上进行排序，而不会创建新的副本，如果想得到一个副本，可以使用 <code>sorted</code> 内置方法。</p><h2 id="如何在Python中指定并强制执行接口规范？"><a href="#如何在Python中指定并强制执行接口规范？" class="headerlink" title="如何在Python中指定并强制执行接口规范？"></a>如何在Python中指定并强制执行接口规范？</h2><p>首先对于一个类可以用 <code>issubclass()</code> 判断子类，用 <code>isinstance()</code> 判断实例。</p><p>python 的接口规范可以使用测试用例来限制， doctest 和 unittest 模块或第三方测试框架可用于构建详尽的测试套件，以便在模块中执行每行代码，并且推荐在测试中限制。</p><h2 id="为什么没有-goto-？"><a href="#为什么没有-goto-？" class="headerlink" title="为什么没有 goto ？"></a>为什么没有 goto ？</h2><p>goto 确实不好，但是怎么实现呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">label</span><span class="params">(Exception)</span>:</span></span><br><span class="line">  print(<span class="string">'hello2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'hello3'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span>&lt;<span class="number">2</span>:</span><br><span class="line">      print(<span class="string">'hello1'</span>)</span><br><span class="line">      <span class="keyword">raise</span> label()</span><br><span class="line">  <span class="keyword">except</span> label:</span><br><span class="line">    print(<span class="string">'bye'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果是：231</span></span><br><span class="line"><span class="comment"># 为什么？解释器先执行了类啊...</span></span><br></pre></td></tr></table></figure><h2 id="为什么-python-不能在-with-中直接进行属性赋值？"><a href="#为什么-python-不能在-with-中直接进行属性赋值？" class="headerlink" title="为什么 python 不能在 with 中直接进行属性赋值？"></a>为什么 python 不能在 with 中直接进行属性赋值？</h2><p>这句话需要解释一下，看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a)</span>:</span></span><br><span class="line">  <span class="keyword">with</span> a:</span><br><span class="line">    print(a.x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">  x = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  a = A()</span><br><span class="line">  foo(a)</span><br></pre></td></tr></table></figure><p>它是对的，这里的 x 需要它的前缀，而不能直接用 x 代替，这是因为， python 作为动态语言，它不能像静态语言那样，永远知道变量的范围，所以现在我们也不知道这个 x 是全局的还是成员变量亦或是局部变量。</p><p>动态语言的好处比如想要实现下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(args).mydict[index][index].a = <span class="number">21</span></span><br><span class="line">function(args).mydict[index][index].b = <span class="number">42</span></span><br><span class="line">function(args).mydict[index][index].c = <span class="number">63</span></span><br></pre></td></tr></table></figure><p>不需要这么麻烦啦！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ref = function(args).mydict[index][index]</span><br><span class="line">ref.a = <span class="number">21</span></span><br><span class="line">ref.b = <span class="number">42</span></span><br><span class="line">ref.c = <span class="number">63</span></span><br></pre></td></tr></table></figure><hr><p>有些问题这里没有讨论，比如:</p><blockquote><ul><li>为什么不在表达式中赋值？</li><li>为什么字符串不可变？</li><li>为什么 join 作用在字符串而不是列表和元组？</li><li>异常有多快？</li><li>python 除了编译成机器码还能编译成什么语言？</li><li>如何实现列表？</li><li>为什么字符串不能以奇数个反斜杠结尾？</li><li>为什么 if/while/def/class 语句后面要冒号？</li><li>为什么 python 允许在列表和元组的结尾加逗号？</li></ul></blockquote><p>我认为它们没有意义，或者我还没有意识到它们的重要性。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探单例模式</title>
      <link href="/design-pattern/2018-06-04-singleton/"/>
      <url>/design-pattern/2018-06-04-singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/koonchen/design-patterns/tree/master/singleton" target="_blank" rel="noopener">koonchen/design-patterns/singleton</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>保证一个类中仅含有一个实例，并提供一个访问它的全局访问点。</p></blockquote><p>生活中有非常多这样的例子，一个学生管理系统只专注于一所学校，一个人只能拥有一双眼睛、一颗心脏…</p><p>单例模式中，最重要的是<strong>保证一个类只有一个实例并且这个实例可以被访问</strong>。答案是让类自身负责保存它的唯一实例，这就是 Singleton 模式了。</p><p>什么情况下可以使用单例模式：</p><blockquote><ul><li>当一个类中只含有一个实例的同时，可以从一个访问点访问它。</li><li>当唯一实例可以通过子类扩展时，我们无需更改代码就能使用一个扩展了的实例。(待验证)</li></ul></blockquote><p>其关系属于依赖关系，唯一实例受控访问，造成其拥有: </p><p><strong>缩小名空间</strong>、<strong>子类易于配置</strong>、<strong>可变实例数</strong>、<strong>比类操作灵活</strong>的优点。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基础单例实现"><a href="#基础单例实现" class="headerlink" title="基础单例实现"></a>基础单例实现</h3><h4 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"the instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    getInstance().check();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  __instance = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getInstance</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> LazySingleton.__instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">      LazySingleton.__instance = object.__new__(cls)</span><br><span class="line">    <span class="keyword">return</span> LazySingleton.__instance</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'the instance has been created'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> <span class="string">'createError'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  LazySingleton.getInstance().check()</span><br></pre></td></tr></table></figure><p>这样是不够的，原因如下：</p><blockquote><ol><li>我们不能保证静态对象只有一个实例会被声明。</li><li>我们可能没有足够的信息在静态初始时实例化每一个组件，有些值可能需要在程序执行后才能被计算。</li><li>如果语言没有定义转换单元 ( translation unit ) 上全局对象的构造器的调用顺序，那么单件之间就不存在依赖关系；如果有，那么错误是不可避免的。</li><li>无论单件是否用到，它都将被创建。</li></ol></blockquote><hr><h3 id="注册表单例实现"><a href="#注册表单例实现" class="headerlink" title="注册表单例实现"></a>注册表单例实现</h3><p>主要问题是限制唯一实例，再使用，现在使用一种注册表的方法，维护目标从一个实例对象转换成一个注册表，单例类可以根据名字在一个注册表中注册它们的单例实例。注册表也可以查询相应的单例并返回它。</p><h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistrySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map registry = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RegistrySingleton <span class="title">getInstance</span><span class="params">(String classname)</span></span>&#123;</span><br><span class="line">    Object singleton = registry.get(classname);</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        singleton = Class.forName(classname).newInstance();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      registry.put(classname,singleton);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (RegistrySingleton) singleton;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"the instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    getInstance(<span class="string">"RegistrySingleton"</span>).check();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrySingleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  registry = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getSingleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls.registry:</span><br><span class="line">      RegistrySingleton.registry[cls] = object.__new__(cls)</span><br><span class="line">    <span class="keyword">return</span> cls.registry[cls]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'the instance has been created'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> <span class="string">'createError'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  RegistrySingleton.getSingleton().check()</span><br></pre></td></tr></table></figure><p>这是 GoF 书中较为推荐的单例实现。</p><hr><h3 id="java-的其他单例"><a href="#java-的其他单例" class="headerlink" title="java 的其他单例"></a>java 的其他单例</h3><h4 id="饿汉单例"><a href="#饿汉单例" class="headerlink" title="饿汉单例"></a>饿汉单例</h4><p>上面的代码中的 <strong>基础实现</strong> 的 java 代码属于 java 中的 <strong>懒汉</strong> 单例，与之名称呼应的还有一种 <strong>饿汉</strong> 单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"the instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    getInstance().check();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种单例模式虽然线程安全了，但是耗费内存，无法延迟加载。</p><h4 id="懒汉单例"><a href="#懒汉单例" class="headerlink" title="懒汉单例"></a>懒汉单例</h4><p>于是我们回到 <strong>懒汉</strong> 单例上，为了解决其线程不安全的问题，我们对其进行修改，使其线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是这样的单例，性能开销极大。</p><h4 id="单锁懒汉单例"><a href="#单锁懒汉单例" class="headerlink" title="单锁懒汉单例"></a>单锁懒汉单例</h4><p>经过上面的探讨，我们发现将 synchronized 套用在方法上代价太大，不如将其作为块使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>虽然加上了锁，但是等到第一个线程实例化完成，跳出，第二个线程还是可能进入 if 实例化另一个实例，因此线程还是不安全的。</p><h4 id="双锁懒汉单例"><a href="#双锁懒汉单例" class="headerlink" title="双锁懒汉单例"></a>双锁懒汉单例</h4><p>既然如此，不如上两层判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DoubleLockSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> DoubleLockSingleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleLockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (DoubleLockSingleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> DoubleLockSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"the instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    getInstance().check();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在对了吗？并不一定，当语句不满足原子性时，语句将重排，于是我们需要的 instance 可能存在一种 <strong>不为 null 但是仍然未被初始化</strong> 的状态，这样会报错。</p><p>只需要修改变量的可见性即可破解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleLockSingleton instance;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p></blockquote><p>这就组成了完整形态的双锁懒汉。</p><h4 id="内部类单例"><a href="#内部类单例" class="headerlink" title="内部类单例"></a>内部类单例</h4><p>这样的单例与饿汉相似，但是却又不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">InSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InHodler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InSingleton instance = <span class="keyword">new</span> InSingleton();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> InHodler.instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"the instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    getInstance().check();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉单例在类加载实例化对象，内部类单例在需要的时候进行实例化，线程安全，延迟加载，效率高。</p><h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><p>在 Google I/O 2008 上，Joshua Bloch 介绍了这种方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"the instance has been created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    INSTANCE.check();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这应该是 <strong>目前最佳的单例实践</strong> 。</p><hr><h3 id="python-的其他单例"><a href="#python-的其他单例" class="headerlink" title="python 的其他单例"></a>python 的其他单例</h3><p>上面的 python 代码实现书上的单例模式可以说非常的牵强，为了达到这种不能实例化的要求，强行在 <code>__init__</code> 里报错，因为 python 根本不需要这么复杂，它对于单例模式有着天生的优势。下面我们好好讨论一下，不强行报错了… 这里的实现参考 stackover 的一个问题：<a href="https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python" target="_blank" rel="noopener">Creating a singleton in Python</a></p><h4 id="函数装饰器单例"><a href="#函数装饰器单例" class="headerlink" title="函数装饰器单例"></a>函数装饰器单例</h4><p>定义一个函数装饰器，让单例模式可以在多个类上进行复用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">  instances = &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">      instances[cls] = cls()</span><br><span class="line">    <span class="keyword">return</span> instances[cls]</span><br><span class="line">  <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionDecoratorSingleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'the instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  FunctionDecoratorSingleton().check()</span><br></pre></td></tr></table></figure><p>这里使用的是 <strong>函数装饰器</strong> ，它的实现原理和上面的 <strong>注册表单例</strong> 中的 python 本质相同，这种写法和 <code>classmethod</code> 也完全等价，假设我们创建两个实例，判断它们的 id ，也将是一样的。</p><p>看起来很对，但是有一个很致命的问题，这个类并不是真正的类，它是一个方法，我们实例化创建的和使用装饰器实现的实例并不是同一个实例，所以我们在进行如下操作会发现问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = MyClass()</span><br><span class="line">n = MyClass() </span><br><span class="line">o = type(n)() </span><br><span class="line"><span class="comment"># m is n -&gt; true</span></span><br><span class="line"><span class="comment"># m is o -&gt; false</span></span><br></pre></td></tr></table></figure><h4 id="类装饰器单例"><a href="#类装饰器单例" class="headerlink" title="类装饰器单例"></a>类装饰器单例</h4><p>谁说只能用函数装饰器？类装饰器也行啊。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cls)</span>:</span></span><br><span class="line">    self._cls = cls</span><br><span class="line">    self._instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._cls <span class="keyword">not</span> <span class="keyword">in</span> self._instance:</span><br><span class="line">      self._instance[self._cls] = self._cls()</span><br><span class="line">    <span class="keyword">return</span> self._instance[self._cls]</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDecoratorSingleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'the instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  ClassDecoratorSingleton().check()</span><br></pre></td></tr></table></figure><p>看上去很对，但是和函数装饰器有着相同的问题。</p><p>统一总结一下装饰器的单例实现，可以说它们是比继承成为直观的附加，但是这样做还是没有解决根本问题，它的返回还是对象，无法通过上面的 m , n , o 测试。</p><p>并且到目前为止，所有的 python 单例都仅仅是形似，它们都不是真正的单例模式。我们顺着思路往下走</p><blockquote><p><em>PS: 如何修改成真正的单例呢？</em><br>其实就是 python 的文字游戏，非装饰器的实现下，只需要将 <code>getInstnce</code> 的 <code>classmethod</code> 改成 <code>__new__</code> 魔术方法即可。装饰器下怎么实现呢？请看下文。</p></blockquote><h4 id="最佳修饰器实例"><a href="#最佳修饰器实例" class="headerlink" title="最佳修饰器实例"></a>最佳修饰器实例</h4><p>现在我们尝试解决修饰器的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TempClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">    __instance = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">      <span class="keyword">if</span> TempClass.__instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        TempClass.__instance = super(TempClass,cls).__new__(cls, *args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> TempClass.__instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">      super(TempClass, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">  TempClass.__name__ = cls.__name__</span><br><span class="line">  <span class="keyword">return</span> TempClass</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnClassDecoratorSingleton</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'the instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  ReturnClassDecoratorSingleton().check()</span><br></pre></td></tr></table></figure><p>问题的本质在于，我们需要像 <code>__init__</code> 那样，创建一个类，而不是一个实例，现在创建一个返回类的装饰器，所以它是真正的单例实现了，但是问题也很明显，强扭的瓜不甜呢。</p><h4 id="base-class-单例"><a href="#base-class-单例" class="headerlink" title="base class 单例"></a>base class 单例</h4><p>基于一个已经存在的类完成单例操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  __instance = <span class="keyword">None</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(cls.__instance, cls):</span><br><span class="line">      cls.__instance = object.__new__(cls, *args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClassSingleton</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'the instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  BaseClassSingleton().check()</span><br></pre></td></tr></table></figure><p>这是一个真正的类了，实际上我想说的是，它已经将实例化和单例取出的方法统一，没有将单例的获取复杂化，因此可以通过上面的 m , n , o 测试，但是因为多重继承的存在，我们如果对 <code>BaseClassSingleton</code> 进行多重继承，那么 <code>__new__</code> 可能被覆盖。 </p><h4 id="metaclass-单例"><a href="#metaclass-单例" class="headerlink" title="metaclass 单例"></a>metaclass 单例</h4><p>我们尝试在类的创建上下文章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">  __instances = &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls.__instances:</span><br><span class="line">      cls.__instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> cls.__instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaclassSingleton</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'the instance has been created'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  MetaclassSingleton().check()</span><br></pre></td></tr></table></figure><p>这是一个真正的类，存在继承也没有影响，似乎这是 <strong>最优解</strong> 。</p><h4 id="model-单例"><a href="#model-单例" class="headerlink" title="model 单例"></a>model 单例</h4><p>事实上，我们真的需要在 python 中实现单例吗？不见得一定。 Models 在 python 中只 import 一次，所以尽量不要使用全局变量，不要过度思考…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelSingleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'the instance has been created'</span>)</span><br><span class="line">instance = ModelSingleton()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ModelSingleton <span class="keyword">import</span> instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  instance.check()</span><br></pre></td></tr></table></figure><p>它就是单例了。</p>]]></content>
      
      
      <categories>
          
          <category> design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsgi and asgi</title>
      <link href="/technology/2018-05-29-wsgi-and-asgi/"/>
      <url>/technology/2018-05-29-wsgi-and-asgi/</url>
      
        <content type="html"><![CDATA[<h2 id="wsgi-接口规范"><a href="#wsgi-接口规范" class="headerlink" title="wsgi 接口规范"></a>wsgi 接口规范</h2><p>wsgi 『 Web Server Gateway Interface 』 是为 python 语言定义的一种在 web 服务器上和 web 应用程序、框架之间定义的一种通用接口。在 wsgi 之后，很多其他语言也出现了类似的接口。官方对其的解释是： <code>the Python Web Server Gateway Interface</code>  。</p><p>从用户的角度能更直观了解到问题：</p><blockquote><ol><li>我们输了 url ；</li><li>浏览器将 url 组成 http/https 的请求；</li><li>request 请求是 <code>应用层</code> 数据，经过层层包装来到 <code>数据链路层</code> ，从网卡发出；</li><li>在服务器那头反过来，层层解包，获得我们的 request ，交付给 web 应用；</li><li>服务器生成 respond 响应返回，走老路递交给我们的浏览器显示。</li></ol></blockquote><p>在这一系列的过程中，服务器的主要职责是对 『 req —— 比特流 —— res 』 这一变化进行处理；<br>而 web app 的职责是将 request 请求和 response 响应进行屏幕上的反馈。</p><p>问题来了，服务器/客户端怎么将 req/res 和 web app 进行交互？ 通过 wsgi 接口。</p><p>在 wsgi 规范下， web 组件被分成三类： client 、 server 、 middleware 。</p><p>apps 能处理 request ，这也就引发出中间件这一概念， client 被作为它的上游， server 被作为它的下游。</p><p>职责分配：</p><div class="table-container"><table><thead><tr><th>组件</th><th>职能</th></tr></thead><tbody><tr><td>server</td><td>接收请求</td></tr><tr><td>client</td><td>处理结果</td></tr><tr><td>applition</td><td>处理请求</td></tr></tbody></table></div><h2 id="asgi-接口规范"><a href="#asgi-接口规范" class="headerlink" title="asgi 接口规范"></a>asgi 接口规范</h2><p>随着时间的推移，越来越多的人开始热衷于实时响应， HTML5 中的 websocket 给我们展现了一片新大陆，全双工通信也确实不是 <code>ajax 轮询</code> 和 <code>long poll</code> 可以比拟的。 </p><p>那么为什么他会解决服务器上消耗资源的问题呢？下面是我找到唯一一段话看懂的答案。</p><blockquote><p>其实我们所用的程序是要经过两层代理的，即<strong>HTTP协议在Nginx等服务器的解析下</strong>，然后再传送给相应的<strong>Handler（PHP等）</strong>来处理。<br>简单地说，我们有一个非常快速的接<strong>线员（Nginx）</strong>，他负责把问题转交给相应的<strong>客服（Handler）</strong>。<br>本身<strong>接线员基本上速度是足够的</strong>，但是每次都卡在<strong>客服（Handler）</strong>了，老有<strong>客服</strong>处理速度太慢。，导致客服不够。</p></blockquote><p>asgi 『 Asynchronous Server Gateway Interface 』是为了取代 wsgi 而定义的，它的处理类型包括了 websocket 。一次 http 请求信息就开始源源不断地进行着传递了。实时 django 也得以实现。</p><p>asgi 由三个组件组成：协议『 interface server 』、频道『 channel 』、应用 『 consumer 』。频道层沟通协议层和应用层。</p><p>职能分配：</p><div class="table-container"><table><thead><tr><th>组件</th><th>职能</th></tr></thead><tbody><tr><td>interface server</td><td>接收请求、分配请求</td></tr><tr><td>channel</td><td>传递请求、队列系统</td></tr><tr><td>consumer</td><td>处理请求、返回结果</td></tr></tbody></table></div><p>补一张图，便于理解：</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/asgi.jpg" alt="cover"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 各种情况记录</title>
      <link href="/note/2018-05-27-css-notes/"/>
      <url>/note/2018-05-27-css-notes/</url>
      
        <content type="html"><![CDATA[<p>非常有必要记录一下。🧐</p><h2 id="手机-table-宽度无法用百分比指定"><a href="#手机-table-宽度无法用百分比指定" class="headerlink" title="手机 table 宽度无法用百分比指定"></a>手机 table 宽度无法用百分比指定</h2><blockquote><p>table 是一个整体，每一列td的宽度是由一个其中一个最长td的宽度决定的。<br><code>word-wrap: break-word;</code> 无效就要用到 <code>table-layout: fixed;</code> 了。</p></blockquote><p>在 table 标签加入如下 css :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用浏览器默认的换行规则。*/</span></span><br><span class="line"><span class="selector-tag">word-break</span>: <span class="selector-tag">normal</span>;</span><br><span class="line"><span class="comment">/*使用浏览器默认的换行规则。*/</span></span><br><span class="line"><span class="selector-tag">word-wrap</span>: <span class="selector-tag">break-word</span>;</span><br><span class="line"><span class="comment">/*使用浏览器默认的换行规则。*/</span></span><br><span class="line"><span class="selector-tag">table-layout</span>: <span class="selector-tag">fixed</span>;</span><br></pre></td></tr></table></figure><h2 id="手机样式适配"><a href="#手机样式适配" class="headerlink" title="手机样式适配"></a>手机样式适配</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> mediatype and|not|only (media feature) &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mediatype-值"><a href="#mediatype-值" class="headerlink" title="mediatype 值"></a>mediatype 值</h3><div class="table-container"><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>all</td><td>用于所有设备</td></tr><tr><td>aural</td><td>已废弃。用于语音和声音合成器</td></tr><tr><td>braille</td><td>已废弃。 应用于盲文触摸式反馈设备</td></tr><tr><td>embossed</td><td>已废弃。 用于打印的盲人印刷设备</td></tr><tr><td>handheld</td><td>已废弃。 用于掌上设备或更小的装置，如PDA和小型电话</td></tr><tr><td>print</td><td>用于打印机和打印预览</td></tr><tr><td>projection</td><td>已废弃。 用于投影设备</td></tr><tr><td>screen</td><td>用于电脑屏幕，平板电脑，智能手机等。</td></tr><tr><td>speech</td><td>应用于屏幕阅读器等发声设备</td></tr><tr><td>tty</td><td>已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备</td></tr><tr><td>tv</td><td>已废弃。 用于电视和网络电视</td></tr></tbody></table></div><h3 id="media-值"><a href="#media-值" class="headerlink" title="media 值"></a>media 值</h3><div class="table-container"><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>aspect-ratio</td><td>定义输出设备中的页面可见区域宽度与高度的比率</td></tr><tr><td>color</td><td>定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0</td></tr><tr><td>color-index</td><td>定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0</td></tr><tr><td>device-aspect-ratio</td><td>定义输出设备的屏幕可见宽度与高度的比率。</td></tr><tr><td>device-height</td><td>定义输出设备的屏幕可见高度。</td></tr><tr><td>device-width</td><td>定义输出设备的屏幕可见宽度。</td></tr><tr><td>grid</td><td>用来查询输出设备是否使用栅格或点阵。</td></tr><tr><td>height</td><td>定义输出设备中的页面可见区域高度。</td></tr><tr><td>max-aspect-ratio</td><td>定义输出设备的屏幕可见宽度与高度的最大比率。</td></tr><tr><td>max-color</td><td>定义输出设备每一组彩色原件的最大个数。</td></tr><tr><td>max-color-index</td><td>定义在输出设备的彩色查询表中的最大条目数。</td></tr><tr><td>max-device-aspect-ratio</td><td>定义输出设备的屏幕可见宽度与高度的最大比率。</td></tr><tr><td>max-device-height</td><td>定义输出设备的屏幕可见的最大高度。</td></tr><tr><td>max-device-width</td><td>定义输出设备的屏幕最大可见宽度。</td></tr><tr><td>max-height</td><td>定义输出设备中的页面最大可见区域高度。</td></tr><tr><td>max-monochrome</td><td>定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。</td></tr><tr><td>max-resolution</td><td>定义设备的最大分辨率。</td></tr><tr><td>max-width</td><td>定义输出设备中的页面最大可见区域宽度。</td></tr><tr><td>min-aspect-ratio</td><td>定义输出设备中的页面可见区域宽度与高度的最小比率。</td></tr><tr><td>min-color</td><td>定义输出设备每一组彩色原件的最小个数。</td></tr><tr><td>min-color-index</td><td>定义在输出设备的彩色查询表中的最小条目数。</td></tr><tr><td>min-device-aspect-ratio</td><td>定义输出设备的屏幕可见宽度与高度的最小比率。</td></tr><tr><td>min-device-width</td><td>定义输出设备的屏幕最小可见宽度。</td></tr><tr><td>min-device-height</td><td>定义输出设备的屏幕的最小可见高度。</td></tr><tr><td>min-height</td><td>定义输出设备中的页面最小可见区域高度。</td></tr><tr><td>min-monochrome</td><td>定义在一个单色框架缓冲区中每像素包含的最小单色原件个数</td></tr><tr><td>min-resolution</td><td>定义设备的最小分辨率。</td></tr><tr><td>min-width</td><td>定义输出设备中的页面最小可见区域宽度。</td></tr><tr><td>monochrome</td><td>定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0</td></tr><tr><td>orientation</td><td>定义输出设备中的页面可见区域高度是否大于或等于宽度。</td></tr><tr><td>resolution</td><td>定义设备的分辨率。如：96dpi, 300dpi, 118dpcm</td></tr><tr><td>scan</td><td>定义电视类设备的扫描工序。</td></tr><tr><td>width</td><td>定义输出设备中的页面可见区域宽度。</td></tr></tbody></table></div><h2 id="手机-div-overflow-滚动失效"><a href="#手机-div-overflow-滚动失效" class="headerlink" title="手机 div overflow 滚动失效"></a>手机 div overflow 滚动失效</h2><ul><li>[x] 父级设置  <code>relative</code> 或  <code>absolute</code> </li><li>[x] 设置 <code>-webkit-overflow-scrolling: touch</code></li></ul><p>全部失败，情况是有时候双击才能滚动…很迷</p><p>最后发现是这段 <code>css</code> 惹的祸：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span> <span class="selector-class">.highlight</span> <span class="selector-tag">pre</span>,</span><br><span class="line"><span class="selector-class">.post</span> <span class="selector-tag">pre</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">85%</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.45</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#282a36</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更准确地讲是这句不行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span>: 3<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><blockquote><p>我嘟嘟他的圆角嘟嘟。</p></blockquote><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/dudu.jpg" alt="cover"></p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm 搭建踩坑记录</title>
      <link href="/note/2018-05-26-ssm-build-notes/"/>
      <url>/note/2018-05-26-ssm-build-notes/</url>
      
        <content type="html"><![CDATA[<p>小伙伴算法教研岗待不下去了，我怕自己以后也会遇到相同的境遇🙁，所以我们一起学习一下 <strong>ssm</strong> 吧🧐！</p><p>在 github 上搜索出最高赞的 idea 项目。附上链接： <a href="https://github.com/crossoverJie/SSM" target="_blank" rel="noopener">使用 Idea 搭建的 Maven 项目</a> 。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>[x] redis stable 4.0.9</li><li>[x] maven 3.5.3</li><li>[x] mysql</li><li>[x] tomcat 7+</li></ul><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><div class="table-container"><table><thead><tr><th>坑点</th><th>解决</th></tr></thead><tbody><tr><td>数据库需要提前建库</td><td>数据库文件在 <code>ssm/doc/sql</code> 下</td></tr><tr><td>mysql 密码更改</td><td>全局搜索 <code>jdbc.password</code></td></tr><tr><td>redis 端口和地址</td><td>全局搜索 <code>redis.host</code></td></tr><tr><td><code>java.lang.NoSuchMethodError</code></td><td>提问得到解决 <a href="https://github.com/crossoverJie/SSM/issues/33" target="_blank" rel="noopener">issues#33</a></td></tr></tbody></table></div><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有一些引发出来的问题需要得到解决🤪。</p><h3 id="mysql-更改密码"><a href="#mysql-更改密码" class="headerlink" title="mysql 更改密码"></a>mysql 更改密码</h3><blockquote><p> 直觉告诉我，这个问题以后我还是要靠搜索引擎，赶紧记录下来。</p></blockquote><p>1.命令行进入 mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>2.更改密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;newpass&apos;);</span><br></pre></td></tr></table></figure><p>3.<code>quit</code> 退出，再次登录已经需要新的密码了。</p><h3 id="mysql-更新"><a href="#mysql-更新" class="headerlink" title="mysql 更新"></a>mysql 更新</h3><blockquote><p>想别恋要趁早</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 环境配置记录</title>
      <link href="/note/2018-01-06-python-manage-notes/"/>
      <url>/note/2018-01-06-python-manage-notes/</url>
      
        <content type="html"><![CDATA[<p>在 <code>python</code> 的版本和环境管理上选择再三，直接安装 <code>Anaconda</code> 的方式应该是最省心的，但是它太大了，很多额外的科学库是我暂时用不上的，最终我选择 <code>pyenv + pyenv-virtualenv</code> 的方式来进行操作。</p><h2 id="一、使用-pyenv-进行版本管理"><a href="#一、使用-pyenv-进行版本管理" class="headerlink" title="一、使用 pyenv 进行版本管理"></a>一、使用 pyenv 进行版本管理</h2><blockquote><p>使用 <a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">pyenv</a> 管理/切换 python 版本 (<strong>Version Manager</strong>)</p></blockquote><h3 id="1-1-查看可安装版本"><a href="#1-1-查看可安装版本" class="headerlink" title="1.1 查看可安装版本"></a>1.1 查看可安装版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure><h3 id="1-2-安装-python-版本"><a href="#1-2-安装-python-版本" class="headerlink" title="1.2 安装 python 版本"></a>1.2 安装 python 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.6.4rc1</span><br></pre></td></tr></table></figure><h3 id="1-3-查看当前已安装的-python-版本"><a href="#1-3-查看当前已安装的-python-版本" class="headerlink" title="1.3 查看当前已安装的 python 版本"></a>1.3 查看当前已安装的 python 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure><h3 id="1-4-设置-python-版本"><a href="#1-4-设置-python-版本" class="headerlink" title="1.4 设置 python 版本"></a>1.4 设置 python 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 对所有的 shell 有效，会把版本号写入到 ~/.pyenv/version 文件中</span><br><span class="line">pyenv global 3.6.4rc1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 只对当前目录有效，会在当前目录创建 .python-version 文件</span><br><span class="line">pyenv local 3.6.4rc1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 只在当前会话有效</span><br><span class="line">pyenv shell 3.6.4rc1</span><br></pre></td></tr></table></figure><h3 id="1-5-重置版本设置"><a href="#1-5-重置版本设置" class="headerlink" title="1.5 重置版本设置"></a>1.5 重置版本设置</h3><blockquote><p>只有 pyenv shell 和 pyenv local 命令有 —unset 参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv shell --unset</span><br><span class="line">pyenv local --unset</span><br></pre></td></tr></table></figure><h3 id="1-6-卸载-Python-版本"><a href="#1-6-卸载-Python-版本" class="headerlink" title="1.6 卸载 Python 版本"></a>1.6 卸载 Python 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv uninstall 3.6.3</span><br></pre></td></tr></table></figure><h2 id="二、使用-pyenv-virtualenv-进行环境管理"><a href="#二、使用-pyenv-virtualenv-进行环境管理" class="headerlink" title="二、使用 pyenv-virtualenv 进行环境管理"></a>二、使用 pyenv-virtualenv 进行环境管理</h2><blockquote><p><a href="https://github.com/pyenv/pyenv-virtualenv" target="_blank" rel="noopener">pyenv-virtualenv</a> 是 pyenv 的插件，为 pyenv 设置的 python 版本提供隔离的虚拟环境，设置虚拟环境后，在当前目录下面安装的第三方库都不会影响其他环境 (<strong>Environment Manager</strong>)</p></blockquote><h3 id="2-1-创建新的环境"><a href="#2-1-创建新的环境" class="headerlink" title="2.1 创建新的环境"></a>2.1 创建新的环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>pyenv virtualenv 版本号 虚拟环境名</span><br><span class="line">pyenv virtualenv 3.6.4rc1 xxx</span><br></pre></td></tr></table></figure><h3 id="2-2-查看创建的环境"><a href="#2-2-查看创建的环境" class="headerlink" title="2.2 查看创建的环境"></a>2.2 查看创建的环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure><h3 id="2-3-激活和停用环境"><a href="#2-3-激活和停用环境" class="headerlink" title="2.3 激活和停用环境"></a>2.3 激活和停用环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 手动激活</span><br><span class="line">pyenv activate 虚拟环境名</span><br><span class="line">pyenv deactivate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 自动激活</span><br><span class="line"><span class="meta">#</span> 使用pyenv local 虚拟环境名</span><br><span class="line"><span class="meta">#</span> 会把`虚拟环境名`写入当前目录的.python-version文件中</span><br><span class="line"><span class="meta">#</span> 关闭自动激活 -&gt; pyenv deactivate</span><br><span class="line"><span class="meta">#</span> 启动自动激活 -&gt; pyenv activate xxx</span><br><span class="line">pyenv local xxx</span><br></pre></td></tr></table></figure><h3 id="2-4-删除现有virtualenv"><a href="#2-4-删除现有virtualenv" class="headerlink" title="2.4 删除现有virtualenv"></a>2.4 删除现有virtualenv</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv uninstall 虚拟环境名</span><br></pre></td></tr></table></figure><blockquote><p>END</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 常用资源</title>
      <link href="/resource/2017-11-06-general-git-resources/"/>
      <url>/resource/2017-11-06-general-git-resources/</url>
      
        <content type="html"><![CDATA[<p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/git-1.jpg" alt="git-1"></p><h2 id="一、正常开发流程"><a href="#一、正常开发流程" class="headerlink" title="一、正常开发流程"></a>一、正常开发流程</h2><p>​仔细观察上面那张图，我们可以发现 workspace 和 本地repo 是分离的，事实上，我们我们在本地操作的内容是 workspace 里的内容，而其内容来源是本地或者远程。</p><h3 id="1、克隆到本地-repo"><a href="#1、克隆到本地-repo" class="headerlink" title="1、克隆到本地 repo"></a>1、克隆到本地 repo</h3><p>​因此，我们需要做的第一件事，就是将远程的项目克隆一个到本地。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx</span><br></pre></td></tr></table></figure><h3 id="2、创建-develop-分支"><a href="#2、创建-develop-分支" class="headerlink" title="2、创建 develop 分支"></a>2、创建 develop 分支</h3><p>当然我们 clone 操作以后，默认在 master 分支下，首先我们创建一个develop分支，作为开发的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master &gt; git checkout -b develop</span><br></pre></td></tr></table></figure><p>执行该指令以后，我们可以发现我们从原先的 master 分支切换到了 develop 分支。这一步我们也可以省略，但是为了充分展示 git 的基本操作以及良好的开发习惯，我先创建了这个分支。</p><h3 id="3、提交到本地-repo"><a href="#3、提交到本地-repo" class="headerlink" title="3、提交到本地 repo"></a>3、提交到本地 repo</h3><p>​假设我们现在要写的是一个 js ，我们在当前分支下进行一些列工作，比如 <code>touch xxx.js</code> 。</p><p>​等到本地单元测试完成，我们就可以开心愉快地先在本地提交了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">develop &gt; git add .</span><br><span class="line">develop &gt; git commit -m &apos;finish xxx&apos;</span><br></pre></td></tr></table></figure><p>​看下面这张图，你就知道我们在做什么了。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/git-2.png" alt="git-2"></p><h3 id="4、回到-master-分支进行-pull-操作"><a href="#4、回到-master-分支进行-pull-操作" class="headerlink" title="4、回到 master 分支进行 pull 操作"></a>4、回到 master 分支进行 pull 操作</h3><p>​为了下面 <code>push</code> 操作，我们首先进行一次 <code>pull</code> 作为准备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">develop &gt; git checkout master</span><br><span class="line">master &gt; git pull</span><br></pre></td></tr></table></figure><h3 id="5、将-master-分支合并到-develop-分支"><a href="#5、将-master-分支合并到-develop-分支" class="headerlink" title="5、将 master 分支合并到 develop 分支"></a>5、将 master 分支合并到 develop 分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master &gt; git checkout develop</span><br><span class="line">develop &gt; git merge master</span><br></pre></td></tr></table></figure><h3 id="6、将本地-develop-分支提交到远程仓库的-xxx-分支"><a href="#6、将本地-develop-分支提交到远程仓库的-xxx-分支" class="headerlink" title="6、将本地 develop 分支提交到远程仓库的 xxx 分支"></a>6、将本地 develop 分支提交到远程仓库的 xxx 分支</h3><p>​最后，我们将开发好的 develop 分支上传到远程仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">develop &gt; git push --set-upstream origin develop</span><br></pre></td></tr></table></figure><p>​到这里一个完整的基本 git 操作流程就完成了，但是在实际的合作中，我们会遇到各种各样的问题，下面的 <strong>开发问题</strong> 模块持续更新中。</p><h2 id="二、开发问题"><a href="#二、开发问题" class="headerlink" title="二、开发问题"></a>二、开发问题</h2><p>​每一个开发时遇到的问题，都是乱七八糟，甚至是匪夷所思的，那是因为我们接触地还不够多，我在这里设置的每一个问题都有不同的实际场景与不同的解决办法。</p><h3 id="1、对某一些文件我不想在-status-中见到"><a href="#1、对某一些文件我不想在-status-中见到" class="headerlink" title="1、对某一些文件我不想在 status 中见到"></a>1、对某一些文件我不想在 status 中见到</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>​换而言之，我对某一些文件的更改不想 <code>push</code> 到远程仓库，比如我们常常看到的显示方式文件 .DS_Store 文件。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>​现在我们需要在 git 项目下新建一个文件，名为 .gitignore ，顾名思义，就是在这个文件中声明的文件，在 git 操作时都将被忽略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建一个 .gitignore 文件</span><br><span class="line">touch .gitignore</span><br><span class="line"><span class="meta">#</span> 写入内容</span><br><span class="line">vim .gitignore</span><br><span class="line"><span class="meta">#</span> 写入.Ds_Store</span><br></pre></td></tr></table></figure><p>​现在再次查看 <code>git status</code> ，声明的文件已经不见了。</p><h3 id="2、push-时发现有人更新"><a href="#2、push-时发现有人更新" class="headerlink" title="2、push 时发现有人更新"></a>2、push 时发现有人更新</h3><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><p>​比如我有一个内容搞不定，但是在某人帮助下他成功搞定了这个内容，然后 <code>push</code> 到我所在开发的分支上，此时我认为我更改的内容和他更改的内容是不冲突的，但是我此时无法 <code>push</code> 的，只能将远程内容先再次保存回本地。提示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git push origin develop:xxx</span><br><span class="line">To (somewhere)</span><br><span class="line"> ! [rejected]        develop -&gt; xxx (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;(somewhere)&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure><h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>​那么根据提示照做吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进行 pull</span><br><span class="line">git pull origin xxx:develop</span><br></pre></td></tr></table></figure><p>​现在错误已经不再是 <code>push</code> 不上去的问题了。</p><h3 id="3、pull-请求被拒绝"><a href="#3、pull-请求被拒绝" class="headerlink" title="3、pull 请求被拒绝"></a>3、pull 请求被拒绝</h3><h4 id="表现-2"><a href="#表现-2" class="headerlink" title="表现"></a>表现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin xxx:develop</span><br><span class="line">! [rejected]        xxx  -&gt; develop  (non-fast-forward)</span><br></pre></td></tr></table></figure><p>​这是因为因为 <code>commit</code> 版本不一致，导致无法更新，这个错误多发生在多人更改同一个项目，也有可能发生在使用了 <code>git commit --amend</code> or <code>git rebase</code> 操作。</p><h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>​先给出一个临时性的方案，如果你非常确定更改的内容与自己内容的差别，可以使用一种非常简单粗暴的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin develop:xxx</span><br></pre></td></tr></table></figure><p>​当然这个方法用到了 <code>—force</code> ，因此并不推荐。</p><h3 id="4、commit-以后或-push-以后发现有错误"><a href="#4、commit-以后或-push-以后发现有错误" class="headerlink" title="4、commit 以后或 push 以后发现有错误"></a>4、commit 以后或 push 以后发现有错误</h3><h4 id="表现-3"><a href="#表现-3" class="headerlink" title="表现"></a>表现</h4><p>​我们通过 <code>git status</code> 命令查看到一些更改，在使用 <code>git add.</code> 以后，不小心将不必要的内容也加入到了本地 repo ，现在我再想 <code>git push</code> 的话，会将我发现错误的 <code>commit</code> 内容一并发送，那么现在怎么办呢？</p><p>​相似地，<code>commit</code> 时候问题没有解决，我们将内容 <code>push</code> 到了远程仓库，那么此时我们应该怎么办呢？</p><h4 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h4><p>​有一个看似麻烦的方法，使用 <code>git log</code> 指令查看最近 <code>commit</code> 的 hash 值，使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看 log 信息</span><br><span class="line">git log</span><br><span class="line"><span class="meta">#</span> 切换回上一次 commit 的状态</span><br><span class="line">git reset --hard &lt;hashcode&gt;</span><br><span class="line"><span class="meta">#</span> 强制提交</span><br><span class="line">git push --force origin develop:xxx</span><br></pre></td></tr></table></figure><p>​现在，我们回到了上一次 <code>commit</code> 的情况，当然可以重新 <code>add commit</code> 了，这就提醒我们，常常更新本地repo，也就是 <code>commit</code> 到本地，做到一个保存的效果。</p><h3 id="5、回滚以后继续开发"><a href="#5、回滚以后继续开发" class="headerlink" title="5、回滚以后继续开发"></a>5、回滚以后继续开发</h3><h4 id="表现-4"><a href="#表现-4" class="headerlink" title="表现"></a>表现</h4><p>​一个分支出现了问题，我们对其进行回滚，等于对之前的 <code>push</code> 进行了一个相反的操作，错误分支消失了，此时想在之前错误的分支上继续开发应该怎么做呢？</p><h4 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h4><p>​此时，我们应该再次执行回滚 <code>revert</code> 操作。</p><p><img src="https://koonchenblog-1252050022.cos.ap-shanghai.myqcloud.com/img/blog/git回退.png" alt="pic-回退"></p><p>​我们假设基版本为10，我们的错误分支为a，<code>merge a</code> 分支之后，基版本变为11，也就是错误的版本。现在我们进行 <code>revert</code> 版本继续提升，等于提交一个 a 相反的 a’，版本变为12，我们当前进行 <code>merge</code> ，先消除之前的错误。此时，我们再次 <code>revert</code> ，版本成为 13，a 分支又出现了，现在就可以在这个 mr 状态下继续操作了。</p><h3 id="6、meger-冲突解决"><a href="#6、meger-冲突解决" class="headerlink" title="6、meger 冲突解决"></a>6、meger 冲突解决</h3><h4 id="表现-5"><a href="#表现-5" class="headerlink" title="表现"></a>表现</h4><p>​在团队开发中我们常常会遇到 <code>merge</code> 失败的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/master</span><br><span class="line"></span><br><span class="line">Auto-merging &lt;文件路径&gt;</span><br><span class="line">CONFLICT (content): Merge conflict in &lt;文件路径&gt;</span><br><span class="line">fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><h4 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h4><p>​打开指定的文件，可以搜索到 <strong>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</strong> 、<strong>=======</strong> 、 <strong>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</strong> ，这样的符号，比如如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxx</span><br></pre></td></tr></table></figure><p>​意思很简单，HEAD 后面的内容是当前分支上的内容，下面用 <strong>=======</strong> 分割需要 <code>merge</code> 的 xxx 分支，然后显示 xxx 分支下的内容，手动调整即可。</p><h3 id="7、合并-master"><a href="#7、合并-master" class="headerlink" title="7、合并 master"></a>7、合并 master</h3><h4 id="表现-6"><a href="#表现-6" class="headerlink" title="表现"></a>表现</h4><p>​首先讲讲 master、 origin master 与 origin/master 有什么区别？ master 就是本地某个分支名； origin master 代表两个概念，前面 origin 代表远程名，后面的 master 代表远程分支名； origin/master 只代表一个概念，及远程分支名，是从远程拉去代码后在本地的一份拷贝。</p><p>​在日常生活中，我们常常会听到 “合并一下主干” 这样的词汇，那要怎么办呢？</p><h4 id="解决-6"><a href="#解决-6" class="headerlink" title="解决"></a>解决</h4><p>首先确保当前分支在远程有对应的分支，然后进行 <code>git pull</code> ，接着使用 <code>git merge origin/master</code> ，出现错误就逐一更正。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建远程分支</span><br><span class="line">git push --set-upstream origin xxx</span><br><span class="line"><span class="meta">#</span> 获取远程各对应分支代码</span><br><span class="line">git pull</span><br><span class="line"><span class="meta">#</span> 合并主干分支 master 到当前分支</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><h3 id="8、撤销文件修改"><a href="#8、撤销文件修改" class="headerlink" title="8、撤销文件修改"></a>8、撤销文件修改</h3><h4 id="表现-7"><a href="#表现-7" class="headerlink" title="表现"></a>表现</h4><p>​假设我们修改了 a , b 两个文件，我们现在想撤销对 a 的修改，那么这里分三种情况：</p><p>1） 如果没有被 <code>git add</code> 到索引区</p><p>2） 撤销工作区中文件 a 的修改</p><p>3） 如果已被提交，则需要先回退当前提交到工作区，然后撤销文件a的修改</p><h4 id="解决-7"><a href="#解决-7" class="headerlink" title="解决"></a>解决</h4><p>1） 使用 <code>git checkout a</code> 撤销修改</p><p>2） 分两步：第一步， <code>git reset HEAD a</code> 将 a 从索引区移除（但是还是保留在工作区） ； 第二步，根据第一种情况，使用 <code>git checkout a</code> 撤销修改</p><p>3） 分两步：第一步，<code>git reset HEAD^</code> 回退当前提交到工作区 ； 第二步，根据第一种情况，使用 <code>git checkout a</code> 撤销修改</p><p>​之前也讨论过 <code>commit</code> 和 <code>push</code> 以后发生错误，当时使用的方法是 <code>—force</code> ，这里给出的方法更加平和，适合少量错误修改</p><h3 id="9、删除远程分支和本地分支"><a href="#9、删除远程分支和本地分支" class="headerlink" title="9、删除远程分支和本地分支"></a>9、删除远程分支和本地分支</h3><p>1） <code>git push origin --delete xxx</code> 删除远程分支</p><p>2）<code>git branch -d xxx</code> 删除本地分支</p><blockquote><p>CONTINUE…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> resource </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
